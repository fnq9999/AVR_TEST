Interrupt Vectors
    00000 940C 010A JMP	__text_start|__start
    00024 940C 0A5E JMP	_uart0_rx_isr
    00028 940C 0ACF JMP	_uart0_tx_isr

Program Code (text area)
__text_start|__start:
    0010A EFCF      LDI	R28,0xFF
    0010B E1D0      LDI	R29,0x10
    0010C BFCD      OUT	0x3D,R28
    0010D BFDE      OUT	0x3E,R29
    0010E 51CE      SUBI	R28,0x1E
    0010F 40D0      SBCI	R29,0
    00110 EA0A      LDI	R16,0xAA
    00111 8308      ST	Y,R16
    00112 2400      CLR	R0
    00113 E6EC      LDI	R30,0x6C
    00114 E0F2      LDI	R31,2
    00115 E013      LDI	R17,3
    00116 36E9      CPI	R30,0x69
    00117 07F1      CPC	R31,R17
    00118 F011      BEQ	0x011B
    00119 9201      ST	Z+,R0
    0011A CFFB      RJMP	0x0116
    0011B 8300      ST	Z,R16
    0011C EAE8      LDI	R30,0xA8
    0011D E0F0      LDI	R31,0
    0011E E0A0      LDI	R26,0
    0011F E0B1      LDI	R27,1
    00120 E012      LDI	R17,2
    00121 E000      LDI	R16,0
    00122 BF0B      OUT	0x3B,R16
    00123 31E4      CPI	R30,0x14
    00124 07F1      CPC	R31,R17
    00125 F021      BEQ	0x012A
    00126 95C8      LPM
    00127 9631      ADIW	R30,1
    00128 920D      ST	X+,R0
    00129 CFF9      RJMP	0x0123
    0012A 940E 03D5 CALL	_main
_exit:
    0012C CFFF      RJMP	_exit
_val_pc_to_msc:
  i                    --> R20
  t                    --> R16
    0012D 940E 0D7A CALL	push_xgset300C
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\main.c
(0001) /************************************************
(0002) 文件：main.c
(0003) 用途：
(0004) 注意：内部8M晶振
(0005) 创建：2008.4.1
(0006) 修改：2008.4.1
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) 
(0010) #include "config.h"
(0011) #include<time.h>
(0012) 
(0013) unsigned char tem[20];
(0014) unsigned char tem2[20];
(0015) unsigned char read_buf[20]="201110123000";
(0016) unsigned char out_buf[50]="201110095000";
(0017) unsigned char ind=0;
(0018) #define uint8 unsigned char
(0019) 
(0020) void val_pc_to_msc(unsigned char *t){/// string to bcd
(0021) 	 unsigned char i=0;
    0012F 2744      CLR	R20
(0022) 	 for(ind=0;ind<6;++ind){  
    00130 2422      CLR	R2
    00131 9220 0146 STS	ind,R2
    00133 C02E      RJMP	0x0162
(0023) 	 	tem[ind]=(0xf0)&((t[2*ind]-'0'))<<4;
    00134 9020 0146 LDS	R2,ind
    00136 2DE2      MOV	R30,R2
    00137 27FF      CLR	R31
    00138 0FEE      LSL	R30
    00139 1FFF      ROL	R31
    0013A 0FE0      ADD	R30,R16
    0013B 1FF1      ADC	R31,R17
    0013C 8180      LD	R24,Z
    0013D 5380      SUBI	R24,0x30
    0013E 708F      ANDI	R24,0xF
    0013F 9582      SWAP	R24
    00140 7F80      ANDI	R24,0xF0
    00141 E8E0      LDI	R30,0x80
    00142 E0F2      LDI	R31,2
    00143 2DA2      MOV	R26,R2
    00144 27BB      CLR	R27
    00145 0FAE      ADD	R26,R30
    00146 1FBF      ADC	R27,R31
    00147 938C      ST	X,R24
(0024) 		tem[ind]|=(0x0f)&(t[2*ind+1]-'0');
    00148 9020 0146 LDS	R2,ind
    0014A E880      LDI	R24,0x80
    0014B E092      LDI	R25,2
    0014C 2CA2      MOV	R10,R2
    0014D 24BB      CLR	R11
    0014E 0EA8      ADD	R10,R24
    0014F 1EB9      ADC	R11,R25
    00150 2DE2      MOV	R30,R2
    00151 27FF      CLR	R31
    00152 0FEE      LSL	R30
    00153 1FFF      ROL	R31
    00154 0FE0      ADD	R30,R16
    00155 1FF1      ADC	R31,R17
    00156 8181      LDD	R24,Z+1
    00157 5380      SUBI	R24,0x30
    00158 708F      ANDI	R24,0xF
    00159 01F5      MOVW	R30,R10
    0015A 8020      LD	R2,Z
    0015B 2A28      OR	R2,R24
    0015C 8220      ST	Z,R2
    0015D 9180 0146 LDS	R24,ind
    0015F 5F8F      SUBI	R24,0xFF
    00160 9380 0146 STS	ind,R24
    00162 9180 0146 LDS	R24,ind
    00164 3086      CPI	R24,6
    00165 F408      BCC	0x0167
    00166 CFCD      RJMP	0x0134
(0025) 	 }
(0026) 	 for(i=0;i<6;++i){
    00167 2744      CLR	R20
    00168 C011      RJMP	0x017A
(0027) 	 	t[i]=tem[5-i];
    00169 2E24      MOV	R2,R20
    0016A 2433      CLR	R3
    0016B E0E5      LDI	R30,5
    0016C E0F0      LDI	R31,0
    0016D 19E2      SUB	R30,R2
    0016E 09F3      SBC	R31,R3
    0016F E880      LDI	R24,0x80
    00170 E092      LDI	R25,2
    00171 0FE8      ADD	R30,R24
    00172 1FF9      ADC	R31,R25
    00173 8020      LD	R2,Z
    00174 2FE4      MOV	R30,R20
    00175 27FF      CLR	R31
    00176 0FE0      ADD	R30,R16
    00177 1FF1      ADC	R31,R17
    00178 8220      ST	Z,R2
    00179 9543      INC	R20
    0017A 3046      CPI	R20,6
    0017B F368      BCS	0x0169
    0017C 940C 0D7F JMP	pop_xgset300C
_time_init:
  s                    --> R20
    0017E 934A      ST	-Y,R20
    0017F 935A      ST	-Y,R21
    00180 01A8      MOVW	R20,R16
(0028) 	 }
(0029) }
(0030) 
(0031) 
(0032) 
(0033) 
(0034) void time_init(uint8 *s)// s is a string 
(0035) {
(0036) 
(0037)      	val_pc_to_msc(s);
    00181 018A      MOVW	R16,R20
    00182 DFAA      RCALL	_val_pc_to_msc
(0038)          pcf_set_byte(0x02,s[0]);         //秒
    00183 01FA      MOVW	R30,R20
    00184 8120      LD	R18,Z
    00185 2733      CLR	R19
    00186 E002      LDI	R16,2
    00187 940E 052B CALL	_pcf_set_byte
(0039)          pcf_set_byte(0x03,s[1]);         //分钟    
    00189 01FA      MOVW	R30,R20
    0018A 8121      LDD	R18,Z+1
    0018B 2733      CLR	R19
    0018C E003      LDI	R16,3
    0018D 940E 052B CALL	_pcf_set_byte
(0040)          pcf_set_byte(0x04,s[2]);          //时             
    0018F 01FA      MOVW	R30,R20
    00190 8122      LDD	R18,Z+2
    00191 2733      CLR	R19
    00192 E004      LDI	R16,4
    00193 940E 052B CALL	_pcf_set_byte
(0041)          pcf_set_byte(0x05,s[3]);          //日
    00195 01FA      MOVW	R30,R20
    00196 8123      LDD	R18,Z+3
    00197 2733      CLR	R19
    00198 E005      LDI	R16,5
    00199 940E 052B CALL	_pcf_set_byte
(0042)          pcf_set_byte(0x06,0x00);          //星期
    0019B 2722      CLR	R18
    0019C 2733      CLR	R19
    0019D E006      LDI	R16,6
    0019E 940E 052B CALL	_pcf_set_byte
(0043)          pcf_set_byte(0x07,s[4]);          //月
    001A0 01FA      MOVW	R30,R20
    001A1 8124      LDD	R18,Z+4
    001A2 2733      CLR	R19
    001A3 E007      LDI	R16,7
    001A4 940E 052B CALL	_pcf_set_byte
(0044)          pcf_set_byte(0x08,s[5]);          //年
    001A6 01FA      MOVW	R30,R20
    001A7 8125      LDD	R18,Z+5
    001A8 2733      CLR	R19
    001A9 E008      LDI	R16,0x8
    001AA 940E 052B CALL	_pcf_set_byte
(0045) 		 pcf_start();
    001AC 940E 063A CALL	_pcf_start
    001AE 9159      LD	R21,Y+
    001AF 9149      LD	R20,Y+
    001B0 9508      RET
_pre_transfer:
  t                    --> R16
    001B1 934A      ST	-Y,R20
    001B2 935A      ST	-Y,R21
(0046) }
(0047) 
(0048) 
(0049) 
(0050) void pre_transfer(unsigned char *t){
(0051) 	 t[0]&=0x7f;	 t[1]&=0x7f;
    001B3 01F8      MOVW	R30,R16
    001B4 8180      LD	R24,Z
    001B5 778F      ANDI	R24,0x7F
    001B6 8380      ST	Z,R24
    001B7 01CF      MOVW	R24,R30
    001B8 9601      ADIW	R24,1
    001B9 01FC      MOVW	R30,R24
    001BA 8180      LD	R24,Z
    001BB 778F      ANDI	R24,0x7F
    001BC 8380      ST	Z,R24
(0052) 	 t[2]&=0x3f;	 t[3]&=0x3f;
    001BD 01C8      MOVW	R24,R16
    001BE 9602      ADIW	R24,2
    001BF 01FC      MOVW	R30,R24
    001C0 8180      LD	R24,Z
    001C1 738F      ANDI	R24,0x3F
    001C2 8380      ST	Z,R24
    001C3 01A8      MOVW	R20,R16
    001C4 5F4D      SUBI	R20,0xFD
    001C5 4F5F      SBCI	R21,0xFF
    001C6 01FA      MOVW	R30,R20
    001C7 8180      LD	R24,Z
    001C8 738F      ANDI	R24,0x3F
    001C9 8380      ST	Z,R24
(0053)  	 t[4]&=0x07;	 t[5]&=0x1f;
    001CA 01A8      MOVW	R20,R16
    001CB 5F4C      SUBI	R20,0xFC
    001CC 4F5F      SBCI	R21,0xFF
    001CD 01FA      MOVW	R30,R20
    001CE 8180      LD	R24,Z
    001CF 7087      ANDI	R24,7
    001D0 8380      ST	Z,R24
    001D1 01A8      MOVW	R20,R16
    001D2 5F4B      SUBI	R20,0xFB
    001D3 4F5F      SBCI	R21,0xFF
    001D4 01FA      MOVW	R30,R20
    001D5 8180      LD	R24,Z
    001D6 718F      ANDI	R24,0x1F
    001D7 8380      ST	Z,R24
    001D8 9159      LD	R21,Y+
    001D9 9149      LD	R20,Y+
    001DA 9508      RET
_val_msc_to_pc:
  i                    --> R20
  t                    --> R10
    001DB 940E 0D7A CALL	push_xgset300C
    001DD 0158      MOVW	R10,R16
(0054) }
(0055) 
(0056) 
(0057) ///use_to_display_val_to_com_string_ok
(0058) void val_msc_to_pc(unsigned char *t){
(0059) 	 unsigned char i=0;
(0060) 	 ind=0;
    001DE 2422      CLR	R2
    001DF 9220 0146 STS	ind,R2
(0061) 	 for(i=0;i<7;++i){  
    001E1 2744      CLR	R20
    001E2 C02F      RJMP	0x0212
(0062) 	 	tem[ind++]='0'+(t[i]/16);
    001E3 9020 0146 LDS	R2,ind
    001E5 2433      CLR	R3
    001E6 2D82      MOV	R24,R2
    001E7 5F8F      SUBI	R24,0xFF
    001E8 9380 0146 STS	ind,R24
    001EA 2FE4      MOV	R30,R20
    001EB 27FF      CLR	R31
    001EC 0DEA      ADD	R30,R10
    001ED 1DFB      ADC	R31,R11
    001EE 8180      LD	R24,Z
    001EF 9582      SWAP	R24
    001F0 708F      ANDI	R24,0xF
    001F1 5D80      SUBI	R24,0xD0
    001F2 E8E0      LDI	R30,0x80
    001F3 E0F2      LDI	R31,2
    001F4 2DA2      MOV	R26,R2
    001F5 27BB      CLR	R27
    001F6 0FAE      ADD	R26,R30
    001F7 1FBF      ADC	R27,R31
    001F8 938C      ST	X,R24
(0063) 		tem[ind++]='0'+(t[i]%16);
    001F9 9020 0146 LDS	R2,ind
    001FB 2433      CLR	R3
    001FC 2D82      MOV	R24,R2
    001FD 5F8F      SUBI	R24,0xFF
    001FE 9380 0146 STS	ind,R24
    00200 2FE4      MOV	R30,R20
    00201 27FF      CLR	R31
    00202 0DEA      ADD	R30,R10
    00203 1DFB      ADC	R31,R11
    00204 8100      LD	R16,Z
    00205 E110      LDI	R17,0x10
    00206 940E 0D13 CALL	mod8u
    00208 2F80      MOV	R24,R16
    00209 5D80      SUBI	R24,0xD0
    0020A E8E0      LDI	R30,0x80
    0020B E0F2      LDI	R31,2
    0020C 2DA2      MOV	R26,R2
    0020D 27BB      CLR	R27
    0020E 0FAE      ADD	R26,R30
    0020F 1FBF      ADC	R27,R31
    00210 938C      ST	X,R24
    00211 9543      INC	R20
    00212 3047      CPI	R20,7
    00213 F408      BCC	0x0215
    00214 CFCE      RJMP	0x01E3
(0064) 	 }
(0065) 	 tem[ind]='\0';
    00215 E880      LDI	R24,0x80
    00216 E092      LDI	R25,2
    00217 91E0 0146 LDS	R30,ind
    00219 27FF      CLR	R31
    0021A 0FE8      ADD	R30,R24
    0021B 1FF9      ADC	R31,R25
    0021C 2422      CLR	R2
    0021D 8220      ST	Z,R2
(0066) 	 for(i=0;tem[i];++i){
    0021E 2744      CLR	R20
    0021F C00D      RJMP	0x022D
(0067) 	 	t[i]=tem[i];
    00220 E880      LDI	R24,0x80
    00221 E092      LDI	R25,2
    00222 2FE4      MOV	R30,R20
    00223 27FF      CLR	R31
    00224 0FE8      ADD	R30,R24
    00225 1FF9      ADC	R31,R25
    00226 8020      LD	R2,Z
    00227 2FE4      MOV	R30,R20
    00228 27FF      CLR	R31
    00229 0DEA      ADD	R30,R10
    0022A 1DFB      ADC	R31,R11
    0022B 8220      ST	Z,R2
    0022C 9543      INC	R20
    0022D E880      LDI	R24,0x80
    0022E E092      LDI	R25,2
    0022F 2FE4      MOV	R30,R20
    00230 27FF      CLR	R31
    00231 0FE8      ADD	R30,R24
    00232 1FF9      ADC	R31,R25
    00233 8020      LD	R2,Z
    00234 2022      TST	R2
    00235 F751      BNE	0x0220
(0068) 	 }
(0069) 	 t[i]='\0';
    00236 2FE4      MOV	R30,R20
    00237 27FF      CLR	R31
    00238 0DEA      ADD	R30,R10
    00239 1DFB      ADC	R31,R11
    0023A 2422      CLR	R2
    0023B 8220      ST	Z,R2
    0023C 940C 0D7F JMP	pop_xgset300C
_len:
  cnt                  --> R10
  i                    --> R12
  s                    --> R16
    0023E 92AA      ST	-Y,R10
    0023F 92CA      ST	-Y,R12
(0070) 	 
(0071) }
(0072) 
(0073) #define uint8 unsigned char
(0074) unsigned char len(unsigned char *s){
(0075) 		 uint8 i=0,cnt=0;
    00240 24CC      CLR	R12
    00241 24AA      CLR	R10
(0076) 		 for(;s[i];++i){
    00242 C002      RJMP	0x0245
(0077) 		 	++cnt;
    00243 94A3      INC	R10
    00244 94C3      INC	R12
    00245 2DEC      MOV	R30,R12
    00246 27FF      CLR	R31
    00247 0FE0      ADD	R30,R16
    00248 1FF1      ADC	R31,R17
    00249 8020      LD	R2,Z
    0024A 2022      TST	R2
    0024B F7B9      BNE	0x0243
(0078) 		 }
(0079) 		 return cnt;
    0024C 2D0A      MOV	R16,R10
    0024D 90C9      LD	R12,Y+
    0024E 90A9      LD	R10,Y+
    0024F 9508      RET
_msc_to_pc:
  s                    --> R10
    00250 92AA      ST	-Y,R10
    00251 92BA      ST	-Y,R11
    00252 0158      MOVW	R10,R16
    00253 9722      SBIW	R28,2
(0080) }
(0081) 
(0082) 
(0083) /// com_packet
(0084) void msc_to_pc(unsigned char *s){
(0085) 	 Com_putstring (s,len(s),&RTbuf_UART0);
    00254 0185      MOVW	R16,R10
    00255 DFE8      RCALL	_len
    00256 E989      LDI	R24,0x99
    00257 E092      LDI	R25,2
    00258 8399      STD	Y+1,R25
    00259 8388      ST	Y,R24
    0025A 2F20      MOV	R18,R16
    0025B 0185      MOVW	R16,R10
    0025C 940E 0939 CALL	_Com_putstring
    0025E 9622      ADIW	R28,2
    0025F 90B9      LD	R11,Y+
    00260 90A9      LD	R10,Y+
    00261 9508      RET
_pc_to_msc:
  len                  --> R12
  p                    --> R10
    00262 940E 0D75 CALL	push_xgset003C
    00264 2EC2      MOV	R12,R18
    00265 0158      MOVW	R10,R16
    00266 9722      SBIW	R28,2
(0086) }
(0087) void pc_to_msc(unsigned char *p,uint8 len){
(0088) 	 Com_getstring (p,len,&RTbuf_UART0);
    00267 E989      LDI	R24,0x99
    00268 E092      LDI	R25,2
    00269 8399      STD	Y+1,R25
    0026A 8388      ST	Y,R24
    0026B 2D2C      MOV	R18,R12
    0026C 0185      MOVW	R16,R10
    0026D 940E 0986 CALL	_Com_getstring
    0026F 9622      ADIW	R28,2
    00270 940C 0D4F JMP	pop_xgset003C
_out_to_user:
  s                    --> R20
    00272 940E 0D84 CALL	push_xgsetF000
    00274 01A8      MOVW	R20,R16
(0089) }/// com_packet_end
(0090) 
(0091) void out_to_user(uint8 *s){
(0092) 	 ind=0;
    00275 2422      CLR	R2
    00276 9220 0146 STS	ind,R2
(0093)      out_buf[ind++]='2';
    00278 2433      CLR	R3
    00279 2D82      MOV	R24,R2
    0027A 5F8F      SUBI	R24,0xFF
    0027B 9380 0146 STS	ind,R24
    0027D E184      LDI	R24,0x14
    0027E E091      LDI	R25,1
    0027F 2DE2      MOV	R30,R2
    00280 27FF      CLR	R31
    00281 0FE8      ADD	R30,R24
    00282 1FF9      ADC	R31,R25
    00283 E382      LDI	R24,0x32
    00284 8380      ST	Z,R24
(0094) 	 out_buf[ind++]='0';
    00285 9020 0146 LDS	R2,ind
    00287 2433      CLR	R3
    00288 2D82      MOV	R24,R2
    00289 5F8F      SUBI	R24,0xFF
    0028A 9380 0146 STS	ind,R24
    0028C E184      LDI	R24,0x14
    0028D E091      LDI	R25,1
    0028E 2DE2      MOV	R30,R2
    0028F 27FF      CLR	R31
    00290 0FE8      ADD	R30,R24
    00291 1FF9      ADC	R31,R25
    00292 E380      LDI	R24,0x30
    00293 8380      ST	Z,R24
(0095)      out_buf[ind++]=s[12];
    00294 9160 0146 LDS	R22,ind
    00296 2777      CLR	R23
    00297 2F86      MOV	R24,R22
    00298 5F8F      SUBI	R24,0xFF
    00299 9380 0146 STS	ind,R24
    0029B E184      LDI	R24,0x14
    0029C E091      LDI	R25,1
    0029D 2FE6      MOV	R30,R22
    0029E 27FF      CLR	R31
    0029F 0FE8      ADD	R30,R24
    002A0 1FF9      ADC	R31,R25
    002A1 01DA      MOVW	R26,R20
    002A2 961C      ADIW	R26,0xC
    002A3 902C      LD	R2,X
    002A4 8220      ST	Z,R2
(0096) 	 out_buf[ind++]=s[13];
    002A5 9160 0146 LDS	R22,ind
    002A7 2777      CLR	R23
    002A8 2F86      MOV	R24,R22
    002A9 5F8F      SUBI	R24,0xFF
    002AA 9380 0146 STS	ind,R24
    002AC E184      LDI	R24,0x14
    002AD E091      LDI	R25,1
    002AE 2FE6      MOV	R30,R22
    002AF 27FF      CLR	R31
    002B0 0FE8      ADD	R30,R24
    002B1 1FF9      ADC	R31,R25
    002B2 01DA      MOVW	R26,R20
    002B3 961D      ADIW	R26,0xD
    002B4 902C      LD	R2,X
    002B5 8220      ST	Z,R2
(0097) 	 out_buf[ind++]='-';
    002B6 9160 0146 LDS	R22,ind
    002B8 2777      CLR	R23
    002B9 2F86      MOV	R24,R22
    002BA 5F8F      SUBI	R24,0xFF
    002BB 9380 0146 STS	ind,R24
    002BD E184      LDI	R24,0x14
    002BE E091      LDI	R25,1
    002BF 2FE6      MOV	R30,R22
    002C0 27FF      CLR	R31
    002C1 0FE8      ADD	R30,R24
    002C2 1FF9      ADC	R31,R25
    002C3 E28D      LDI	R24,0x2D
    002C4 8380      ST	Z,R24
(0098)      
(0099)      out_buf[ind++]=s[10];
    002C5 9160 0146 LDS	R22,ind
    002C7 2777      CLR	R23
    002C8 2F86      MOV	R24,R22
    002C9 5F8F      SUBI	R24,0xFF
    002CA 9380 0146 STS	ind,R24
    002CC E184      LDI	R24,0x14
    002CD E091      LDI	R25,1
    002CE 2FE6      MOV	R30,R22
    002CF 27FF      CLR	R31
    002D0 0FE8      ADD	R30,R24
    002D1 1FF9      ADC	R31,R25
    002D2 01DA      MOVW	R26,R20
    002D3 961A      ADIW	R26,0xA
    002D4 902C      LD	R2,X
    002D5 8220      ST	Z,R2
(0100) 	 out_buf[ind++]=s[11];
    002D6 9160 0146 LDS	R22,ind
    002D8 2777      CLR	R23
    002D9 2F86      MOV	R24,R22
    002DA 5F8F      SUBI	R24,0xFF
    002DB 9380 0146 STS	ind,R24
    002DD E184      LDI	R24,0x14
    002DE E091      LDI	R25,1
    002DF 2FE6      MOV	R30,R22
    002E0 27FF      CLR	R31
    002E1 0FE8      ADD	R30,R24
    002E2 1FF9      ADC	R31,R25
    002E3 01DA      MOVW	R26,R20
    002E4 961B      ADIW	R26,0xB
    002E5 902C      LD	R2,X
    002E6 8220      ST	Z,R2
(0101) 	 out_buf[ind++]='-';
    002E7 9160 0146 LDS	R22,ind
    002E9 2777      CLR	R23
    002EA 2F86      MOV	R24,R22
    002EB 5F8F      SUBI	R24,0xFF
    002EC 9380 0146 STS	ind,R24
    002EE E184      LDI	R24,0x14
    002EF E091      LDI	R25,1
    002F0 2FE6      MOV	R30,R22
    002F1 27FF      CLR	R31
    002F2 0FE8      ADD	R30,R24
    002F3 1FF9      ADC	R31,R25
    002F4 E28D      LDI	R24,0x2D
    002F5 8380      ST	Z,R24
(0102)      
(0103)      out_buf[ind++]=s[6];
    002F6 9160 0146 LDS	R22,ind
    002F8 2777      CLR	R23
    002F9 2F86      MOV	R24,R22
    002FA 5F8F      SUBI	R24,0xFF
    002FB 9380 0146 STS	ind,R24
    002FD E184      LDI	R24,0x14
    002FE E091      LDI	R25,1
    002FF 2FE6      MOV	R30,R22
    00300 27FF      CLR	R31
    00301 0FE8      ADD	R30,R24
    00302 1FF9      ADC	R31,R25
    00303 01DA      MOVW	R26,R20
    00304 9616      ADIW	R26,6
    00305 902C      LD	R2,X
    00306 8220      ST	Z,R2
(0104) 	 out_buf[ind++]=s[7];
    00307 9160 0146 LDS	R22,ind
    00309 2777      CLR	R23
    0030A 2F86      MOV	R24,R22
    0030B 5F8F      SUBI	R24,0xFF
    0030C 9380 0146 STS	ind,R24
    0030E E184      LDI	R24,0x14
    0030F E091      LDI	R25,1
    00310 2FE6      MOV	R30,R22
    00311 27FF      CLR	R31
    00312 0FE8      ADD	R30,R24
    00313 1FF9      ADC	R31,R25
    00314 01DA      MOVW	R26,R20
    00315 9617      ADIW	R26,7
    00316 902C      LD	R2,X
    00317 8220      ST	Z,R2
(0105) 	 out_buf[ind++]=' ';out_buf[ind++]=' ';
    00318 9160 0146 LDS	R22,ind
    0031A 2777      CLR	R23
    0031B 2F86      MOV	R24,R22
    0031C 5F8F      SUBI	R24,0xFF
    0031D 9380 0146 STS	ind,R24
    0031F E184      LDI	R24,0x14
    00320 E091      LDI	R25,1
    00321 2FE6      MOV	R30,R22
    00322 27FF      CLR	R31
    00323 0FE8      ADD	R30,R24
    00324 1FF9      ADC	R31,R25
    00325 E280      LDI	R24,0x20
    00326 8380      ST	Z,R24
    00327 9160 0146 LDS	R22,ind
    00329 2777      CLR	R23
    0032A 2F86      MOV	R24,R22
    0032B 5F8F      SUBI	R24,0xFF
    0032C 9380 0146 STS	ind,R24
    0032E E184      LDI	R24,0x14
    0032F E091      LDI	R25,1
    00330 2FE6      MOV	R30,R22
    00331 27FF      CLR	R31
    00332 0FE8      ADD	R30,R24
    00333 1FF9      ADC	R31,R25
    00334 E280      LDI	R24,0x20
    00335 8380      ST	Z,R24
(0106)      
(0107)      out_buf[ind++]=s[4];
    00336 9160 0146 LDS	R22,ind
    00338 2777      CLR	R23
    00339 2F86      MOV	R24,R22
    0033A 5F8F      SUBI	R24,0xFF
    0033B 9380 0146 STS	ind,R24
    0033D E184      LDI	R24,0x14
    0033E E091      LDI	R25,1
    0033F 2FE6      MOV	R30,R22
    00340 27FF      CLR	R31
    00341 0FE8      ADD	R30,R24
    00342 1FF9      ADC	R31,R25
    00343 01DA      MOVW	R26,R20
    00344 9614      ADIW	R26,4
    00345 902C      LD	R2,X
    00346 8220      ST	Z,R2
(0108) 	 out_buf[ind++]=s[5];
    00347 9160 0146 LDS	R22,ind
    00349 2777      CLR	R23
    0034A 2F86      MOV	R24,R22
    0034B 5F8F      SUBI	R24,0xFF
    0034C 9380 0146 STS	ind,R24
    0034E E184      LDI	R24,0x14
    0034F E091      LDI	R25,1
    00350 2FE6      MOV	R30,R22
    00351 27FF      CLR	R31
    00352 0FE8      ADD	R30,R24
    00353 1FF9      ADC	R31,R25
    00354 01DA      MOVW	R26,R20
    00355 9615      ADIW	R26,5
    00356 902C      LD	R2,X
    00357 8220      ST	Z,R2
(0109) 	 out_buf[ind++]=':';
    00358 9160 0146 LDS	R22,ind
    0035A 2777      CLR	R23
    0035B 2F86      MOV	R24,R22
    0035C 5F8F      SUBI	R24,0xFF
    0035D 9380 0146 STS	ind,R24
    0035F E184      LDI	R24,0x14
    00360 E091      LDI	R25,1
    00361 2FE6      MOV	R30,R22
    00362 27FF      CLR	R31
    00363 0FE8      ADD	R30,R24
    00364 1FF9      ADC	R31,R25
    00365 E38A      LDI	R24,0x3A
    00366 8380      ST	Z,R24
(0110) 	 out_buf[ind++]=s[2];
    00367 9160 0146 LDS	R22,ind
    00369 2777      CLR	R23
    0036A 2F86      MOV	R24,R22
    0036B 5F8F      SUBI	R24,0xFF
    0036C 9380 0146 STS	ind,R24
    0036E E184      LDI	R24,0x14
    0036F E091      LDI	R25,1
    00370 2FE6      MOV	R30,R22
    00371 27FF      CLR	R31
    00372 0FE8      ADD	R30,R24
    00373 1FF9      ADC	R31,R25
    00374 01DA      MOVW	R26,R20
    00375 9612      ADIW	R26,2
    00376 902C      LD	R2,X
    00377 8220      ST	Z,R2
(0111) 	 out_buf[ind++]=s[3];
    00378 9160 0146 LDS	R22,ind
    0037A 2777      CLR	R23
    0037B 2F86      MOV	R24,R22
    0037C 5F8F      SUBI	R24,0xFF
    0037D 9380 0146 STS	ind,R24
    0037F E184      LDI	R24,0x14
    00380 E091      LDI	R25,1
    00381 2FE6      MOV	R30,R22
    00382 27FF      CLR	R31
    00383 0FE8      ADD	R30,R24
    00384 1FF9      ADC	R31,R25
    00385 01DA      MOVW	R26,R20
    00386 9613      ADIW	R26,3
    00387 902C      LD	R2,X
    00388 8220      ST	Z,R2
(0112) 	 out_buf[ind++]=':';
    00389 9160 0146 LDS	R22,ind
    0038B 2777      CLR	R23
    0038C 2F86      MOV	R24,R22
    0038D 5F8F      SUBI	R24,0xFF
    0038E 9380 0146 STS	ind,R24
    00390 E184      LDI	R24,0x14
    00391 E091      LDI	R25,1
    00392 2FE6      MOV	R30,R22
    00393 27FF      CLR	R31
    00394 0FE8      ADD	R30,R24
    00395 1FF9      ADC	R31,R25
    00396 E38A      LDI	R24,0x3A
    00397 8380      ST	Z,R24
(0113) 	 out_buf[ind++]=s[0];
    00398 9160 0146 LDS	R22,ind
    0039A 2777      CLR	R23
    0039B 2F86      MOV	R24,R22
    0039C 5F8F      SUBI	R24,0xFF
    0039D 9380 0146 STS	ind,R24
    0039F E184      LDI	R24,0x14
    003A0 E091      LDI	R25,1
    003A1 2FE6      MOV	R30,R22
    003A2 27FF      CLR	R31
    003A3 0FE8      ADD	R30,R24
    003A4 1FF9      ADC	R31,R25
    003A5 01DA      MOVW	R26,R20
    003A6 902C      LD	R2,X
    003A7 8220      ST	Z,R2
(0114) 	 out_buf[ind++]=s[1];
    003A8 9160 0146 LDS	R22,ind
    003AA 2777      CLR	R23
    003AB 2F86      MOV	R24,R22
    003AC 5F8F      SUBI	R24,0xFF
    003AD 9380 0146 STS	ind,R24
    003AF E184      LDI	R24,0x14
    003B0 E091      LDI	R25,1
    003B1 2FE6      MOV	R30,R22
    003B2 27FF      CLR	R31
    003B3 0FE8      ADD	R30,R24
    003B4 1FF9      ADC	R31,R25
    003B5 9611      ADIW	R26,1
    003B6 902C      LD	R2,X
    003B7 8220      ST	Z,R2
(0115) 	 out_buf[ind++]='\n';
    003B8 9140 0146 LDS	R20,ind
    003BA 2755      CLR	R21
    003BB 2F84      MOV	R24,R20
    003BC 5F8F      SUBI	R24,0xFF
    003BD 9380 0146 STS	ind,R24
    003BF E184      LDI	R24,0x14
    003C0 E091      LDI	R25,1
    003C1 2FE4      MOV	R30,R20
    003C2 27FF      CLR	R31
    003C3 0FE8      ADD	R30,R24
    003C4 1FF9      ADC	R31,R25
    003C5 E08A      LDI	R24,0xA
    003C6 8380      ST	Z,R24
(0116) 	 out_buf[ind]='\0';
    003C7 E184      LDI	R24,0x14
    003C8 E091      LDI	R25,1
    003C9 91E0 0146 LDS	R30,ind
    003CB 27FF      CLR	R31
    003CC 0FE8      ADD	R30,R24
    003CD 1FF9      ADC	R31,R25
    003CE 2422      CLR	R2
    003CF 8220      ST	Z,R2
(0117)    	 msc_to_pc(out_buf);	
    003D0 E104      LDI	R16,0x14
    003D1 E011      LDI	R17,1
    003D2 DE7D      RCALL	_msc_to_pc
    003D3 940C 0D89 JMP	pop_xgsetF000
_main:
  ng                   --> R12
  W_Buff               --> R20
  R_Buff               --> R20
  key_brk              --> R22
  Key                  --> R10
  i                    --> R22
  j                    --> R10
    003D5 9722      SBIW	R28,2
(0118) }
(0119) 
(0120) void main(void)
(0121) {
(0122)      unsigned char *W_Buff="www.avrvi.com",*R_Buff="\0",i=0,j=0,Key,key_brk,ng;
    003D6 E148      LDI	R20,0x18
    003D7 E052      LDI	R21,2
    003D8 24AA      CLR	R10
(0123) 	 
(0124) 	 //// init_process
(0125) 	 CLI();
    003D9 94F8      BCLR	7
(0126) 	 Com_init();
    003DA 940E 08E3 CALL	_Com_init
(0127) 	 twi_init();
    003DC 940E 0B18 CALL	_twi_init
(0128)      CLI();
    003DE 94F8      BCLR	7
(0129)      ng= read_temperature();
    003DF 940E 0BE2 CALL	_read_temperature
(0130)      delay_nms(500);
    003E1 EF04      LDI	R16,0xF4
    003E2 E011      LDI	R17,1
    003E3 940E 0691 CALL	_delay_nms
(0131)      delay_nms(1000);
    003E5 EE08      LDI	R16,0xE8
    003E6 E013      LDI	R17,3
    003E7 940E 0691 CALL	_delay_nms
(0132)      ng= read_temperature();
    003E9 940E 0BE2 CALL	_read_temperature
    003EB 2EC0      MOV	R12,R16
(0133)      SEI();
    003EC 9478      BSET	7
(0134) //         ng= read_temperature();
(0135)  	 //// init_process_end
(0136) 	 
(0137) 	 //pcf 
(0138) //	 msc_to_pc("Plead write the time to the msc now!\n\n");
(0139) //     while(1);
(0140) // msc_to_pc("24C01 Write: www.avrvi.com\n\n");
(0141) //	 time_init(read_buf);
(0142) //	 pcf_start();
(0143) 	//pcf_init_end	
(0144) //	 delay_nms(5000);	 
(0145) 
(0146) //////////////////////////////////////////////exp_process
(0147) 
(0148) /////////////////////////led_test
(0149) 
(0150) 
(0151)    	 msc_to_pc("led_test\n");
    003ED E00E      LDI	R16,0xE
    003EE E012      LDI	R17,2
    003EF DE60      RCALL	_msc_to_pc
(0152)      delay_nms(500);
    003F0 EF04      LDI	R16,0xF4
    003F1 E011      LDI	R17,1
    003F2 940E 0691 CALL	_delay_nms
(0153)      Com_disable();
    003F4 940E 08F5 CALL	_Com_disable
(0154)  PORTE = 0xFF;
    003F6 EF8F      LDI	R24,0xFF
    003F7 B983      OUT	0x03,R24
(0155)  DDRE  = 0xFF;
    003F8 B982      OUT	0x02,R24
(0156) 
(0157)  	   for(i=0;i<3;i++)
    003F9 2766      CLR	R22
    003FA C00D      RJMP	0x0408
(0158) 	 	 {
(0159) 		  PORTE = 0;
    003FB 2422      CLR	R2
    003FC B823      OUT	0x03,R2
(0160) 		  delay_nms(300);
    003FD E20C      LDI	R16,0x2C
    003FE E011      LDI	R17,1
    003FF 940E 0691 CALL	_delay_nms
(0161) 		  PORTE = 0xff;
    00401 EF8F      LDI	R24,0xFF
    00402 B983      OUT	0x03,R24
(0162) 		  delay_nms(300);
    00403 E20C      LDI	R16,0x2C
    00404 E011      LDI	R17,1
    00405 940E 0691 CALL	_delay_nms
    00407 9563      INC	R22
    00408 3063      CPI	R22,3
    00409 F388      BCS	0x03FB
(0163) 		 }
(0164)          Com_init();
    0040A 940E 08E3 CALL	_Com_init
(0165) //.///////////////////////led_test_end
(0166) 
(0167) 
(0168) 
(0169) //8.ds18b20
(0170)     
(0171) 
(0172)     msc_to_pc("DS18B20\n");
    0040C E005      LDI	R16,5
    0040D E012      LDI	R17,2
    0040E DE41      RCALL	_msc_to_pc
(0173)     convert_temp_data();
    0040F 940E 0C02 CALL	_convert_temp_data
(0174)     msc_to_pc(current_temp_display_buffer);
    00411 E405      LDI	R16,0x45
    00412 E012      LDI	R17,2
    00413 DE3C      RCALL	_msc_to_pc
(0175)     
(0176) //8.ds18b20_end
(0177)     
(0178) 
(0179) 
(0180) 
(0181) /////////////////////////seg7
(0182) 
(0183)    	 msc_to_pc("\nSEG7_test\n");
    00414 EF09      LDI	R16,0xF9
    00415 E011      LDI	R17,1
    00416 DE39      RCALL	_msc_to_pc
(0184) 		HC_595_init();
    00417 940E 06A1 CALL	_HC_595_init
(0185) 		//  Seg7_Led_display(111*i)
(0186) 		 for(i=0;i<10;i++)
    00419 2766      CLR	R22
    0041A C013      RJMP	0x042E
(0187) 	 	 {
(0188) 		  for(j=0;j<200;++j){
    0041B 24AA      CLR	R10
    0041C C00D      RJMP	0x042A
(0189) 		  	Seg7_Led_display(1111*i);
    0041D 2F26      MOV	R18,R22
    0041E 2733      CLR	R19
    0041F E507      LDI	R16,0x57
    00420 E014      LDI	R17,4
    00421 940E 0D3F CALL	empy16s
    00423 940E 0737 CALL	_Seg7_Led_display
(0190)      		  delay_nms(1);
    00425 E001      LDI	R16,1
    00426 E010      LDI	R17,0
    00427 940E 0691 CALL	_delay_nms
    00429 94A3      INC	R10
    0042A 2D8A      MOV	R24,R10
    0042B 3C88      CPI	R24,0xC8
    0042C F380      BCS	0x041D
    0042D 9563      INC	R22
    0042E 306A      CPI	R22,0xA
    0042F F358      BCS	0x041B
(0191) 		  }  
(0192) 		 }
(0193) 
(0194) 
(0195) /////////////////////////seg7_test_end
(0196) 
(0197) 
(0198) 
(0199) /////////////////////////BUZZ_KEY_test
(0200) 
(0201)    	 msc_to_pc("BUZZ_KEY_test\n");
    00430 EE0A      LDI	R16,0xEA
    00431 E011      LDI	R17,1
    00432 DE1D      RCALL	_msc_to_pc
(0202)       DDRE = 0xFF;
    00433 EF8F      LDI	R24,0xFF
    00434 B982      OUT	0x02,R24
(0203)        PORTE = 0xFF;
    00435 B983      OUT	0x03,R24
(0204)     Key_init();
    00436 940E 08BF CALL	_Key_init
(0205)     Buzz_init();
    00438 940E 0666 CALL	_Buzz_init
(0206) 	key_brk=0;
    0043A 2766      CLR	R22
    0043B C071      RJMP	0x04AD
(0207) 	while(1) {
(0208) 		if(key_brk)break;
    0043C 2366      TST	R22
    0043D F009      BEQ	0x043F
    0043E C06F      RJMP	0x04AE
(0209)         Key=get_key();
    0043F 940E 08C4 CALL	_get_key
    00441 2EA0      MOV	R10,R16
(0210)         switch(Key) {
    00442 24BB      CLR	R11
    00443 01C5      MOVW	R24,R10
    00444 3B80      CPI	R24,0xB0
    00445 E0E0      LDI	R30,0
    00446 079E      CPC	R25,R30
    00447 F409      BNE	0x0449
    00448 C037      RJMP	0x0480
    00449 EB80      LDI	R24,0xB0
    0044A 158A      CP	R24,R10
    0044B 059B      CPC	R25,R11
    0044C F034      BLT	0x0453
    0044D 01C5      MOVW	R24,R10
    0044E 3780      CPI	R24,0x70
    0044F E0E0      LDI	R30,0
    00450 079E      CPC	R25,R30
    00451 F099      BEQ	0x0465
    00452 C05A      RJMP	0x04AD
    00453 01C5      MOVW	R24,R10
    00454 3D80      CPI	R24,0xD0
    00455 E0E0      LDI	R30,0
    00456 079E      CPC	R25,R30
    00457 F409      BNE	0x0459
    00458 C03C      RJMP	0x0495
    00459 3D80      CPI	R24,0xD0
    0045A E0E0      LDI	R30,0
    0045B 079E      CPC	R25,R30
    0045C F40C      BGE	0x045E
    0045D C04F      RJMP	0x04AD
    0045E 01C5      MOVW	R24,R10
    0045F 3E80      CPI	R24,0xE0
    00460 E0E0      LDI	R30,0
    00461 079E      CPC	R25,R30
    00462 F409      BNE	0x0464
    00463 C040      RJMP	0x04A4
    00464 C048      RJMP	0x04AD
(0211)             case ( ((1<<S4)^0xF0) ): {
(0212)                 PORTE =~ (1<<3);
    00465 EF87      LDI	R24,0xF7
    00466 B983      OUT	0x03,R24
(0213)                 Beep(100,50);
    00467 E322      LDI	R18,0x32
    00468 E030      LDI	R19,0
    00469 E604      LDI	R16,0x64
    0046A E010      LDI	R17,0
    0046B 940E 0671 CALL	_Beep
(0214)                 Beep(100,50);
    0046D E322      LDI	R18,0x32
    0046E E030      LDI	R19,0
    0046F E604      LDI	R16,0x64
    00470 E010      LDI	R17,0
    00471 940E 0671 CALL	_Beep
(0215)                 Beep(100,50);
    00473 E322      LDI	R18,0x32
    00474 E030      LDI	R19,0
    00475 E604      LDI	R16,0x64
    00476 E010      LDI	R17,0
    00477 940E 0671 CALL	_Beep
(0216)                 Beep(100,50);
    00479 E322      LDI	R18,0x32
    0047A E030      LDI	R19,0
    0047B E604      LDI	R16,0x64
    0047C E010      LDI	R17,0
    0047D 940E 0671 CALL	_Beep
(0217) 				break;
    0047F C02D      RJMP	0x04AD
(0218)             }
(0219)             case ( ((1<<S3)^0xF0) ): {
(0220)                 PORTE =~ (1<<2);
    00480 EF8B      LDI	R24,0xFB
    00481 B983      OUT	0x03,R24
(0221)                 Beep(100,50);
    00482 E322      LDI	R18,0x32
    00483 E030      LDI	R19,0
    00484 E604      LDI	R16,0x64
    00485 E010      LDI	R17,0
    00486 940E 0671 CALL	_Beep
(0222)                 Beep(100,50);
    00488 E322      LDI	R18,0x32
    00489 E030      LDI	R19,0
    0048A E604      LDI	R16,0x64
    0048B E010      LDI	R17,0
    0048C 940E 0671 CALL	_Beep
(0223)                 Beep(100,50);
    0048E E322      LDI	R18,0x32
    0048F E030      LDI	R19,0
    00490 E604      LDI	R16,0x64
    00491 E010      LDI	R17,0
    00492 940E 0671 CALL	_Beep
(0224) 				break;
    00494 C018      RJMP	0x04AD
(0225)             }
(0226)             case ( ((1<<S2)^0xF0) ): {
(0227)                 PORTE =~ (1<<1);
    00495 EF8D      LDI	R24,0xFD
    00496 B983      OUT	0x03,R24
(0228)                 Beep(100,50);
    00497 E322      LDI	R18,0x32
    00498 E030      LDI	R19,0
    00499 E604      LDI	R16,0x64
    0049A E010      LDI	R17,0
    0049B 940E 0671 CALL	_Beep
(0229)                 Beep(100,50);
    0049D E322      LDI	R18,0x32
    0049E E030      LDI	R19,0
    0049F E604      LDI	R16,0x64
    004A0 E010      LDI	R17,0
    004A1 940E 0671 CALL	_Beep
(0230) 				break;
    004A3 C009      RJMP	0x04AD
(0231)             }
(0232)             case ( ((1<<S1)^0xF0) ): {
(0233)                 PORTE =~ (1<<0);
    004A4 EF8E      LDI	R24,0xFE
    004A5 B983      OUT	0x03,R24
(0234)                 Beep(100,50);
    004A6 E322      LDI	R18,0x32
    004A7 E030      LDI	R19,0
    004A8 E604      LDI	R16,0x64
    004A9 E010      LDI	R17,0
    004AA 940E 0671 CALL	_Beep
(0235) 				key_brk=1;
    004AC E061      LDI	R22,1
    004AD CF8E      RJMP	0x043C
(0236)                 break;
(0237)             }
(0238)             default: {
(0239)                 break;
(0240)             }
(0241)         }
(0242) 
(0243)     }
(0244) 	
(0245) 
(0246) 
(0247) /////////////////////////BUZZ_KEY_test_end
(0248) // 1.read the pcf_init_data
(0249) 
(0250)    	 msc_to_pc("read the pcf_init_data\n");
    004AE ED02      LDI	R16,0xD2
    004AF E011      LDI	R17,1
    004B0 DD9F      RCALL	_msc_to_pc
(0251) 	 pcfread(tem2,2,7);/// get the bcd_to_year
    004B1 E087      LDI	R24,7
    004B2 E090      LDI	R25,0
    004B3 8399      STD	Y+1,R25
    004B4 8388      ST	Y,R24
    004B5 E022      LDI	R18,2
    004B6 E030      LDI	R19,0
    004B7 E60C      LDI	R16,0x6C
    004B8 E012      LDI	R17,2
    004B9 940E 0657 CALL	_pcfread
(0252) 	 pre_transfer(tem2);///and op
    004BB E60C      LDI	R16,0x6C
    004BC E012      LDI	R17,2
    004BD DCF3      RCALL	_pre_transfer
(0253)      val_msc_to_pc(tem2);/// bcd to string
    004BE E60C      LDI	R16,0x6C
    004BF E012      LDI	R17,2
    004C0 DD1A      RCALL	_val_msc_to_pc
(0254)    	 msc_to_pc("read the pcf_init_data_end\n");
    004C1 EB06      LDI	R16,0xB6
    004C2 E011      LDI	R17,1
    004C3 DD8C      RCALL	_msc_to_pc
(0255) // 2.pcf_init_data_read to pc
(0256)    out_to_user(tem2);
    004C4 E60C      LDI	R16,0x6C
    004C5 E012      LDI	R17,2
    004C6 DDAB      RCALL	_out_to_user
(0257) //3. update the pcf data_to now time
(0258)    	 msc_to_pc("update the pcf data_to now time\n");	 
    004C7 E905      LDI	R16,0x95
    004C8 E011      LDI	R17,1
    004C9 DD86      RCALL	_msc_to_pc
(0259)      time_init(read_buf);
    004CA E000      LDI	R16,0
    004CB E011      LDI	R17,1
    004CC DCB1      RCALL	_time_init
(0260) // 4.read the pcd_now_data
(0261)     pcfread(tem2,2,7);/// get the bcd_to_year
    004CD E087      LDI	R24,7
    004CE E090      LDI	R25,0
    004CF 8399      STD	Y+1,R25
    004D0 8388      ST	Y,R24
    004D1 E022      LDI	R18,2
    004D2 E030      LDI	R19,0
    004D3 E60C      LDI	R16,0x6C
    004D4 E012      LDI	R17,2
    004D5 940E 0657 CALL	_pcfread
(0262) 	pre_transfer(tem2);///and op
    004D7 E60C      LDI	R16,0x6C
    004D8 E012      LDI	R17,2
    004D9 DCD7      RCALL	_pre_transfer
(0263) 	val_msc_to_pc(tem2);/// bcd to string
    004DA E60C      LDI	R16,0x6C
    004DB E012      LDI	R17,2
    004DC DCFE      RCALL	_val_msc_to_pc
(0264) 	
(0265) // 5.pcf_now_data_read to pc
(0266) 	out_to_user(tem2);
    004DD E60C      LDI	R16,0x6C
    004DE E012      LDI	R17,2
    004DF DD92      RCALL	_out_to_user
(0267) // 6.write_to_at24c01
(0268)    	msc_to_pc("The string written to the AT24C01 is: \"GOOD_EXP\"\n");
    004E0 E603      LDI	R16,0x63
    004E1 E011      LDI	R17,1
    004E2 DD6D      RCALL	_msc_to_pc
(0269) 	 //wt24c(W_Buff,0x00,13);
(0270) 	 wt24c("GOOD_EXP\n\0",0x00,10);
    004E3 E08A      LDI	R24,0xA
    004E4 E090      LDI	R25,0
    004E5 8399      STD	Y+1,R25
    004E6 8388      ST	Y,R24
    004E7 2722      CLR	R18
    004E8 2733      CLR	R19
    004E9 E508      LDI	R16,0x58
    004EA E011      LDI	R17,1
    004EB 940E 056B CALL	_wt24c
(0271) //7.at24c01_to_pc
(0272)    	msc_to_pc("GET THE STRING:\n");
    004ED E407      LDI	R16,0x47
    004EE E011      LDI	R17,1
    004EF DD60      RCALL	_msc_to_pc
(0273) 	rd24c(R_Buff,0x00,10);
    004F0 E08A      LDI	R24,0xA
    004F1 E090      LDI	R25,0
    004F2 8399      STD	Y+1,R25
    004F3 8388      ST	Y,R24
    004F4 2722      CLR	R18
    004F5 2733      CLR	R19
    004F6 018A      MOVW	R16,R20
    004F7 940E 05CF CALL	_rd24c
(0274) 	msc_to_pc(R_Buff);
    004F9 018A      MOVW	R16,R20
    004FA DD55      RCALL	_msc_to_pc
(0275) 
(0276)     
(0277) while(1);
    004FB CFFF      RJMP	0x04FB
(0278) ////////////////////////////////////////exp_process_end
(0279) 
(0280) 	 wt24c(W_Buff,0x00,13);
(0281) 	 delay_nms(500);
(0282) 	 //Com_putstring ("24C01 Read: ",12,&RTbuf_UART0);
(0283) 	 rd24c(R_Buff,0x00,13);Com_putstring (R_Buff,13,&RTbuf_UART0);
(0284) 	 //Com_putstring ("\n\n",2,&RTbuf_UART0);
(0285)      delay_nms(500);
(0286) 	 while(1)
    004FC CFFF      RJMP	0x04FC
    004FD 9622      ADIW	R28,2
    004FE 9508      RET
_wt24c_fc:
  t                    --> R22
  n                    --> R10
  ad                   --> R12
  p                    --> R20
    004FF 940E 0D9C CALL	push_xgsetF03C
    00501 0169      MOVW	R12,R18
    00502 01A8      MOVW	R20,R16
    00503 84A8      LDD	R10,Y+8
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\AT24C01.c
(0001) /************************************************
(0002) 文件：AT24C01.c
(0003) 用途：AT24C01操作函数
(0004) 注意：
(0005) 创建：2008.1.26
(0006) 修改：2008.1.26
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) unsigned char syserr;
(0011) /*************************************************************************
(0012) ** 函数名称: unsigned char * wt24c_fc(unsigned char *p, unsigned int ad, unsigned char n)
(0013) ** 功能描述: 向24Cxx写入数据wt24c_h()所要调用的函数
(0014) ** 输　入: 
(0015) ** 输出	 : 返回写入n个字节后的主机内存指针
(0016) ** 全局变量: 无
(0017) ** 调用模块: 
(0018) ** 说明：
(0019) ** 注意：
(0020) **************************************************************************/
(0021) 
(0022) 
(0023) 
(0024) unsigned char * wt24c_fc(unsigned char *p, unsigned int ad, unsigned char n)
(0025) {
(0026) 	unsigned char t=0;
(0027) 
(0028) 	#if e2prom<32
(0029) 	t=ad>>8;
    00504 01B6      MOVW	R22,R12
    00505 2F67      MOV	R22,R23
    00506 2777      CLR	R23
(0030) 	t<<=1;
    00507 0F66      LSL	R22
(0031) 	#endif
(0032) 	
(0033) 	i2cstart();					//发送起始信号
    00508 940E 0B26 CALL	_i2cstart
(0034) 		
(0035) 	if(i2cwt(W_ADD_COM+t)==SLAW)//发送SLA_W, 写字节命令及器件地址
    0050A 2F06      MOV	R16,R22
    0050B 5600      SUBI	R16,0x60
    0050C 940E 0B2E CALL	_i2cwt
    0050E 3108      CPI	R16,0x18
    0050F F479      BNE	0x051F
(0036) 	{	
(0037) 		#if e2prom>16
(0038) 		i2cwt(ad>>8);			//ad_dst的高位到器件
(0039) 		#endif
(0040) 		i2cwt(ad);				//ad_dst的低位到器件
    00510 2D0C      MOV	R16,R12
    00511 940E 0B2E CALL	_i2cwt
(0041) 			
(0042) 		for(;n>0;n--)			//发送要写入的数据
    00513 C007      RJMP	0x051B
(0043) 		{
(0044) 		    i2cwt(*p);
    00514 01FA      MOVW	R30,R20
    00515 8100      LD	R16,Z
    00516 940E 0B2E CALL	_i2cwt
(0045) 			p++;
    00518 5F4F      SUBI	R20,0xFF
    00519 4F5F      SBCI	R21,0xFF
    0051A 94AA      DEC	R10
    0051B E080      LDI	R24,0
    0051C 158A      CP	R24,R10
    0051D F3B0      BCS	0x0514
(0046) 		}
(0047) 	}
    0051E C003      RJMP	0x0522
(0048) 	else syserr=ERR_SLAW;		//写字节命令及器件地址错
    0051F E081      LDI	R24,1
    00520 9380 0294 STS	syserr,R24
(0049) 	
(0050) 	i2cstop();
    00522 940E 0B46 CALL	_i2cstop
(0051)     delay_nms(6);						//延时6ms
    00524 E006      LDI	R16,6
    00525 E010      LDI	R17,0
    00526 940E 0691 CALL	_delay_nms
(0052) 	
(0053) 	return(p);
    00528 018A      MOVW	R16,R20
    00529 940C 0DA5 JMP	pop_xgsetF03C
_pcf_set_byte:
  startcode            --> Y,+2
  ad                   --> R12
  p                    --> R10
    0052B 92AA      ST	-Y,R10
    0052C 92CA      ST	-Y,R12
    0052D 0169      MOVW	R12,R18
    0052E 2EA0      MOV	R10,R16
    0052F 9723      SBIW	R28,3
(0054) }
(0055) 
(0056) void pcf_set_byte(unsigned char p, unsigned int ad){
(0057)  unsigned char startcode=ad;
    00530 82CA      STD	Y+2,R12
(0058)   wt24c_fc_pcf(&startcode,p,1);
    00531 E081      LDI	R24,1
    00532 E090      LDI	R25,0
    00533 8399      STD	Y+1,R25
    00534 8388      ST	Y,R24
    00535 2D2A      MOV	R18,R10
    00536 2733      CLR	R19
    00537 018E      MOVW	R16,R28
    00538 5F0E      SUBI	R16,0xFE
    00539 4F1F      SBCI	R17,0xFF
    0053A D004      RCALL	_wt24c_fc_pcf
    0053B 9623      ADIW	R28,3
    0053C 90C9      LD	R12,Y+
    0053D 90A9      LD	R10,Y+
    0053E 9508      RET
_wt24c_fc_pcf:
  t                    --> R22
  n                    --> R10
  ad                   --> R12
  p                    --> R20
    0053F 940E 0D9C CALL	push_xgsetF03C
    00541 0169      MOVW	R12,R18
    00542 01A8      MOVW	R20,R16
    00543 84A8      LDD	R10,Y+8
(0059) }
(0060) 
(0061) 
(0062) 
(0063) unsigned char * wt24c_fc_pcf(unsigned char *p, unsigned int ad, unsigned char n)
(0064) {
(0065) 
(0066) 	unsigned char t=0;
(0067) 	#if e2prom<32
(0068) 	t=ad>>8;
    00544 01B6      MOVW	R22,R12
    00545 2F67      MOV	R22,R23
    00546 2777      CLR	R23
(0069) 	t<<=1;
    00547 0F66      LSL	R22
(0070) 	#endif
(0071) 	
(0072) 	i2cstart();					//发送起始信号
    00548 940E 0B26 CALL	_i2cstart
(0073) 		
(0074) 	if(i2cwt(W_ADD_COM_PCF+t)==SLAW)//发送SLA_W, 写字节命令及器件地址
    0054A 2F06      MOV	R16,R22
    0054B 550E      SUBI	R16,0x5E
    0054C 940E 0B2E CALL	_i2cwt
    0054E 3108      CPI	R16,0x18
    0054F F479      BNE	0x055F
(0075) 	{	
(0076) 		#if e2prom>16
(0077) 		i2cwt(ad>>8);			//ad_dst的高位到器件
(0078) 		#endif
(0079) 		i2cwt(ad);				//ad_dst的低位到器件
    00550 2D0C      MOV	R16,R12
    00551 940E 0B2E CALL	_i2cwt
(0080) 			
(0081) 		for(;n>0;n--)			//发送要写入的数据
    00553 C007      RJMP	0x055B
(0082) 		{
(0083) 		    i2cwt(*p);
    00554 01FA      MOVW	R30,R20
    00555 8100      LD	R16,Z
    00556 940E 0B2E CALL	_i2cwt
(0084) 			p++;
    00558 5F4F      SUBI	R20,0xFF
    00559 4F5F      SBCI	R21,0xFF
    0055A 94AA      DEC	R10
    0055B E080      LDI	R24,0
    0055C 158A      CP	R24,R10
    0055D F3B0      BCS	0x0554
(0085) 		}
(0086) 	}
    0055E C003      RJMP	0x0562
(0087) 	else syserr=ERR_SLAW;		//写字节命令及器件地址错
    0055F E081      LDI	R24,1
    00560 9380 0294 STS	syserr,R24
(0088) 	
(0089) 	i2cstop();
    00562 940E 0B46 CALL	_i2cstop
(0090)     delay_nms(6);						//延时6ms
    00564 E006      LDI	R16,6
    00565 E010      LDI	R17,0
    00566 940E 0691 CALL	_delay_nms
(0091) 	
(0092) 	return(p);
    00568 018A      MOVW	R16,R20
    00569 940C 0DA5 JMP	pop_xgsetF03C
_wt24c:
  n                    --> R12
  num                  --> R22
  ad_dst               --> R20
  p_rsc                --> R10
    0056B 940E 0D9C CALL	push_xgsetF03C
    0056D 01A9      MOVW	R20,R18
    0056E 0158      MOVW	R10,R16
    0056F 9721      SBIW	R28,1
    00570 8569      LDD	R22,Y+9
    00571 857A      LDD	R23,Y+10
(0093) }
(0094) 
(0095) 
(0096) /*************************************************************************
(0097) ** 函数名称: 
(0098) ** 功能描述: 向24Cxx写入数据
(0099) ** 输　入: *p_rsc要输出数据的主机内存地址指针; ad_dst要写入数据的i2c的地址(双字节); num数据个数
(0100) ** 输出	 : 
(0101) ** 全局变量: 无
(0102) ** 调用模块: 
(0103) ** 说明：ad_dst: ad_dst+(num-1)不能大于器件的最高地址; num必须>0;
(0104) ** 注意：
(0105) **************************************************************************/
(0106) void wt24c(unsigned char *p_rsc, unsigned int ad_dst, unsigned int num)
(0107) {
(0108)     unsigned int n;
(0109) 
(0110)     n=ad_dst/PAGE_SIZE;		//确定地址与块地址的差
    00572 016A      MOVW	R12,R20
    00573 94D6      LSR	R13
    00574 94C7      ROR	R12
    00575 94D6      LSR	R13
    00576 94C7      ROR	R12
    00577 94D6      LSR	R13
    00578 94C7      ROR	R12
(0111) 	if(n) n=(unsigned long)PAGE_SIZE*(n+1)-ad_dst;
    00579 20CC      TST	R12
    0057A F411      BNE	0x057D
    0057B 20DD      TST	R13
    0057C F0A9      BEQ	0x0592
    0057D E083      LDI	R24,3
    0057E E090      LDI	R25,0
    0057F 0186      MOVW	R16,R12
    00580 5F0F      SUBI	R16,0xFF
    00581 4F1F      SBCI	R17,0xFF
    00582 2722      CLR	R18
    00583 2733      CLR	R19
    00584 938A      ST	-Y,R24
    00585 940E 0DB7 CALL	lsl32
    00587 0118      MOVW	R2,R16
    00588 0129      MOVW	R4,R18
    00589 013A      MOVW	R6,R20
    0058A 2488      CLR	R8
    0058B 2499      CLR	R9
    0058C 1826      SUB	R2,R6
    0058D 0837      SBC	R3,R7
    0058E 0848      SBC	R4,R8
    0058F 0859      SBC	R5,R9
    00590 0161      MOVW	R12,R2
    00591 C005      RJMP	0x0597
(0112) 	else n=PAGE_SIZE-ad_dst;
    00592 E088      LDI	R24,0x8
    00593 E090      LDI	R25,0
    00594 016C      MOVW	R12,R24
    00595 1AC4      SUB	R12,R20
    00596 0AD5      SBC	R13,R21
(0113) 	
(0114)     if(n>=num)		//如果ad_dst所在的数据块的末尾地址 >= ad_dst + num, 就直接写入num个数据
    00597 16C6      CP	R12,R22
    00598 06D7      CPC	R13,R23
    00599 F048      BCS	0x05A3
(0115)     {
(0116) 	 	wt24c_fc(p_rsc, ad_dst, num);
    0059A 8368      ST	Y,R22
    0059B 019A      MOVW	R18,R20
    0059C 0185      MOVW	R16,R10
    0059D DF61      RCALL	_wt24c_fc
(0117)     	if(syserr!=0) return;
    0059E 9020 0294 LDS	R2,syserr
    005A0 2022      TST	R2
    005A1 F151      BEQ	0x05CC
    005A2 C029      RJMP	0x05CC
(0118)     }
(0119)     else			//如果ad_dst所在的数据块末尾地址 < ad_dst + num, 就先写入ad_dst所在的数据块末尾地址与 ad_dst 之差个数据
(0120)     {
(0121) 	    p_rsc=wt24c_fc(p_rsc, ad_dst, n);
    005A3 82C8      ST	Y,R12
    005A4 019A      MOVW	R18,R20
    005A5 0185      MOVW	R16,R10
    005A6 DF58      RCALL	_wt24c_fc
    005A7 0158      MOVW	R10,R16
(0122)     	if(syserr!=0) return;
    005A8 9020 0294 LDS	R2,syserr
    005AA 2022      TST	R2
    005AB F009      BEQ	0x05AD
    005AC C01F      RJMP	0x05CC
(0123) 		
(0124) 		num-=n;     //更新剩下数据个数
    005AD 196C      SUB	R22,R12
    005AE 097D      SBC	R23,R13
(0125)         ad_dst+=n;	//更新剩下数据的起始地址
    005AF 0D4C      ADD	R20,R12
    005B0 1D5D      ADC	R21,R13
    005B1 C00F      RJMP	0x05C1
(0126) 
(0127)         //把剩下数据写入器件
(0128)         while(num>=PAGE_SIZE)	//先按PAGE_SIZE为长度一页一页的写入
(0129)         {
(0130) 		 	p_rsc=wt24c_fc(p_rsc, ad_dst, PAGE_SIZE);
    005B2 E088      LDI	R24,0x8
    005B3 8388      ST	Y,R24
    005B4 019A      MOVW	R18,R20
    005B5 0185      MOVW	R16,R10
    005B6 DF48      RCALL	_wt24c_fc
    005B7 0158      MOVW	R10,R16
(0131)         	if(syserr!=0) return;
    005B8 9020 0294 LDS	R2,syserr
    005BA 2022      TST	R2
    005BB F009      BEQ	0x05BD
    005BC C00F      RJMP	0x05CC
(0132)         	
(0133)             num-=PAGE_SIZE;		//更新剩余数据个数
    005BD 5068      SUBI	R22,0x8
    005BE 4070      SBCI	R23,0
(0134)         	ad_dst+=PAGE_SIZE;	//更新剩下数据的起始地址
    005BF 5F48      SUBI	R20,0xF8
    005C0 4F5F      SBCI	R21,0xFF
    005C1 3068      CPI	R22,0x8
    005C2 E0E0      LDI	R30,0
    005C3 077E      CPC	R23,R30
    005C4 F768      BCC	0x05B2
(0135) 		}
(0136)         
(0137) 		if(num)			//把最后剩下的小于一个PAGE_SIZE长度的数据写入器件
    005C5 3060      CPI	R22,0
    005C6 0767      CPC	R22,R23
    005C7 F021      BEQ	0x05CC
(0138) 			wt24c_fc(p_rsc, ad_dst, num);
    005C8 8368      ST	Y,R22
    005C9 019A      MOVW	R18,R20
    005CA 0185      MOVW	R16,R10
    005CB DF33      RCALL	_wt24c_fc
(0139)     }
    005CC 9621      ADIW	R28,1
    005CD 940C 0DA5 JMP	pop_xgsetF03C
_rd24c:
  t                    --> R10
  num                  --> R22
  ad_rsc               --> R12
  p_dst                --> R20
    005CF 940E 0D9C CALL	push_xgsetF03C
    005D1 0169      MOVW	R12,R18
    005D2 01A8      MOVW	R20,R16
    005D3 8568      LDD	R22,Y+8
    005D4 8579      LDD	R23,Y+9
(0140) }
(0141) /*************************************************************************
(0142) ** 函数名称: 
(0143) ** 功能描述: 从24cxx读出数据
(0144) ** 输　入: *p_dst要读入数据的主机内存地址指针; ad_rsc要输出数据的i2c的地址(整形); num数据个数(整形)
(0145) ** 输出	 : 
(0146) ** 全局变量: 无
(0147) ** 调用模块: 
(0148) ** 说明：ad_dst+(num-1)不能大于器件的最高地址; num必须>0;
(0149) ** 注意：
(0150) **************************************************************************/
(0151) void rd24c(unsigned char *p_dst, unsigned int ad_rsc, unsigned int num)
(0152) {
(0153) 
(0154) 
(0155)  	 
(0156)     unsigned char t=0;
(0157) 
(0158) 	#if e2prom<32
(0159) 	t=ad_rsc>>8;
    005D5 0156      MOVW	R10,R12
    005D6 2CAB      MOV	R10,R11
    005D7 24BB      CLR	R11
(0160) 	t<<=1;
    005D8 0CAA      LSL	R10
(0161) 	#endif
(0162) 	
(0163) 	i2cstart();					//发送起始信号
    005D9 940E 0B26 CALL	_i2cstart
(0164) 		
(0165) 	if(i2cwt(W_ADD_COM+t)==SLAW)//发送SLA_W, 写字节命令及器件地址
    005DB 2D0A      MOV	R16,R10
    005DC 5600      SUBI	R16,0x60
    005DD 940E 0B2E CALL	_i2cwt
    005DF 3108      CPI	R16,0x18
    005E0 F4B1      BNE	0x05F7
(0166) 	{	
(0167) 		#if e2prom>16
(0168) 		i2cwt(ad_rsc>>8);		//ad_rsc的高位,  发送要读出数据的地址
(0169) 		#endif
(0170) 		i2cwt(ad_rsc);			//ad_rsc的低位
    005E1 2D0C      MOV	R16,R12
    005E2 940E 0B2E CALL	_i2cwt
(0171) 				
(0172) 		i2cstart();				//再发送起始信号
    005E4 940E 0B26 CALL	_i2cstart
(0173) 		i2cwt(R_ADD_COM+t);		//发送SLA_R, 读命令字节及器件地址
    005E6 2D0A      MOV	R16,R10
    005E7 550F      SUBI	R16,0x5F
    005E8 940E 0B2E CALL	_i2cwt
(0174) 				
(0175) 		for(;num>0;num--)
    005EA C008      RJMP	0x05F3
(0176) 		{
(0177) 		    *p_dst=i2crd();		//从器件读出一个字节
    005EB 940E 0B3C CALL	_i2crd
    005ED 01FA      MOVW	R30,R20
    005EE 8300      ST	Z,R16
(0178) 			p_dst++;
    005EF 5F4F      SUBI	R20,0xFF
    005F0 4F5F      SBCI	R21,0xFF
    005F1 5061      SUBI	R22,1
    005F2 4070      SBCI	R23,0
    005F3 3060      CPI	R22,0
    005F4 0767      CPC	R22,R23
    005F5 F7A9      BNE	0x05EB
(0179) 		}
(0180) 	}
    005F6 C003      RJMP	0x05FA
(0181) 	else syserr=ERR_SLAW;		//写字节命令及器件地址错或对方无应答
    005F7 E081      LDI	R24,1
    005F8 9380 0294 STS	syserr,R24
(0182) 		
(0183) 	i2cstop();
    005FA 940E 0B46 CALL	_i2cstop
    005FC 940C 0DA5 JMP	pop_xgsetF03C
_rd24c_pcf:
  t                    --> R10
  num                  --> R22
  ad_rsc               --> R12
  p_dst                --> R20
    005FE 940E 0D9C CALL	push_xgsetF03C
    00600 0169      MOVW	R12,R18
    00601 01A8      MOVW	R20,R16
    00602 8568      LDD	R22,Y+8
    00603 8579      LDD	R23,Y+9
(0184) 
(0185) }
(0186) 
(0187) 
(0188) 
(0189) 
(0190) 
(0191) 
(0192) 
(0193) void rd24c_pcf(unsigned char *p_dst, unsigned int ad_rsc, unsigned int num)
(0194) {
(0195) 
(0196)     unsigned char t=0;
(0197) 	#if e2prom<32
(0198) 	t=ad_rsc>>8;
    00604 0156      MOVW	R10,R12
    00605 2CAB      MOV	R10,R11
    00606 24BB      CLR	R11
(0199) 	t<<=1;
    00607 0CAA      LSL	R10
(0200) 	#endif
(0201) 	
(0202) 	i2cstart();					//发送起始信号
    00608 940E 0B26 CALL	_i2cstart
(0203) 		
(0204) 	if(i2cwt(W_ADD_COM_PCF+t)==SLAW)//发送SLA_W, 写字节命令及器件地址
    0060A 2D0A      MOV	R16,R10
    0060B 550E      SUBI	R16,0x5E
    0060C 940E 0B2E CALL	_i2cwt
    0060E 3108      CPI	R16,0x18
    0060F F4B1      BNE	0x0626
(0205) 	{	
(0206) 		#if e2prom>16
(0207) 		i2cwt(ad_rsc>>8);		//ad_rsc的高位,  发送要读出数据的地址
(0208) 		#endif
(0209) 		i2cwt(ad_rsc);			//ad_rsc的低位
    00610 2D0C      MOV	R16,R12
    00611 940E 0B2E CALL	_i2cwt
(0210) 				
(0211) 		i2cstart();				//再发送起始信号
    00613 940E 0B26 CALL	_i2cstart
(0212) 		i2cwt(R_ADD_COM_PCF+t);		//发送SLA_R, 读命令字节及器件地址
    00615 2D0A      MOV	R16,R10
    00616 550D      SUBI	R16,0x5D
    00617 940E 0B2E CALL	_i2cwt
(0213) 				
(0214) 		for(;num>0;num--)
    00619 C008      RJMP	0x0622
(0215) 		{
(0216) 		    *p_dst=i2crd();		//从器件读出一个字节
    0061A 940E 0B3C CALL	_i2crd
    0061C 01FA      MOVW	R30,R20
    0061D 8300      ST	Z,R16
(0217) 			p_dst++;
    0061E 5F4F      SUBI	R20,0xFF
    0061F 4F5F      SBCI	R21,0xFF
    00620 5061      SUBI	R22,1
    00621 4070      SBCI	R23,0
    00622 3060      CPI	R22,0
    00623 0767      CPC	R22,R23
    00624 F7A9      BNE	0x061A
(0218) 		}
(0219) 	}
    00625 C003      RJMP	0x0629
(0220) 	else syserr=ERR_SLAW;		//写字节命令及器件地址错或对方无应答
    00626 E081      LDI	R24,1
    00627 9380 0294 STS	syserr,R24
(0221) 		
(0222) 	i2cstop();
    00629 940E 0B46 CALL	_i2cstop
    0062B 940C 0DA5 JMP	pop_xgsetF03C
_pcf_stop:
  stopcode             --> Y,+1
    0062D 9722      SBIW	R28,2
(0223) 
(0224) }
(0225) 
(0226) 
(0227) 
(0228) void pcf_stop(void)
(0229) {
(0230)  unsigned char stopcode=0x20;
    0062E E280      LDI	R24,0x20
    0062F 8389      STD	Y+1,R24
(0231)  wt24c_fc_pcf(&stopcode,0,1);
    00630 E081      LDI	R24,1
    00631 8388      ST	Y,R24
    00632 2722      CLR	R18
    00633 2733      CLR	R19
    00634 018E      MOVW	R16,R28
    00635 5F0F      SUBI	R16,0xFF
    00636 4F1F      SBCI	R17,0xFF
    00637 DF07      RCALL	_wt24c_fc_pcf
    00638 9622      ADIW	R28,2
    00639 9508      RET
_pcf_start:
  startcode            --> Y,+1
    0063A 9722      SBIW	R28,2
(0232) }
(0233) void pcf_start(void)
(0234) {
(0235)  unsigned char startcode=0x00;
    0063B 2422      CLR	R2
    0063C 8229      STD	Y+1,R2
(0236)   wt24c_fc_pcf(&startcode,0,1);
    0063D E081      LDI	R24,1
    0063E 8388      ST	Y,R24
    0063F 2722      CLR	R18
    00640 2733      CLR	R19
    00641 018E      MOVW	R16,R28
    00642 5F0F      SUBI	R16,0xFF
    00643 4F1F      SBCI	R17,0xFF
    00644 DEFA      RCALL	_wt24c_fc_pcf
    00645 9622      ADIW	R28,2
    00646 9508      RET
_pcfset:
  n                    --> R14
  ad                   --> R12
  p                    --> R10
    00647 940E 0D73 CALL	push_xgset00FC
    00649 0169      MOVW	R12,R18
    0064A 0158      MOVW	R10,R16
    0064B 9721      SBIW	R28,1
    0064C 80EF      LDD	R14,Y+7
(0237) }
(0238) 
(0239) unsigned char * pcfset(unsigned char *p, unsigned int ad, unsigned char n){
(0240) 		 pcf_stop();
    0064D DFDF      RCALL	_pcf_stop
(0241) 		 wt24c_fc_pcf(p,ad,n);
    0064E 82E8      ST	Y,R14
    0064F 0196      MOVW	R18,R12
    00650 0185      MOVW	R16,R10
    00651 DEED      RCALL	_wt24c_fc_pcf
(0242) 		 pcf_start();
    00652 DFE7      RCALL	_pcf_start
(0243) 		 return(p);		 
    00653 0185      MOVW	R16,R10
    00654 9621      ADIW	R28,1
    00655 940C 0D54 JMP	pop_xgset00FC
_pcfread:
  num                  --> R14
  ad_rsc               --> R12
  p_dst                --> R10
    00657 940E 0D73 CALL	push_xgset00FC
    00659 0169      MOVW	R12,R18
    0065A 0158      MOVW	R10,R16
    0065B 9722      SBIW	R28,2
    0065C 84E8      LDD	R14,Y+8
    0065D 84F9      LDD	R15,Y+9
(0244) }
(0245) 
(0246) void pcfread(unsigned char *p_dst, unsigned int ad_rsc, unsigned int num){	 
(0247) 	 rd24c_pcf(p_dst,ad_rsc,num);
    0065E 82F9      STD	Y+1,R15
    0065F 82E8      ST	Y,R14
    00660 0196      MOVW	R18,R12
    00661 0185      MOVW	R16,R10
    00662 DF9B      RCALL	_rd24c_pcf
    00663 9622      ADIW	R28,2
    00664 940C 0D54 JMP	pop_xgset00FC
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\buzz.c
(0001) /************************************************
(0002) 文件：buzz.c
(0003) 用途：
(0004) 注意：内部8M晶振
(0005) 创建：2008.4.1
(0006) 修改：2008.4.1
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) /*************************************************************************
(0011) ** 函数名称:蜂鸣器初始化
(0012) ** 功能描述:
(0013) ** 输　入:
(0014) ** 输出	 :
(0015) ** 全局变量:
(0016) ** 调用模块:
(0017) ** 说明：
(0018) ** 注意：
(0019) **************************************************************************/
(0020) void Buzz_init(void)
(0021) {
(0022)  BUZZ_DDR |= (1<<SPK);
_Buzz_init:
    00666 9180 0064 LDS	R24,0x64
    00668 6180      ORI	R24,0x10
    00669 9380 0064 STS	0x64,R24
(0023)  BUZZ_PORT &=~ (1<<SPK);
    0066B 9180 0065 LDS	R24,0x65
    0066D 7E8F      ANDI	R24,0xEF
    0066E 9380 0065 STS	0x65,R24
    00670 9508      RET
_Beep:
  L_time               --> R10
  H_time               --> R12
    00671 940E 0D75 CALL	push_xgset003C
    00673 0159      MOVW	R10,R18
    00674 0168      MOVW	R12,R16
(0024) }
(0025) /*************************************************************************
(0026) ** 函数名称:蜂鸣
(0027) ** 功能描述:
(0028) ** 输　入: H_time: 响的时间 L_time: 不响的时间
(0029) ** 输出	 :
(0030) ** 全局变量:
(0031) ** 调用模块:
(0032) ** 说明：
(0033) ** 注意：
(0034) **************************************************************************/
(0035) void Beep(unsigned int H_time,unsigned int L_time)
(0036) {
(0037)  BUZZ_PORT |= (1<<SPK);
    00675 9180 0065 LDS	R24,0x65
    00677 6180      ORI	R24,0x10
    00678 9380 0065 STS	0x65,R24
(0038)  delay_nms(H_time);
    0067A 0186      MOVW	R16,R12
    0067B 940E 0691 CALL	_delay_nms
(0039)  BUZZ_PORT &=~ (1<<SPK);
    0067D 9180 0065 LDS	R24,0x65
    0067F 7E8F      ANDI	R24,0xEF
    00680 9380 0065 STS	0x65,R24
(0040)  delay_nms(L_time);
    00682 0185      MOVW	R16,R10
    00683 940E 0691 CALL	_delay_nms
    00685 940C 0D4F JMP	pop_xgset003C
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\delay.c
(0001) /************************************************
(0002) 文件：delay.c
(0003) 用途：延时函数
(0004) 注意：系统时钟8M
(0005) 创建：2008.1.25
(0006) 修改：2008.1.25
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include <iom128v.h>
(0010) 
(0011) #define delay_1us(); asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
(0012) //void delay_1us(void) //延时1us
(0013) //{//ret:4t+call:4t=8t,8MHz时1t为125ns,8t为1000ns=1us
(0014) //}
(0015) 
(0016)   void delay_nus(unsigned int n) //延时n us
(0017) {//(8+(4+4)*(n-1)+3)t=(8+8n-8+3)t=(8n+3)t=n us+0.375us,所以约等于1us,特别n越大越精确
(0018)  while(--n)
_delay_nus:
  n                    --> R16
    00687 01C8      MOVW	R24,R16
    00688 9701      SBIW	R24,1
    00689 018C      MOVW	R16,R24
    0068A 3000      CPI	R16,0
    0068B 0701      CPC	R16,R17
    0068C F7D1      BNE	0x0687
    0068D 9508      RET
(0019)  {
(0020) //  delay_1us();
(0021)  }
(0022) }
(0023) 
(0024)   
(0025)   
(0026) void delay_1ms(void)                 //1ms延时函数
(0027)   {
(0028)   /*
(0029)    unsigned int i;
(0030)    for (i=0;i<1140;i++);
(0031)    */
(0032)    delay_nus(999); //为999us
_delay_1ms:
    0068E EE07      LDI	R16,0xE7
    0068F E013      LDI	R17,3
    00690 CFF6      RJMP	_delay_nus
_delay_nms:
  n                    --> R20
    00691 934A      ST	-Y,R20
    00692 935A      ST	-Y,R21
    00693 01A8      MOVW	R20,R16
(0033)    
(0034)   }
(0035)   
(0036)   
(0037)   
(0038)   void delay_nms(unsigned int n) //延时nms
(0039) {//(8+4*(n-1)+3)t+delay_nus=(7+4n)t+delay_nus
(0040)  for(;n>0;n--)
    00694 C006      RJMP	0x069B
(0041)  {
(0042)   asm("nop"); //再补尝,变成了(7+5n)t+delay_nus
    00695 0000      NOP
(0043)   delay_nus(999); /*delay_nus(m)为(8m+3)t所以delay_nus的参数只要999就可以了
    00696 EE07      LDI	R16,0xE7
    00697 E013      LDI	R17,3
    00698 DFEE      RCALL	_delay_nus
    00699 5041      SUBI	R20,1
    0069A 4050      SBCI	R21,0
    0069B 3040      CPI	R20,0
    0069C 0745      CPC	R20,R21
    0069D F7B9      BNE	0x0695
    0069E 9159      LD	R21,Y+
    0069F 9149      LD	R20,Y+
    006A0 9508      RET
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\hc595.c
(0001) /************************************************
(0002) 文件：hc595.c
(0003) 用途：
(0004) 注意：内部8M晶振
(0005) 创建：2008.4.1
(0006) 修改：2008.4.1
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) const unsigned char Seg7_Data[]={0x3F,0x06,0x5B,0x4F,0x66,             //0,1,2,3,4
(0011)                                  0x6D,0x7D,0x07,0x7F,0x6F,             //5,6,7,8,9
(0012) 						         0x77,0x7C,0x39,0x5E,0x79,0x71,0x00};  //a,b,c,d,e,f
(0013) volatile unsigned char Seg7_Led_Buf[4],point=0,point_pos=0;//point是小数点标志1代表有小数点point_pos表示小数点位置
(0014) /*************************************************************************
(0015) ** 函数名称:HC595初始化
(0016) ** 功能描述:
(0017) ** 输　入:
(0018) ** 输出	 :
(0019) ** 全局变量:
(0020) ** 调用模块:
(0021) ** 说明：
(0022) ** 注意：
(0023) **************************************************************************/
(0024) void HC_595_init(void)
(0025) {
(0026)  OE_DDR |= (1<<OE);
_HC_595_init:
    006A1 9AA7      SBI	0x14,7
(0027)  OE_PORT &= (1<<OE);
    006A2 B385      IN	R24,0x15
    006A3 7880      ANDI	R24,0x80
    006A4 BB85      OUT	0x15,R24
(0028)  PORTB = 0x0F;
    006A5 E08F      LDI	R24,0xF
    006A6 BB88      OUT	0x18,R24
(0029)  spi_init();
    006A7 940E 0B4A CALL	_spi_init
(0030)  Seg7_Led_Buf[0]=16;
    006A9 E180      LDI	R24,0x10
    006AA 9380 0295 STS	Seg7_Led_Buf,R24
(0031)  Seg7_Led_Buf[1]=16;
    006AC 9380 0296 STS	Seg7_Led_Buf+1,R24
(0032)  Seg7_Led_Buf[2]=16;
    006AE 9380 0297 STS	Seg7_Led_Buf+2,R24
(0033)  Seg7_Led_Buf[3]=16;
    006B0 9380 0298 STS	Seg7_Led_Buf+3,R24
    006B2 9508      RET
_HC_595_OUT:
  data                 --> R10
    006B3 92AA      ST	-Y,R10
    006B4 2EA0      MOV	R10,R16
(0034) }
(0035) /*************************************************************************
(0036) ** 函数名称:HC595送数据
(0037) ** 功能描述:
(0038) ** 输　入:
(0039) ** 输出	 :
(0040) ** 全局变量:
(0041) ** 调用模块: 
(0042) ** 说明：
(0043) ** 注意：
(0044) **************************************************************************/
(0045) void HC_595_OUT(unsigned char data)
(0046) {
(0047)  	 SS_L();
    006B5 98C0      CBI	0x18,0
(0048) 	 SPI_MasterTransmit(data);
    006B6 2D0A      MOV	R16,R10
    006B7 940E 0B50 CALL	_SPI_MasterTransmit
(0049)  	 SS_H();
    006B9 9AC0      SBI	0x18,0
    006BA 90A9      LD	R10,Y+
    006BB 9508      RET
(0050) }
(0051) /*************************************************************************
(0052) ** 函数名称:HC595刷新显示
(0053) ** 功能描述:
(0054) ** 输　入:
(0055) ** 输出	 :
(0056) ** 全局变量:
(0057) ** 调用模块: 
(0058) ** 说明：
(0059) ** 注意：
(0060) **************************************************************************/
(0061) void Seg7_Led_Update(void)
(0062) {
(0063)  HC_595_OUT(Seg7_Data[Seg7_Led_Buf[0]]); 
_Seg7_Led_Update:
    006BC E288      LDI	R24,0x28
    006BD E092      LDI	R25,2
    006BE 91E0 0295 LDS	R30,Seg7_Led_Buf
    006C0 27FF      CLR	R31
    006C1 0FE8      ADD	R30,R24
    006C2 1FF9      ADC	R31,R25
    006C3 8100      LD	R16,Z
    006C4 DFEE      RCALL	_HC_595_OUT
(0064)  Seg7_Bit0_En(); 
    006C5 9ABC      SBI	0x17,4
    006C6 9AC4      SBI	0x18,4
(0065)  delay_nus(60); 
    006C7 E30C      LDI	R16,0x3C
    006C8 E010      LDI	R17,0
    006C9 940E 0687 CALL	_delay_nus
(0066)  Seg7_Bit0_Dis();
    006CB 9ABC      SBI	0x17,4
    006CC 98C4      CBI	0x18,4
(0067)  
(0068)  HC_595_OUT(Seg7_Data[Seg7_Led_Buf[1]]);
    006CD E288      LDI	R24,0x28
    006CE E092      LDI	R25,2
    006CF 91E0 0296 LDS	R30,Seg7_Led_Buf+1
    006D1 27FF      CLR	R31
    006D2 0FE8      ADD	R30,R24
    006D3 1FF9      ADC	R31,R25
    006D4 8100      LD	R16,Z
    006D5 DFDD      RCALL	_HC_595_OUT
(0069)  if((point==1)&&(point_pos==1))
    006D6 9180 0239 LDS	R24,point
    006D8 3081      CPI	R24,1
    006D9 F471      BNE	0x06E8
    006DA 9180 023A LDS	R24,point_pos
    006DC 3081      CPI	R24,1
    006DD F451      BNE	0x06E8
(0070)  HC_595_OUT((Seg7_Data[Seg7_Led_Buf[1]])|(1<<dp));
    006DE E288      LDI	R24,0x28
    006DF E092      LDI	R25,2
    006E0 91E0 0296 LDS	R30,Seg7_Led_Buf+1
    006E2 27FF      CLR	R31
    006E3 0FE8      ADD	R30,R24
    006E4 1FF9      ADC	R31,R25
    006E5 8100      LD	R16,Z
    006E6 6800      ORI	R16,0x80
    006E7 DFCB      RCALL	_HC_595_OUT
(0071)  Seg7_Bit1_En();
    006E8 9ABD      SBI	0x17,5
    006E9 9AC5      SBI	0x18,5
(0072)  delay_nus(60);
    006EA E30C      LDI	R16,0x3C
    006EB E010      LDI	R17,0
    006EC 940E 0687 CALL	_delay_nus
(0073)  Seg7_Bit1_Dis();
    006EE 9ABD      SBI	0x17,5
    006EF 98C5      CBI	0x18,5
(0074)  
(0075)  HC_595_OUT(Seg7_Data[Seg7_Led_Buf[2]]); 
    006F0 E288      LDI	R24,0x28
    006F1 E092      LDI	R25,2
    006F2 91E0 0297 LDS	R30,Seg7_Led_Buf+2
    006F4 27FF      CLR	R31
    006F5 0FE8      ADD	R30,R24
    006F6 1FF9      ADC	R31,R25
    006F7 8100      LD	R16,Z
    006F8 DFBA      RCALL	_HC_595_OUT
(0076)  if((point==1)&&(point_pos==2))
    006F9 9180 0239 LDS	R24,point
    006FB 3081      CPI	R24,1
    006FC F471      BNE	0x070B
    006FD 9180 023A LDS	R24,point_pos
    006FF 3082      CPI	R24,2
    00700 F451      BNE	0x070B
(0077)  HC_595_OUT((Seg7_Data[Seg7_Led_Buf[2]])|(1<<dp));
    00701 E288      LDI	R24,0x28
    00702 E092      LDI	R25,2
    00703 91E0 0297 LDS	R30,Seg7_Led_Buf+2
    00705 27FF      CLR	R31
    00706 0FE8      ADD	R30,R24
    00707 1FF9      ADC	R31,R25
    00708 8100      LD	R16,Z
    00709 6800      ORI	R16,0x80
    0070A DFA8      RCALL	_HC_595_OUT
(0078)  Seg7_Bit2_En();
    0070B 9ABE      SBI	0x17,6
    0070C 9AC6      SBI	0x18,6
(0079)  delay_nus(60);
    0070D E30C      LDI	R16,0x3C
    0070E E010      LDI	R17,0
    0070F 940E 0687 CALL	_delay_nus
(0080)  Seg7_Bit2_Dis();
    00711 9ABE      SBI	0x17,6
    00712 98C6      CBI	0x18,6
(0081)  
(0082)  HC_595_OUT(Seg7_Data[Seg7_Led_Buf[3]]);
    00713 E288      LDI	R24,0x28
    00714 E092      LDI	R25,2
    00715 91E0 0298 LDS	R30,Seg7_Led_Buf+3
    00717 27FF      CLR	R31
    00718 0FE8      ADD	R30,R24
    00719 1FF9      ADC	R31,R25
    0071A 8100      LD	R16,Z
    0071B DF97      RCALL	_HC_595_OUT
(0083)  if((point==1)&&(point_pos==3))
    0071C 9180 0239 LDS	R24,point
    0071E 3081      CPI	R24,1
    0071F F471      BNE	0x072E
    00720 9180 023A LDS	R24,point_pos
    00722 3083      CPI	R24,3
    00723 F451      BNE	0x072E
(0084)  HC_595_OUT((Seg7_Data[Seg7_Led_Buf[3]])|(1<<dp));
    00724 E288      LDI	R24,0x28
    00725 E092      LDI	R25,2
    00726 91E0 0298 LDS	R30,Seg7_Led_Buf+3
    00728 27FF      CLR	R31
    00729 0FE8      ADD	R30,R24
    0072A 1FF9      ADC	R31,R25
    0072B 8100      LD	R16,Z
    0072C 6800      ORI	R16,0x80
    0072D DF85      RCALL	_HC_595_OUT
(0085)  Seg7_Bit3_En();
    0072E 9ABF      SBI	0x17,7
    0072F 9AC7      SBI	0x18,7
(0086)  delay_nus(60);
    00730 E30C      LDI	R16,0x3C
    00731 E010      LDI	R17,0
    00732 940E 0687 CALL	_delay_nus
(0087)  Seg7_Bit3_Dis();
    00734 9ABF      SBI	0x17,7
    00735 98C7      CBI	0x18,7
    00736 9508      RET
_Seg7_Led_display:
  data                 --> R10
    00737 92AA      ST	-Y,R10
    00738 92BA      ST	-Y,R11
    00739 0158      MOVW	R10,R16
(0088) }
(0089) /*************************************************************************
(0090) ** 函数名称:Hc595显示整形数据
(0091) ** 功能描述:
(0092) ** 输　入:0~9999
(0093) ** 输出	 :
(0094) ** 全局变量:
(0095) ** 调用模块: 
(0096) ** 说明：
(0097) ** 注意：
(0098) **************************************************************************/
(0099) void Seg7_Led_display(unsigned int data)
(0100) {
(0101) if(data==0){
    0073A 20AA      TST	R10
    0073B F461      BNE	0x0748
    0073C 20BB      TST	R11
    0073D F451      BNE	0x0748
(0102)       Seg7_Led_Buf[3]=0;
    0073E 2422      CLR	R2
    0073F 9220 0298 STS	Seg7_Led_Buf+3,R2
(0103)  	 Seg7_Led_Buf[2]=0;
    00741 9220 0297 STS	Seg7_Led_Buf+2,R2
(0104)  	 Seg7_Led_Buf[1]=0;
    00743 9220 0296 STS	Seg7_Led_Buf+1,R2
(0105)  	 Seg7_Led_Buf[0]=0;
    00745 9220 0295 STS	Seg7_Led_Buf,R2
(0106) 	 Seg7_Led_Update();
    00747 DF74      RCALL	_Seg7_Led_Update
(0107) }
(0108)  if(data>9999) //错误处理,超出显示范围则全亮
    00748 E08F      LDI	R24,0xF
    00749 E297      LDI	R25,0x27
    0074A 158A      CP	R24,R10
    0074B 059B      CPC	R25,R11
    0074C F430      BCC	0x0753
(0109)  	{
(0110) 	 HC_595_OUT(0xFF);
    0074D EF0F      LDI	R16,0xFF
    0074E DF64      RCALL	_HC_595_OUT
(0111) 	 Seg7_Bitselect_PORT|=((1<<Seg7_Bit0)|(1<<Seg7_Bit1)|(1<<Seg7_Bit2)|(1<<Seg7_Bit3));
    0074F B388      IN	R24,0x18
    00750 6F80      ORI	R24,0xF0
    00751 BB88      OUT	0x18,R24
(0112) 	}
    00752 C07F      RJMP	0x07D2
(0113)  else if(data>999)
    00753 EE87      LDI	R24,0xE7
    00754 E093      LDI	R25,3
    00755 158A      CP	R24,R10
    00756 059B      CPC	R25,R11
    00757 F530      BCC	0x077E
(0114)  	{
(0115) 	 Seg7_Led_Buf[3]=data/1000;
    00758 EE28      LDI	R18,0xE8
    00759 E033      LDI	R19,3
    0075A 0185      MOVW	R16,R10
    0075B 940E 0C8F CALL	div16u
    0075D 9300 0298 STS	Seg7_Led_Buf+3,R16
(0116)  	 Seg7_Led_Buf[2]=(data%1000)/100;
    0075F EE28      LDI	R18,0xE8
    00760 E033      LDI	R19,3
    00761 0185      MOVW	R16,R10
    00762 940E 0C8D CALL	mod16u
    00764 E624      LDI	R18,0x64
    00765 E030      LDI	R19,0
    00766 940E 0C8F CALL	div16u
    00768 9300 0297 STS	Seg7_Led_Buf+2,R16
(0117)  	 Seg7_Led_Buf[1]=(data%100)/10;
    0076A E624      LDI	R18,0x64
    0076B E030      LDI	R19,0
    0076C 0185      MOVW	R16,R10
    0076D 940E 0C8D CALL	mod16u
    0076F E02A      LDI	R18,0xA
    00770 E030      LDI	R19,0
    00771 940E 0C8F CALL	div16u
    00773 9300 0296 STS	Seg7_Led_Buf+1,R16
(0118)  	 Seg7_Led_Buf[0]=data%10;
    00775 E02A      LDI	R18,0xA
    00776 E030      LDI	R19,0
    00777 0185      MOVW	R16,R10
    00778 940E 0C8D CALL	mod16u
    0077A 9300 0295 STS	Seg7_Led_Buf,R16
(0119) 	 Seg7_Led_Update();
    0077C DF3F      RCALL	_Seg7_Led_Update
(0120) 	}
    0077D C054      RJMP	0x07D2
(0121)  else if(data>99)
    0077E E683      LDI	R24,0x63
    0077F E090      LDI	R25,0
    00780 158A      CP	R24,R10
    00781 059B      CPC	R25,R11
    00782 F510      BCC	0x07A5
(0122)  	{
(0123) 	 Seg7_Led_Buf[3]=0;
    00783 2422      CLR	R2
    00784 9220 0298 STS	Seg7_Led_Buf+3,R2
(0124)  	 Seg7_Led_Buf[2]=(data%1000)/100;
    00786 EE28      LDI	R18,0xE8
    00787 E033      LDI	R19,3
    00788 0185      MOVW	R16,R10
    00789 940E 0C8D CALL	mod16u
    0078B E624      LDI	R18,0x64
    0078C E030      LDI	R19,0
    0078D 940E 0C8F CALL	div16u
    0078F 9300 0297 STS	Seg7_Led_Buf+2,R16
(0125)  	 Seg7_Led_Buf[1]=(data%100)/10;
    00791 E624      LDI	R18,0x64
    00792 E030      LDI	R19,0
    00793 0185      MOVW	R16,R10
    00794 940E 0C8D CALL	mod16u
    00796 E02A      LDI	R18,0xA
    00797 E030      LDI	R19,0
    00798 940E 0C8F CALL	div16u
    0079A 9300 0296 STS	Seg7_Led_Buf+1,R16
(0126)  	 Seg7_Led_Buf[0]=data%10;
    0079C E02A      LDI	R18,0xA
    0079D E030      LDI	R19,0
    0079E 0185      MOVW	R16,R10
    0079F 940E 0C8D CALL	mod16u
    007A1 9300 0295 STS	Seg7_Led_Buf,R16
(0127) 	 Seg7_Led_Update();
    007A3 DF18      RCALL	_Seg7_Led_Update
(0128) 	}
    007A4 C02D      RJMP	0x07D2
(0129)  else if(data>9)
    007A5 E089      LDI	R24,0x9
    007A6 E090      LDI	R25,0
    007A7 158A      CP	R24,R10
    007A8 059B      CPC	R25,R11
    007A9 F4C8      BCC	0x07C3
(0130)  	{
(0131) 	 Seg7_Led_Buf[3]=0;
    007AA 2422      CLR	R2
    007AB 9220 0298 STS	Seg7_Led_Buf+3,R2
(0132)  	 Seg7_Led_Buf[2]=0;
    007AD 9220 0297 STS	Seg7_Led_Buf+2,R2
(0133)  	 Seg7_Led_Buf[1]=(data%100)/10;
    007AF E624      LDI	R18,0x64
    007B0 E030      LDI	R19,0
    007B1 0185      MOVW	R16,R10
    007B2 940E 0C8D CALL	mod16u
    007B4 E02A      LDI	R18,0xA
    007B5 E030      LDI	R19,0
    007B6 940E 0C8F CALL	div16u
    007B8 9300 0296 STS	Seg7_Led_Buf+1,R16
(0134)  	 Seg7_Led_Buf[0]=data%10;
    007BA E02A      LDI	R18,0xA
    007BB E030      LDI	R19,0
    007BC 0185      MOVW	R16,R10
    007BD 940E 0C8D CALL	mod16u
    007BF 9300 0295 STS	Seg7_Led_Buf,R16
(0135) 	 Seg7_Led_Update();
    007C1 DEFA      RCALL	_Seg7_Led_Update
(0136) 	}
    007C2 C00F      RJMP	0x07D2
(0137)  else
(0138)  	{
(0139) 	 Seg7_Led_Buf[3]=0;
    007C3 2422      CLR	R2
    007C4 9220 0298 STS	Seg7_Led_Buf+3,R2
(0140)  	 Seg7_Led_Buf[2]=0;
    007C6 9220 0297 STS	Seg7_Led_Buf+2,R2
(0141)  	 Seg7_Led_Buf[1]=0;
    007C8 9220 0296 STS	Seg7_Led_Buf+1,R2
(0142)  	 Seg7_Led_Buf[0]=data%10;
    007CA E02A      LDI	R18,0xA
    007CB E030      LDI	R19,0
    007CC 0185      MOVW	R16,R10
    007CD 940E 0C8D CALL	mod16u
    007CF 9300 0295 STS	Seg7_Led_Buf,R16
(0143) 	 Seg7_Led_Update();
    007D1 DEEA      RCALL	_Seg7_Led_Update
(0144) 	}
    007D2 90B9      LD	R11,Y+
    007D3 90A9      LD	R10,Y+
    007D4 9508      RET
_Seg7_Led_float:
  temp                 --> R10
  data                 --> Y,+2
    007D5 940E 0C88 CALL	push_arg4
    007D7 92AA      ST	-Y,R10
    007D8 92BA      ST	-Y,R11
(0145) }
(0146) /*************************************************************************
(0147) ** 函数名称:HC595显示浮点数据
(0148) ** 功能描述:
(0149) ** 输　入:
(0150) ** 输出	 :
(0151) ** 全局变量:
(0152) ** 调用模块: 
(0153) ** 说明：
(0154) ** 注意：
(0155) **************************************************************************/
(0156) void Seg7_Led_float(float data)
(0157) {
(0158)  unsigned int temp;
(0159)  /*
(0160)  重要说明:data+=0.00001;其中0.00001为容错值
(0161)  解决float数据类型在计算机内部存储的误差问题，可以解决显示问题
(0162)  但是会引入新的计算误差，如果精度要求大于0.00001建议更改容错值或者将此处注释掉 
(0163)  */
(0164)  data+=0.00001;
    007D9 802A      LDD	R2,Y+2
    007DA 803B      LDD	R3,Y+3
    007DB 804C      LDD	R4,Y+4
    007DC 805D      LDD	R5,Y+5
    007DD EA04      LDI	R16,0xA4
    007DE E010      LDI	R17,0
    007DF 940E 0D2B CALL	elpm32
    007E1 933A      ST	-Y,R19
    007E2 932A      ST	-Y,R18
    007E3 931A      ST	-Y,R17
    007E4 930A      ST	-Y,R16
    007E5 0181      MOVW	R16,R2
    007E6 0192      MOVW	R18,R4
    007E7 940E 0E33 CALL	fpadd2
    007E9 830A      STD	Y+2,R16
    007EA 831B      STD	Y+3,R17
    007EB 832C      STD	Y+4,R18
    007EC 833D      STD	Y+5,R19
(0165)  point=1;
    007ED E081      LDI	R24,1
    007EE 9380 0239 STS	point,R24
(0166)  if(data>999) //错误处理,超出显示范围则全亮
    007F0 01CE      MOVW	R24,R28
    007F1 9602      ADIW	R24,2
    007F2 011C      MOVW	R2,R24
    007F3 EA00      LDI	R16,0xA0
    007F4 E010      LDI	R17,0
    007F5 940E 0D2B CALL	elpm32
    007F7 923A      ST	-Y,R3
    007F8 922A      ST	-Y,R2
    007F9 940E 0F66 CALL	fpcmp1
    007FB F434      BGE	0x0802
(0167)  	{
(0168) 	 HC_595_OUT(0xFF);
    007FC EF0F      LDI	R16,0xFF
    007FD DEB5      RCALL	_HC_595_OUT
(0169) 	 Seg7_Bitselect_PORT|=((1<<Seg7_Bit0)|(1<<Seg7_Bit1)|(1<<Seg7_Bit2)|(1<<Seg7_Bit3));
    007FE B388      IN	R24,0x18
    007FF 6F80      ORI	R24,0xF0
    00800 BB88      OUT	0x18,R24
(0170) 	}
    00801 C0B6      RJMP	0x08B8
(0171)  else if(data>99)
    00802 01CE      MOVW	R24,R28
    00803 9602      ADIW	R24,2
    00804 011C      MOVW	R2,R24
    00805 E90C      LDI	R16,0x9C
    00806 E010      LDI	R17,0
    00807 940E 0D2B CALL	elpm32
    00809 923A      ST	-Y,R3
    0080A 922A      ST	-Y,R2
    0080B 940E 0F66 CALL	fpcmp1
    0080D F5AC      BGE	0x0843
(0172)  	{
(0173) 	 temp=data*10;
    0080E E908      LDI	R16,0x98
    0080F E010      LDI	R17,0
    00810 940E 0D2B CALL	elpm32
    00812 01CE      MOVW	R24,R28
    00813 9602      ADIW	R24,2
    00814 939A      ST	-Y,R25
    00815 938A      ST	-Y,R24
    00816 940E 0F4F CALL	fpmule1
    00818 940E 0E3E CALL	fpint
    0081A 0158      MOVW	R10,R16
(0174) 	 point_pos=1;
    0081B E081      LDI	R24,1
    0081C 9380 023A STS	point_pos,R24
(0175) 	 Seg7_Led_Buf[3]=temp/1000;
    0081E EE28      LDI	R18,0xE8
    0081F E033      LDI	R19,3
    00820 940E 0C8F CALL	div16u
    00822 9300 0298 STS	Seg7_Led_Buf+3,R16
(0176)  	 Seg7_Led_Buf[2]=(temp%1000)/100;
    00824 EE28      LDI	R18,0xE8
    00825 E033      LDI	R19,3
    00826 0185      MOVW	R16,R10
    00827 940E 0C8D CALL	mod16u
    00829 E624      LDI	R18,0x64
    0082A E030      LDI	R19,0
    0082B 940E 0C8F CALL	div16u
    0082D 9300 0297 STS	Seg7_Led_Buf+2,R16
(0177)  	 Seg7_Led_Buf[1]=(temp%100)/10;
    0082F E624      LDI	R18,0x64
    00830 E030      LDI	R19,0
    00831 0185      MOVW	R16,R10
    00832 940E 0C8D CALL	mod16u
    00834 E02A      LDI	R18,0xA
    00835 E030      LDI	R19,0
    00836 940E 0C8F CALL	div16u
    00838 9300 0296 STS	Seg7_Led_Buf+1,R16
(0178)  	 Seg7_Led_Buf[0]=temp%10;
    0083A E02A      LDI	R18,0xA
    0083B E030      LDI	R19,0
    0083C 0185      MOVW	R16,R10
    0083D 940E 0C8D CALL	mod16u
    0083F 9300 0295 STS	Seg7_Led_Buf,R16
(0179) 	 Seg7_Led_Update();
    00841 DE7A      RCALL	_Seg7_Led_Update
(0180) 	}
    00842 C075      RJMP	0x08B8
(0181)  else if(data>9)
    00843 01CE      MOVW	R24,R28
    00844 9602      ADIW	R24,2
    00845 011C      MOVW	R2,R24
    00846 E904      LDI	R16,0x94
    00847 E010      LDI	R17,0
    00848 940E 0D2B CALL	elpm32
    0084A 923A      ST	-Y,R3
    0084B 922A      ST	-Y,R2
    0084C 940E 0F66 CALL	fpcmp1
    0084E F5AC      BGE	0x0884
(0182)  	{
(0183) 	 temp=data*100;
    0084F E900      LDI	R16,0x90
    00850 E010      LDI	R17,0
    00851 940E 0D2B CALL	elpm32
    00853 01CE      MOVW	R24,R28
    00854 9602      ADIW	R24,2
    00855 939A      ST	-Y,R25
    00856 938A      ST	-Y,R24
    00857 940E 0F4F CALL	fpmule1
    00859 940E 0E3E CALL	fpint
    0085B 0158      MOVW	R10,R16
(0184) 	 point_pos=2;
    0085C E082      LDI	R24,2
    0085D 9380 023A STS	point_pos,R24
(0185) 	 Seg7_Led_Buf[3]=temp/1000;
    0085F EE28      LDI	R18,0xE8
    00860 E033      LDI	R19,3
    00861 940E 0C8F CALL	div16u
    00863 9300 0298 STS	Seg7_Led_Buf+3,R16
(0186)  	 Seg7_Led_Buf[2]=(temp%1000)/100;
    00865 EE28      LDI	R18,0xE8
    00866 E033      LDI	R19,3
    00867 0185      MOVW	R16,R10
    00868 940E 0C8D CALL	mod16u
    0086A E624      LDI	R18,0x64
    0086B E030      LDI	R19,0
    0086C 940E 0C8F CALL	div16u
    0086E 9300 0297 STS	Seg7_Led_Buf+2,R16
(0187)  	 Seg7_Led_Buf[1]=(temp%100)/10;
    00870 E624      LDI	R18,0x64
    00871 E030      LDI	R19,0
    00872 0185      MOVW	R16,R10
    00873 940E 0C8D CALL	mod16u
    00875 E02A      LDI	R18,0xA
    00876 E030      LDI	R19,0
    00877 940E 0C8F CALL	div16u
    00879 9300 0296 STS	Seg7_Led_Buf+1,R16
(0188)  	 Seg7_Led_Buf[0]=temp%10;
    0087B E02A      LDI	R18,0xA
    0087C E030      LDI	R19,0
    0087D 0185      MOVW	R16,R10
    0087E 940E 0C8D CALL	mod16u
    00880 9300 0295 STS	Seg7_Led_Buf,R16
(0189) 	 Seg7_Led_Update();
    00882 DE39      RCALL	_Seg7_Led_Update
(0190) 	}
    00883 C034      RJMP	0x08B8
(0191)  else
(0192)  	{
(0193) 	 temp=data*1000;
    00884 E80C      LDI	R16,0x8C
    00885 E010      LDI	R17,0
    00886 940E 0D2B CALL	elpm32
    00888 01CE      MOVW	R24,R28
    00889 9602      ADIW	R24,2
    0088A 939A      ST	-Y,R25
    0088B 938A      ST	-Y,R24
    0088C 940E 0F4F CALL	fpmule1
    0088E 940E 0E3E CALL	fpint
    00890 0158      MOVW	R10,R16
(0194) 	 point_pos=3;
    00891 E083      LDI	R24,3
    00892 9380 023A STS	point_pos,R24
(0195) 	 Seg7_Led_Buf[3]=temp/1000;
    00894 EE28      LDI	R18,0xE8
    00895 E033      LDI	R19,3
    00896 940E 0C8F CALL	div16u
    00898 9300 0298 STS	Seg7_Led_Buf+3,R16
(0196)  	 Seg7_Led_Buf[2]=(temp%1000)/100;
    0089A EE28      LDI	R18,0xE8
    0089B E033      LDI	R19,3
    0089C 0185      MOVW	R16,R10
    0089D 940E 0C8D CALL	mod16u
    0089F E624      LDI	R18,0x64
    008A0 E030      LDI	R19,0
    008A1 940E 0C8F CALL	div16u
    008A3 9300 0297 STS	Seg7_Led_Buf+2,R16
(0197)  	 Seg7_Led_Buf[1]=(temp%100)/10;
    008A5 E624      LDI	R18,0x64
    008A6 E030      LDI	R19,0
    008A7 0185      MOVW	R16,R10
    008A8 940E 0C8D CALL	mod16u
    008AA E02A      LDI	R18,0xA
    008AB E030      LDI	R19,0
    008AC 940E 0C8F CALL	div16u
    008AE 9300 0296 STS	Seg7_Led_Buf+1,R16
(0198)  	 Seg7_Led_Buf[0]=temp%10;
    008B0 E02A      LDI	R18,0xA
    008B1 E030      LDI	R19,0
    008B2 0185      MOVW	R16,R10
    008B3 940E 0C8D CALL	mod16u
    008B5 9300 0295 STS	Seg7_Led_Buf,R16
(0199) 	 Seg7_Led_Update();
    008B7 DE04      RCALL	_Seg7_Led_Update
(0200) 	}
(0201)  point=0;
    008B8 2422      CLR	R2
    008B9 9220 0239 STS	point,R2
    008BB 90B9      LD	R11,Y+
    008BC 90A9      LD	R10,Y+
    008BD 9624      ADIW	R28,4
    008BE 9508      RET
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\key.c
(0001) /************************************************
(0002) 文件：key.c
(0003) 用途：
(0004) 注意：内部8M晶振
(0005) 创建：2008.4.1
(0006) 修改：2008.4.1
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) /*************************************************************************
(0011) ** 函数名称:键盘初始化
(0012) ** 功能描述:
(0013) ** 输　入:
(0014) ** 输出	 :
(0015) ** 全局变量:
(0016) ** 调用模块:
(0017) ** 说明：
(0018) ** 注意：
(0019) **************************************************************************/
(0020) void Key_init(void)
(0021) {
(0022)  KEY_DDR &=~ (1<<S1)|(1<<S2)|(1<<S3)|(1<<S4);
_Key_init:
    008BF 988C      CBI	0x11,4
(0023)  KEY_PORT |= (1<<S1)|(1<<S2)|(1<<S3)|(1<<S4);
    008C0 B382      IN	R24,0x12
    008C1 6F80      ORI	R24,0xF0
    008C2 BB82      OUT	0x12,R24
    008C3 9508      RET
_get_key:
  tmp                  --> Y,+1
  Key_Value            --> R20
    008C4 934A      ST	-Y,R20
(0024) }
(0025) /*************************************************************************
(0026) ** 函数名称:键盘扫描
(0027) ** 功能描述:
(0028) ** 输　入:
(0029) ** 输出	 :
(0030) ** 全局变量:
(0031) ** 调用模块:
(0032) ** 说明：
(0033) ** 注意：
(0034) **************************************************************************/
(0035) unsigned char get_key(void)
(0036) {
(0037)  unsigned char Key_Value=0xFF,tmp;
    008C5 EF4F      LDI	R20,0xFF
(0038) 
(0039)  Key_Value=KEY_PIN & ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4));
    008C6 B340      IN	R20,0x10
    008C7 7F40      ANDI	R20,0xF0
(0040)  if( Key_Value != ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4)) )
    008C8 3F40      CPI	R20,0xF0
    008C9 F0B1      BEQ	0x08E0
(0041)  	 {
(0042) 	  delay_nms(2);
    008CA E002      LDI	R16,2
    008CB E010      LDI	R17,0
    008CC 940E 0691 CALL	_delay_nms
(0043) 	  if( (KEY_PIN & ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4))) == Key_Value )
    008CE B380      IN	R24,0x10
    008CF 7F80      ANDI	R24,0xF0
    008D0 1784      CP	R24,R20
    008D1 F471      BNE	0x08E0
(0044) 		 {
(0045) 		  Key_Value=KEY_PIN & ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4));
    008D2 B340      IN	R20,0x10
    008D3 7F40      ANDI	R20,0xF0
(0046) 		  //NOP();
(0047) 	  	  while(( KEY_PIN & ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4)) )!= ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4)));
    008D4 B380      IN	R24,0x10
    008D5 7F80      ANDI	R24,0xF0
    008D6 3F80      CPI	R24,0xF0
    008D7 F7E1      BNE	0x08D4
(0048) 		  delay_nms(1);
    008D8 E001      LDI	R16,1
    008D9 E010      LDI	R17,0
    008DA 940E 0691 CALL	_delay_nms
(0049) 		  while(( KEY_PIN & ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4)) )!= ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4)));
    008DC B380      IN	R24,0x10
    008DD 7F80      ANDI	R24,0xF0
    008DE 3F80      CPI	R24,0xF0
    008DF F7E1      BNE	0x08DC
(0050) 		 }
(0051) 	 }
(0052) 	 
(0053)  return Key_Value;
    008E0 2F04      MOV	R16,R20
    008E1 9149      LD	R20,Y+
    008E2 9508      RET
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\sio.c
(0001) /************************************************
(0002) 文件：sio.c
(0003) 用途：结构化串口通信程序
(0004) 注意：
(0005) 创建：2008.1.26
(0006) 修改：2008.1.26
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) 
(0011) #if USEUART0
(0012) siocirqueue RTbuf_UART0;
(0013) #endif
(0014) #if USEUART1
(0015) siocirqueue RTbuf_UART1;
(0016) #endif
(0017) 
(0018) #if (CPU_TYPE == M32)||(CPU_TYPE == M16)||(CPU_TYPE == M8)
(0019) #define USEUART0  TRUE
(0020) #define USEUART1  FALSE
(0021) #define iv_USART0_RXC   iv_USART_RXC
(0022) #define iv_USART0_TXC   iv_USART_TXC
(0023) #define UDR0  	  UDR
(0024) #define UCSR0A    UCSRA
(0025) #define UCSR0B    UCSRB
(0026) #define UCSR0C	  UCSRC
(0027) #define UBRR0H	  UBRRH
(0028) #define UBRR0L	  UBRRL
(0029) #define RXCIE0	  RXCIE
(0030) #define TXCIE0	  TXCIE
(0031) #endif
(0032) 
(0033) 
(0034) /*********************************************************************************************************
(0035) ** 函数名称: Com_init
(0036) ** 功能描述: 初始化串行口
(0037) ** 输　入:
(0038) ** 全局变量: 无
(0039) ** 调用模块: Com_baudrate
(0040) ** 说明：
(0041) ** 注意：
(0042) ********************************************************************************************************/
(0043) void Com_init (void) {
(0044) //WDR(); //喂狗
(0045) //CLI();                     // 关中断
(0046) #if USEUART0
(0047)     Tbuf_init(&RTbuf_UART0);              //初始化接收缓冲
_Com_init:
    008E3 E909      LDI	R16,0x99
    008E4 E012      LDI	R17,2
    008E5 D0E8      RCALL	_Tbuf_init
(0048)     Rbuf_init(&RTbuf_UART0);
    008E6 E909      LDI	R16,0x99
    008E7 E012      LDI	R17,2
    008E8 D0DE      RCALL	_Rbuf_init
(0049)     UCSR0B = 0x00; //disable while setting baud rate
    008E9 2422      CLR	R2
    008EA B82A      OUT	0x0A,R2
(0050)     UCSR0A=0x00;
    008EB B82B      OUT	0x0B,R2
(0051) 
(0052) #if CPU_TYPE <= M32
(0053)     UCSRC = (1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0);
(0054)     UCSR0B = (1<<RXCIE)|(1<<TXCIE)|(1<<RXEN)|(1<<TXEN);  // RXCIE=1;TXCIE=1;UDREIE=0;RXEN=1;TXEN=1
(0055) #else
(0056)     UCSR0C=0x06;  //8 DATA ,1 STOP, NO PARITY
    008EC E086      LDI	R24,6
    008ED 9380 0095 STS	0x95,R24
(0057) //    UCSR0B = (1<<RXCIE0)|(1<<TXCIE0)|(1<<RXEN0)|(1<<TXEN0);  // RXCIE=1;TXCIE=1;UDREIE=0;RXEN=1;TXEN=1
(0058) 	
(0059)     UCSR0B |= (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0);  //允许发送和接收,接收中断使能
    008EF B18A      IN	R24,0x0A
    008F0 6988      ORI	R24,0x98
    008F1 B98A      OUT	0x0A,R24
(0060) 	
(0061) #endif
(0062) 
(0063) #endif
(0064) 
(0065) 
(0066) #if USEUART1
(0067)     Tbuf_init(&RTbuf_B);              //初始化接收缓冲
(0068)     Rbuf_init(&RTbuf_B);
(0069)     UCSR1B = 0x00; //disable while setting baud rate
(0070)     UCSR1A = 0x00;
(0071)     UCSR1C = 0x06;
(0072)     UCSR1B = 0xD8;
(0073) #endif
(0074)     Com_baudrate (9600);		 //
    008F2 E800      LDI	R16,0x80
    008F3 E215      LDI	R17,0x25
    008F4 C006      RJMP	_Com_baudrate
(0075) 
(0076) //SEI();                     // 开中断
(0077) }
(0078) 
(0079) 
(0080) void Com_disable(){
(0081)      UCSR0A=0x00;
_Com_disable:
    008F5 2422      CLR	R2
    008F6 B82B      OUT	0x0B,R2
(0082)      UCSR0B=0x00;
    008F7 B82A      OUT	0x0A,R2
(0083)      UCSR0C=0x00;
    008F8 9220 0095 STS	0x95,R2
    008FA 9508      RET
_Com_baudrate:
  tmp                  --> R10
  baudrate             --> R10
    008FB 940E 0D8E CALL	push_xgsetF00C
    008FD 0158      MOVW	R10,R16
(0084) }
(0085) /*********************************************************************************************************
(0086) ** 函数名称: Com_baudrate
(0087) ** 功能描述: 利用定时器T1产生由参数baudrate指定的波特率
(0088) ** 输　入: baudrate指定的波特率
(0089) ** 全局变量: 无
(0090) ** 调用模块: 无
(0091) ** 说明：
(0092) ** 注意：
(0093) ********************************************************************************************************/
(0094) void Com_baudrate (unsigned int baudrate) {
(0095)     unsigned int tmp;
(0096)     tmp= F_CPU/baudrate/16-1;
    008FE 0115      MOVW	R2,R10
    008FF 2444      CLR	R4
    00900 2455      CLR	R5
    00901 E040      LDI	R20,0
    00902 E152      LDI	R21,0x12
    00903 E76A      LDI	R22,0x7A
    00904 E070      LDI	R23,0
    00905 925A      ST	-Y,R5
    00906 924A      ST	-Y,R4
    00907 923A      ST	-Y,R3
    00908 922A      ST	-Y,R2
    00909 018A      MOVW	R16,R20
    0090A 019B      MOVW	R18,R22
    0090B 940E 0CAF CALL	div32s
    0090D E140      LDI	R20,0x10
    0090E E050      LDI	R21,0
    0090F E060      LDI	R22,0
    00910 E070      LDI	R23,0
    00911 937A      ST	-Y,R23
    00912 936A      ST	-Y,R22
    00913 935A      ST	-Y,R21
    00914 934A      ST	-Y,R20
    00915 940E 0CAF CALL	div32s
    00917 0118      MOVW	R2,R16
    00918 0129      MOVW	R4,R18
    00919 E041      LDI	R20,1
    0091A E050      LDI	R21,0
    0091B E060      LDI	R22,0
    0091C E070      LDI	R23,0
    0091D 1A24      SUB	R2,R20
    0091E 0A35      SBC	R3,R21
    0091F 0A46      SBC	R4,R22
    00920 0A57      SBC	R5,R23
    00921 0151      MOVW	R10,R2
(0097) #if USEUART0
(0098)     UBRR0H=(unsigned char)(tmp>>8);
    00922 2C23      MOV	R2,R3
    00923 2433      CLR	R3
    00924 9220 0090 STS	0x90,R2
(0099)     UBRR0L=(unsigned char)tmp;
    00926 B8A9      OUT	0x09,R10
    00927 940C 0D95 JMP	pop_xgsetF00C
_Com_putchar:
  RTbuf                --> R12
  c                    --> R10
    00929 940E 0D75 CALL	push_xgset003C
    0092B 0169      MOVW	R12,R18
    0092C 2EA0      MOV	R10,R16
(0100) #endif
(0101) #if USEUART1
(0102)     UBRR1H=(unsigned char)(tmp>>8);
(0103)     UBRR1L=(unsigned char)tmp;
(0104) #endif
(0105) }
(0106) /*********************************************************************************************************
(0107) ** 函数名称: Com_putchar
(0108) ** 功能描述: 从串行口输出一个字符c
(0109) ** 输　入: c:输出字符
(0110) ** 输出	 : 0:失败 1:成功
(0111) ** 全局变量: 无
(0112) ** 调用模块:
(0113) ** 说明：
(0114) ** 注意：
(0115) ********************************************************************************************************/
(0116) unsigned char Com_putchar (unsigned char c,siocirqueue *RTbuf) {
(0117) //WDR(); //喂狗
(0118)     if (Tbuf_full(RTbuf))
    0092D 0186      MOVW	R16,R12
    0092E D0C4      RCALL	_Tbuf_full
    0092F 2300      TST	R16
    00930 F011      BEQ	0x0933
(0119)         return(0);
    00931 2700      CLR	R16
    00932 C004      RJMP	0x0937
(0120)     else {
(0121)         Tbuf_putchar(c,RTbuf);				// 将数据加入到发送缓冲区并开中断
    00933 0196      MOVW	R18,R12
    00934 2D0A      MOV	R16,R10
    00935 D0CE      RCALL	_Tbuf_putchar
(0122)         return(1);
    00936 E001      LDI	R16,1
    00937 940C 0D4F JMP	pop_xgset003C
_Com_putstring:
  i                    --> R14
  RTbuf                --> R12
  len                  --> R20
  p                    --> R10
    00939 940E 0D71 CALL	push_xgset30FC
    0093B 2F42      MOV	R20,R18
    0093C 0158      MOVW	R10,R16
    0093D 84C8      LDD	R12,Y+8
    0093E 84D9      LDD	R13,Y+9
(0123)     }
(0124) }
(0125) /*********************************************************************************************************
(0126) ** 函数名称: Com_putstring
(0127) ** 功能描述: 从串行口输出一个字符串
(0128) ** 输　入: p:指向输出字符串 len:输出长度
(0129) ** 输出	 :
(0130) ** 全局变量: 无
(0131) ** 调用模块:
(0132) ** 说明：
(0133) ** 注意：
(0134) ********************************************************************************************************/
(0135) void Com_putstring (unsigned char *p,unsigned char len,siocirqueue *RTbuf) {
(0136)     unsigned char i;
(0137) //WDR(); //喂狗
(0138)     if (len!=0 ) {
    0093F 2344      TST	R20
    00940 F079      BEQ	0x0950
(0139)         for(i=0; i<len; i++)
    00941 24EE      CLR	R14
    00942 C00A      RJMP	0x094D
(0140)             while(Com_putchar(p[i],RTbuf)==0);//WDR(); //喂狗;
    00943 0196      MOVW	R18,R12
    00944 2DEE      MOV	R30,R14
    00945 27FF      CLR	R31
    00946 0DEA      ADD	R30,R10
    00947 1DFB      ADC	R31,R11
    00948 8100      LD	R16,Z
    00949 DFDF      RCALL	_Com_putchar
    0094A 2300      TST	R16
    0094B F3B9      BEQ	0x0943
    0094C 94E3      INC	R14
    0094D 16E4      CP	R14,R20
    0094E F3A0      BCS	0x0943
(0141)     } else {
    0094F C00B      RJMP	0x095B
(0142)         do {
(0143)             while(Com_putchar(*p,RTbuf)==0);//WDR(); //喂狗;
    00950 0196      MOVW	R18,R12
    00951 01F5      MOVW	R30,R10
    00952 8100      LD	R16,Z
    00953 DFD5      RCALL	_Com_putchar
    00954 2300      TST	R16
    00955 F3D1      BEQ	0x0950
(0144)         } while(*p++!='\n');
    00956 01F5      MOVW	R30,R10
    00957 9181      LD	R24,Z+
    00958 015F      MOVW	R10,R30
    00959 308A      CPI	R24,0xA
    0095A F7A9      BNE	0x0950
(0145)     }
    0095B 940C 0D5B JMP	pop_xgset30FC
_Com_getchar:
  ts                   --> R20
  RTbuf                --> R10
  mode                 --> Y,+6
    0095D 940E 0C88 CALL	push_arg4
    0095F 940E 0D7A CALL	push_xgset300C
    00961 0159      MOVW	R10,R18
    00962 9722      SBIW	R28,2
(0146) 
(0147) }
(0148) /*********************************************************************************************************
(0149) ** 函数名称: Com_getchar
(0150) ** 功能描述: 从串行口输入一个字符
(0151) ** 输　入: mode：0不需等待，在调用函数前检测Com_R_count的值
(0152) **              1 等待数据到来
(0153) ** 输出	 : 读入的字符
(0154) ** 全局变量: 无
(0155) ** 调用模块:
(0156) ** 说明：
(0157) ** 注意：
(0158) ********************************************************************************************************/
(0159) 
(0160) unsigned char Com_getchar (unsigned char mode,siocirqueue *RTbuf) {
(0161) //WDR(); //喂狗
(0162) //    Delay(Delay_Comget,MaxLimit_Comget_Delay);
(0163) //	if (mode>0) while(Com_R_count(RTbuf)==0 && !DelayOvf(Delay_Comget))//WDR(); //喂狗;
(0164) //	if (DelayOvf(Delay_Comget))
(0165) //	    return 0;    //时间超时
(0166) //	else
(0167) 	unsigned char *ts="??!\n";
    00963 E440      LDI	R20,0x40
    00964 E052      LDI	R21,2
(0168) 	Com_putstring (ts,4,&RTbuf_UART0);
    00965 E989      LDI	R24,0x99
    00966 E092      LDI	R25,2
    00967 8399      STD	Y+1,R25
    00968 8388      ST	Y,R24
    00969 E024      LDI	R18,4
    0096A 018A      MOVW	R16,R20
    0096B DFCD      RCALL	_Com_putstring
(0169)     while(!Com_R_count(RTbuf));
    0096C 0185      MOVW	R16,R10
    0096D D056      RCALL	_Com_R_count
    0096E 2300      TST	R16
    0096F F3E1      BEQ	0x096C
(0170) 	Com_putstring (ts,4,&RTbuf_UART0);
    00970 E989      LDI	R24,0x99
    00971 E092      LDI	R25,2
    00972 8399      STD	Y+1,R25
    00973 8388      ST	Y,R24
    00974 E024      LDI	R18,4
    00975 018A      MOVW	R16,R20
    00976 DFC2      RCALL	_Com_putstring
(0171) 	
(0172)     return (Rbuf_getchar(RTbuf));// 串行口输入正确，返回输入的字符
    00977 0185      MOVW	R16,R10
    00978 D0C2      RCALL	_Rbuf_getchar
    00979 9622      ADIW	R28,2
    0097A 940E 0D7F CALL	pop_xgset300C
    0097C 9624      ADIW	R28,4
    0097D 9508      RET
_Com_Rbuf_Clear:
  RTbuf                --> R10
    0097E 92AA      ST	-Y,R10
    0097F 92BA      ST	-Y,R11
    00980 0158      MOVW	R10,R16
(0173) }
(0174) 
(0175) 
(0176) 
(0177) void Com_Rbuf_Clear(siocirqueue *RTbuf) {
(0178)     Rbuf_init(RTbuf);
    00981 0185      MOVW	R16,R10
    00982 D044      RCALL	_Rbuf_init
    00983 90B9      LD	R11,Y+
    00984 90A9      LD	R10,Y+
    00985 9508      RET
_Com_getstring:
  ts                   --> R22
  i                    --> R10
  RTbuf                --> R12
  len                  --> R14
  p                    --> R20
    00986 940E 0D6F CALL	push_xgsetF0FC
    00988 2EE2      MOV	R14,R18
    00989 01A8      MOVW	R20,R16
    0098A 9722      SBIW	R28,2
    0098B 84CC      LDD	R12,Y+12
    0098C 84DD      LDD	R13,Y+13
(0179) }
(0180) 
(0181) 
(0182) 
(0183) unsigned char Com_getstring (unsigned char *p,unsigned char len,siocirqueue *RTbuf) {
(0184) 
(0185)     unsigned char i=0;
    0098D 24AA      CLR	R10
(0186) 	unsigned char *ts="???\n";
    0098E E36B      LDI	R22,0x3B
    0098F E072      LDI	R23,2
(0187)     //WDR(); //喂狗
(0188)     if (len>0 ) {
    00990 E080      LDI	R24,0
    00991 158E      CP	R24,R14
    00992 F508      BCC	0x09B4
(0189)         for(i=0; i<len; i++) {
    00993 C01C      RJMP	0x09B0
(0190)             //WDR(); //喂狗
(0191) 			
(0192) 			//debug_start
(0193) 			Com_putstring (ts,4,&RTbuf_UART0);
    00994 E989      LDI	R24,0x99
    00995 E092      LDI	R25,2
    00996 8399      STD	Y+1,R25
    00997 8388      ST	Y,R24
    00998 E024      LDI	R18,4
    00999 018B      MOVW	R16,R22
    0099A DF9E      RCALL	_Com_putstring
(0194) 			Com_putstring (ts,4,&RTbuf_UART0);
    0099B E989      LDI	R24,0x99
    0099C E092      LDI	R25,2
    0099D 8399      STD	Y+1,R25
    0099E 8388      ST	Y,R24
    0099F E024      LDI	R18,4
    009A0 018B      MOVW	R16,R22
    009A1 DF97      RCALL	_Com_putstring
(0195)             *p++=Com_getchar(1,RTbuf);
    009A2 0196      MOVW	R18,R12
    009A3 E001      LDI	R16,1
    009A4 DFB8      RCALL	_Com_getchar
    009A5 01FA      MOVW	R30,R20
    009A6 9301      ST	Z+,R16
    009A7 01AF      MOVW	R20,R30
(0196) 			Com_putstring (ts,4,&RTbuf_UART0);
    009A8 E989      LDI	R24,0x99
    009A9 E092      LDI	R25,2
    009AA 8399      STD	Y+1,R25
    009AB 8388      ST	Y,R24
    009AC E024      LDI	R18,4
    009AD 018B      MOVW	R16,R22
    009AE DF8A      RCALL	_Com_putstring
    009AF 94A3      INC	R10
    009B0 14AE      CP	R10,R14
    009B1 F310      BCS	0x0994
(0197) 			
(0198) 			
(0199) 			//debug_start
(0200)         }
(0201)         return(len);
    009B2 2D0E      MOV	R16,R14
    009B3 C00D      RJMP	0x09C1
(0202)     } else {
(0203) 
(0204)         do {
(0205)             *p++=Com_getchar(1,RTbuf);
    009B4 0196      MOVW	R18,R12
    009B5 E001      LDI	R16,1
    009B6 DFA6      RCALL	_Com_getchar
    009B7 01FA      MOVW	R30,R20
    009B8 9301      ST	Z+,R16
    009B9 01AF      MOVW	R20,R30
(0206)             i++;
    009BA 94A3      INC	R10
(0207)             //WDR(); //喂狗
(0208)         } while(*(p-1)!='\n');
    009BB 01FA      MOVW	R30,R20
    009BC 9731      SBIW	R30,1
    009BD 8180      LD	R24,Z
    009BE 308A      CPI	R24,0xA
    009BF F7A1      BNE	0x09B4
(0209) //			*p++=Com_getchar(1,RTbuf);
(0210) //			*(p)=0;
(0211)         return(i);
    009C0 2D0A      MOV	R16,R10
    009C1 9622      ADIW	R28,2
    009C2 940C 0D64 JMP	pop_xgsetF0FC
(0212)     }
(0213) 
(0214) }
(0215) 
(0216) 
(0217) /*********************************************************************************************************
(0218) ** 函数名称: Com_R_count
(0219) ** 功能描述: 返回接收缓冲区字符个数函数
(0220) ** 输　入:
(0221) ** 输出	 : 字符个数
(0222) ** 全局变量: 无
(0223) ** 调用模块:
(0224) ** 说明：
(0225) ** 注意：
(0226) ********************************************************************************************************/
(0227) unsigned char Com_R_count(siocirqueue *RTbuf) {
(0228)     return RTbuf->R_count;
_Com_R_count:
  RTbuf                --> R16
    009C4 01F8      MOVW	R30,R16
    009C5 8102      LDD	R16,Z+2
    009C6 9508      RET
(0229) }
(0230) /*********************************************************************************************************
(0231) ** 函数名称: Rbuf_init
(0232) ** 功能描述: 接收缓冲区初始化
(0233) ** 输　入:
(0234) ** 输出	 :
(0235) ** 全局变量: 无
(0236) ** 调用模块:
(0237) ** 说明：
(0238) ** 注意：
(0239) ********************************************************************************************************/
(0240) void Rbuf_init(siocirqueue *RTbuf) {
(0241)     RTbuf->R_front=0;
_Rbuf_init:
  RTbuf                --> R16
    009C7 2422      CLR	R2
    009C8 01F8      MOVW	R30,R16
    009C9 8220      ST	Z,R2
(0242)     RTbuf->R_rear=0;
    009CA 8221      STD	Z+1,R2
(0243)     RTbuf->R_count=0;
    009CB 8222      STD	Z+2,R2
(0244)     RTbuf->R_overflow=0;
    009CC 8223      STD	Z+3,R2
    009CD 9508      RET
(0245) }
(0246) /*********************************************************************************************************
(0247) ** 函数名称: Tbuf_init
(0248) ** 功能描述: 发送缓冲区初始化
(0249) ** 输　入:
(0250) ** 输出	 :
(0251) ** 全局变量: 无
(0252) ** 调用模块:
(0253) ** 说明：
(0254) ** 注意：
(0255) ********************************************************************************************************/
(0256) void Tbuf_init(siocirqueue *RTbuf) {
(0257)     RTbuf->T_front=0;
_Tbuf_init:
  RTbuf                --> R16
    009CE 2422      CLR	R2
    009CF 01F8      MOVW	R30,R16
    009D0 59E8      SUBI	R30,0x98
    009D1 4FFF      SBCI	R31,0xFF
    009D2 8220      ST	Z,R2
    009D3 56E8      SUBI	R30,0x68
    009D4 40F0      SBCI	R31,0
(0258)     RTbuf->T_rear=0;
    009D5 59E7      SUBI	R30,0x97
    009D6 4FFF      SBCI	R31,0xFF
    009D7 8220      ST	Z,R2
    009D8 56E9      SUBI	R30,0x69
    009D9 40F0      SBCI	R31,0
(0259)     RTbuf->T_count=0;
    009DA 59E6      SUBI	R30,0x96
    009DB 4FFF      SBCI	R31,0xFF
    009DC 8220      ST	Z,R2
    009DD 56EA      SUBI	R30,0x6A
    009DE 40F0      SBCI	R31,0
(0260)     RTbuf->T_disabled=1;
    009DF E081      LDI	R24,1
    009E0 53E1      SUBI	R30,0x31
    009E1 4FFF      SBCI	R31,0xFF
    009E2 8380      ST	Z,R24
    009E3 9508      RET
_Rbuf_empty:
  RTbuf                --> R16
    009E4 934A      ST	-Y,R20
    009E5 935A      ST	-Y,R21
(0261) }
(0262) /*********************************************************************************************************
(0263) ** 函数名称: Rbuf_empty
(0264) ** 功能描述: 接收缓冲区判空
(0265) ** 输　入:
(0266) ** 输出	 :  TRUE 空 FALSE 非空
(0267) ** 全局变量: 无
(0268) ** 调用模块:
(0269) ** 说明：
(0270) ** 注意：
(0271) ********************************************************************************************************/
(0272) unsigned char Rbuf_empty(siocirqueue *RTbuf) {
(0273)     return RTbuf->R_count==0;
    009E6 01F8      MOVW	R30,R16
    009E7 8022      LDD	R2,Z+2
    009E8 2022      TST	R2
    009E9 F419      BNE	0x09ED
    009EA E041      LDI	R20,1
    009EB E050      LDI	R21,0
    009EC C002      RJMP	0x09EF
    009ED 2744      CLR	R20
    009EE 2755      CLR	R21
    009EF 2F04      MOV	R16,R20
    009F0 9159      LD	R21,Y+
    009F1 9149      LD	R20,Y+
    009F2 9508      RET
_Tbuf_full:
  RTbuf                --> R16
    009F3 934A      ST	-Y,R20
    009F4 935A      ST	-Y,R21
(0274) }
(0275) /*********************************************************************************************************
(0276) ** 函数名称: Tbuf_empty
(0277) ** 功能描述: 发送缓冲区判空
(0278) ** 输　入:
(0279) ** 输出	 :  TRUE 空 FALSE 非空
(0280) ** 全局变量: 无
(0281) ** 调用模块:
(0282) ** 说明：
(0283) ** 注意：
(0284) ********************************************************************************************************
(0285) unsigned char Tbuf_empty(void){
(0286) 	return RTbuf->T_count==0;
(0287) 	}
(0288) /*********************************************************************************************************
(0289) ** 函数名称: Rbuf_full
(0290) ** 功能描述: 接收缓冲区判满
(0291) ** 输　入:
(0292) ** 输出	 :  TRUE 满 FALSE 非满
(0293) ** 全局变量: 无
(0294) ** 调用模块:
(0295) ** 说明：
(0296) ** 注意：
(0297) ********************************************************************************************************
(0298) unsigned char Rbuf_full (void){
(0299) 	return RTbuf->R_count==RBUF_SIZE;
(0300) 	}
(0301) /*********************************************************************************************************
(0302) ** 函数名称: Tbuf_full
(0303) ** 功能描述: 发送缓冲区判满
(0304) ** 输　入:
(0305) ** 输出	 :  TRUE 满 FALSE 非满
(0306) ** 全局变量: 无
(0307) ** 调用模块:
(0308) ** 说明：
(0309) ** 注意：
(0310) ********************************************************************************************************/
(0311) unsigned char Tbuf_full(siocirqueue *RTbuf) {
(0312)     return RTbuf->T_count==TBUF_SIZE;
    009F5 01F8      MOVW	R30,R16
    009F6 59E6      SUBI	R30,0x96
    009F7 4FFF      SBCI	R31,0xFF
    009F8 8180      LD	R24,Z
    009F9 3684      CPI	R24,0x64
    009FA F419      BNE	0x09FE
    009FB E041      LDI	R20,1
    009FC E050      LDI	R21,0
    009FD C002      RJMP	0x0A00
    009FE 2744      CLR	R20
    009FF 2755      CLR	R21
    00A00 2F04      MOV	R16,R20
    00A01 9159      LD	R21,Y+
    00A02 9149      LD	R20,Y+
    00A03 9508      RET
_Tbuf_putchar:
  RTbuf                --> R20
  x                    --> R10
    00A04 940E 0D7A CALL	push_xgset300C
    00A06 01A9      MOVW	R20,R18
    00A07 2EA0      MOV	R10,R16
(0313) }
(0314) /*********************************************************************************************************
(0315) ** 函数名称: Rbuf_putchar
(0316) ** 功能描述: 把一个字符放入接收缓冲区
(0317) ** 输　入:
(0318) ** 输出	 :
(0319) ** 全局变量: 无
(0320) ** 调用模块:
(0321) ** 说明：
(0322) ** 注意：
(0323) ********************************************************************************************************
(0324) void  Rbuf_putchar (unsigned char x){
(0325) 	if(!Rbuf_full()){
(0326) 		REV_DIS();
(0327) 		RTbuf->R_count++;
(0328) 		RTbuf->R_buf[RTbuf->R_rear]=x;
(0329) 		RTbuf->R_rear=(RTbuf->R_rear+1) % RBUF_SIZE;
(0330) 		REV_EN();
(0331) 	}
(0332) }
(0333) /*********************************************************************************************************
(0334) ** 函数名称: Tbuf_putchar
(0335) ** 功能描述: 把一个字符放入发送缓冲区
(0336) ** 输　入:
(0337) ** 输出	 :
(0338) ** 全局变量: 无
(0339) ** 调用模块:
(0340) ** 说明：
(0341) ** 注意：
(0342) ********************************************************************************************************/
(0343) void Tbuf_putchar(unsigned char x,siocirqueue *RTbuf) {
(0344)     if(!Tbuf_full(RTbuf)) {
    00A08 018A      MOVW	R16,R20
    00A09 DFE9      RCALL	_Tbuf_full
    00A0A 2300      TST	R16
    00A0B F009      BEQ	0x0A0D
    00A0C C02C      RJMP	0x0A39
(0345)         TXC_DIS();
    00A0D 9856      CBI	0x0A,6
(0346)         if (RTbuf->T_disabled) {
    00A0E 01FA      MOVW	R30,R20
    00A0F 53E1      SUBI	R30,0x31
    00A10 4FFF      SBCI	R31,0xFF
    00A11 8020      LD	R2,Z
    00A12 5CEF      SUBI	R30,0xCF
    00A13 40F0      SBCI	R31,0
    00A14 2022      TST	R2
    00A15 F031      BEQ	0x0A1C
(0347)             UDR0=x;
    00A16 B8AC      OUT	0x0C,R10
(0348)             RTbuf->T_disabled=0;
    00A17 2422      CLR	R2
    00A18 53E1      SUBI	R30,0x31
    00A19 4FFF      SBCI	R31,0xFF
    00A1A 8220      ST	Z,R2
(0349)         } else {
    00A1B C01C      RJMP	0x0A38
(0350)             RTbuf->T_count++;
    00A1C 01CA      MOVW	R24,R20
    00A1D 5986      SUBI	R24,0x96
    00A1E 4F9F      SBCI	R25,0xFF
    00A1F 01FC      MOVW	R30,R24
    00A20 8180      LD	R24,Z
    00A21 5F8F      SUBI	R24,0xFF
    00A22 8380      ST	Z,R24
(0351)             RTbuf->T_buf[RTbuf->T_rear]=x;
    00A23 01CA      MOVW	R24,R20
    00A24 5985      SUBI	R24,0x95
    00A25 4F9F      SBCI	R25,0xFF
    00A26 01FA      MOVW	R30,R20
    00A27 59E7      SUBI	R30,0x97
    00A28 4FFF      SBCI	R31,0xFF
    00A29 81E0      LD	R30,Z
    00A2A 27FF      CLR	R31
    00A2B 0FE8      ADD	R30,R24
    00A2C 1FF9      ADC	R31,R25
    00A2D 82A0      ST	Z,R10
(0352)             RTbuf->T_rear=(RTbuf->T_rear+1) % TBUF_SIZE;
    00A2E 5947      SUBI	R20,0x97
    00A2F 4F5F      SBCI	R21,0xFF
    00A30 E614      LDI	R17,0x64
    00A31 01FA      MOVW	R30,R20
    00A32 8100      LD	R16,Z
    00A33 5F0F      SUBI	R16,0xFF
    00A34 940E 0D13 CALL	mod8u
    00A36 01FA      MOVW	R30,R20
    00A37 8300      ST	Z,R16
(0353)         }
(0354)         TXC_EN();
    00A38 9A56      SBI	0x0A,6
(0355)     }
    00A39 940C 0D7F JMP	pop_xgset300C
_Rbuf_getchar:
  Btemp                --> R10
  RTbuf                --> R20
    00A3B 940E 0D7A CALL	push_xgset300C
    00A3D 01A8      MOVW	R20,R16
(0356) }
(0357) /*********************************************************************************************************
(0358) ** 函数名称: Rbuf_getstring
(0359) ** 功能描述: 从接收缓冲区返回当前子串指针
(0360) ** 输　入:
(0361) ** 输出	 :  当前子串指针
(0362) ** 全局变量: 无
(0363) ** 调用模块:
(0364) ** 说明：
(0365) ** 注意：
(0366) ********************************************************************************************************
(0367) unsigned char * Rbuf_getstring(void){
(0368) 	return (RTbuf->R_buf[RTbuf->R_front]);
(0369) }
(0370) /*********************************************************************************************************
(0371) ** 函数名称: Tbuf_getstring
(0372) ** 功能描述: 从发送缓冲区返回当前子串指针
(0373) ** 输　入:
(0374) ** 输出	 :  当前子串指针
(0375) ** 全局变量: 无
(0376) ** 调用模块:
(0377) ** 说明：
(0378) ** 注意：
(0379) ********************************************************************************************************
(0380) unsigned char * Tbuf_getstring(void){
(0381) 	return (RTbuf->T_buf[RTbuf->T_front]);
(0382) }
(0383) /*********************************************************************************************************
(0384) ** 函数名称: Rbuf_putchar
(0385) ** 功能描述: 从接收缓冲区读一个字符
(0386) ** 输　入:
(0387) ** 输出	 :  读字符
(0388) ** 全局变量: 无
(0389) ** 调用模块:
(0390) ** 说明：
(0391) ** 注意：
(0392) ********************************************************************************************************/
(0393) unsigned char Rbuf_getchar(siocirqueue *RTbuf) {
(0394)     unsigned char Btemp=0;
    00A3E 24AA      CLR	R10
(0395)     if (!Rbuf_empty(RTbuf)) {
    00A3F 018A      MOVW	R16,R20
    00A40 DFA3      RCALL	_Rbuf_empty
    00A41 2300      TST	R16
    00A42 F4C1      BNE	0x0A5B
(0396)         Btemp=RTbuf->R_buf[RTbuf->R_front];
    00A43 01CA      MOVW	R24,R20
    00A44 9604      ADIW	R24,4
    00A45 01FA      MOVW	R30,R20
    00A46 81E0      LD	R30,Z
    00A47 27FF      CLR	R31
    00A48 0FE8      ADD	R30,R24
    00A49 1FF9      ADC	R31,R25
    00A4A 80A0      LD	R10,Z
(0397)         REV_DIS();
    00A4B 9857      CBI	0x0A,7
(0398)         RTbuf->R_count--;
    00A4C 01CA      MOVW	R24,R20
    00A4D 9602      ADIW	R24,2
    00A4E 01FC      MOVW	R30,R24
    00A4F 8180      LD	R24,Z
    00A50 5081      SUBI	R24,1
    00A51 8380      ST	Z,R24
(0399)         RTbuf->R_front=(RTbuf->R_front+1) % RBUF_SIZE;
    00A52 E614      LDI	R17,0x64
    00A53 01FA      MOVW	R30,R20
    00A54 8100      LD	R16,Z
    00A55 5F0F      SUBI	R16,0xFF
    00A56 940E 0D13 CALL	mod8u
    00A58 01FA      MOVW	R30,R20
    00A59 8300      ST	Z,R16
(0400)         REV_EN();
    00A5A 9A57      SBI	0x0A,7
(0401)     }
(0402)     return (Btemp);
    00A5B 2D0A      MOV	R16,R10
    00A5C 940C 0D7F JMP	pop_xgset300C
_uart0_rx_isr:
  data                 --> R10
  status               --> R22
  RTbuf                --> R20
    00A5E 922A      ST	-Y,R2
    00A5F 923A      ST	-Y,R3
    00A60 930A      ST	-Y,R16
    00A61 931A      ST	-Y,R17
    00A62 938A      ST	-Y,R24
    00A63 939A      ST	-Y,R25
    00A64 93EA      ST	-Y,R30
    00A65 93FA      ST	-Y,R31
    00A66 B62F      IN	R2,0x3F
    00A67 922A      ST	-Y,R2
    00A68 940E 0D8E CALL	push_xgsetF00C
(0403) 
(0404) }
(0405) /*********************************************************************************************************
(0406) ** 函数名称: Tbuf_getchar
(0407) ** 功能描述: 从发送缓冲区读一个字符
(0408) ** 输　入:
(0409) ** 输出	 :  读字符
(0410) ** 全局变量: 无
(0411) ** 调用模块:
(0412) ** 说明：
(0413) ** 注意：
(0414) ********************************************************************************************************
(0415) unsigned char Tbuf_getchar(void){
(0416) 	unsigned char Btemp;
(0417) 	if (!Tbuf_empty()){
(0418) 		Btemp=RTbuf->T_buf[RTbuf->T_front];
(0419) 		TXC_DIS();
(0420) 		RTbuf->T_count--;
(0421) 		RTbuf->T_front=(RTbuf->T_front+1) % TBUF_SIZE;
(0422) 		TXC_EN();
(0423) 		return (Btemp);
(0424) 	}
(0425) }
(0426) */
(0427) 
(0428) /******************************* 中断处理函数 ***************************
(0429) * 功能：完成数据得的接收和发送
(0430) ***********************************************************************/
(0431) #if USEUART0
(0432) #pragma interrupt_handler uart0_rx_isr:iv_USART0_RXC
(0433) void uart0_rx_isr(void) {
(0434)     unsigned char status,data;
(0435)     siocirqueue *RTbuf;
(0436)     RTbuf=&RTbuf_UART0;
    00A6A E949      LDI	R20,0x99
    00A6B E052      LDI	R21,2
(0437) // CLI();
(0438)     status=UCSR0A;
    00A6C B16B      IN	R22,0x0B
(0439)     data=UDR0;
    00A6D B0AC      IN	R10,0x0C
(0440) //WDR(); //喂狗
(0441)     if((status & (FRAMING_ERROR | DATA_OVERRUN))==0) {
    00A6E 2F86      MOV	R24,R22
    00A6F 7188      ANDI	R24,0x18
    00A70 F009      BEQ	0x0A72
    00A71 C022      RJMP	0x0A94
(0442)         if(RTbuf->R_count<RBUF_SIZE) {
    00A72 01FA      MOVW	R30,R20
    00A73 8182      LDD	R24,Z+2
    00A74 3684      CPI	R24,0x64
    00A75 F008      BCS	0x0A77
    00A76 C01A      RJMP	0x0A91
(0443)             RTbuf->R_count++;
    00A77 01CF      MOVW	R24,R30
    00A78 9602      ADIW	R24,2
    00A79 01FC      MOVW	R30,R24
    00A7A 8180      LD	R24,Z
    00A7B 5F8F      SUBI	R24,0xFF
    00A7C 8380      ST	Z,R24
(0444)             RTbuf->R_buf[RTbuf->R_rear]=data;
    00A7D 01CA      MOVW	R24,R20
    00A7E 9604      ADIW	R24,4
    00A7F 01FA      MOVW	R30,R20
    00A80 81E1      LDD	R30,Z+1
    00A81 27FF      CLR	R31
    00A82 0FE8      ADD	R30,R24
    00A83 1FF9      ADC	R31,R25
    00A84 82A0      ST	Z,R10
(0445)             RTbuf->R_rear=(RTbuf->R_rear+1) % RBUF_SIZE;
    00A85 01CA      MOVW	R24,R20
    00A86 9601      ADIW	R24,1
    00A87 011C      MOVW	R2,R24
    00A88 E614      LDI	R17,0x64
    00A89 01FC      MOVW	R30,R24
    00A8A 8100      LD	R16,Z
    00A8B 5F0F      SUBI	R16,0xFF
    00A8C 940E 0D13 CALL	mod8u
    00A8E 01F1      MOVW	R30,R2
    00A8F 8300      ST	Z,R16
(0446)         } else {
    00A90 C003      RJMP	0x0A94
(0447)             RTbuf->R_overflow=1;
    00A91 E081      LDI	R24,1
    00A92 01FA      MOVW	R30,R20
    00A93 8383      STD	Z+3,R24
(0448)         }
(0449)     }
    00A94 940E 0D95 CALL	pop_xgsetF00C
    00A96 9029      LD	R2,Y+
    00A97 BE2F      OUT	0x3F,R2
    00A98 91F9      LD	R31,Y+
    00A99 91E9      LD	R30,Y+
    00A9A 9199      LD	R25,Y+
    00A9B 9189      LD	R24,Y+
    00A9C 9119      LD	R17,Y+
    00A9D 9109      LD	R16,Y+
    00A9E 9039      LD	R3,Y+
    00A9F 9029      LD	R2,Y+
    00AA0 9518      RETI
_getstr:
  data                 --> R10
  status               --> R22
  RTbuf                --> R20
    00AA1 940E 0D8E CALL	push_xgsetF00C
(0450) //SEI();
(0451) }
(0452) 
(0453) 
(0454) 
(0455) 
(0456) 
(0457) void getstr(void) {
(0458)     unsigned char status,data;
(0459)     siocirqueue *RTbuf;
(0460)     RTbuf=&RTbuf_UART0;
    00AA3 E949      LDI	R20,0x99
    00AA4 E052      LDI	R21,2
(0461) // CLI();
(0462)     status=UCSR0A;
    00AA5 B16B      IN	R22,0x0B
(0463)     data=UDR0;
    00AA6 B0AC      IN	R10,0x0C
(0464) //WDR(); //喂狗
(0465)     if((status & (FRAMING_ERROR | DATA_OVERRUN))==0) {
    00AA7 2F86      MOV	R24,R22
    00AA8 7188      ANDI	R24,0x18
    00AA9 F009      BEQ	0x0AAB
    00AAA C022      RJMP	0x0ACD
(0466)         if(RTbuf->R_count<RBUF_SIZE) {
    00AAB 01FA      MOVW	R30,R20
    00AAC 8182      LDD	R24,Z+2
    00AAD 3684      CPI	R24,0x64
    00AAE F008      BCS	0x0AB0
    00AAF C01A      RJMP	0x0ACA
(0467)             RTbuf->R_count++;
    00AB0 01CF      MOVW	R24,R30
    00AB1 9602      ADIW	R24,2
    00AB2 01FC      MOVW	R30,R24
    00AB3 8180      LD	R24,Z
    00AB4 5F8F      SUBI	R24,0xFF
    00AB5 8380      ST	Z,R24
(0468)             RTbuf->R_buf[RTbuf->R_rear]=data;
    00AB6 01CA      MOVW	R24,R20
    00AB7 9604      ADIW	R24,4
    00AB8 01FA      MOVW	R30,R20
    00AB9 81E1      LDD	R30,Z+1
    00ABA 27FF      CLR	R31
    00ABB 0FE8      ADD	R30,R24
    00ABC 1FF9      ADC	R31,R25
    00ABD 82A0      ST	Z,R10
(0469)             RTbuf->R_rear=(RTbuf->R_rear+1) % RBUF_SIZE;
    00ABE 01CA      MOVW	R24,R20
    00ABF 9601      ADIW	R24,1
    00AC0 011C      MOVW	R2,R24
    00AC1 E614      LDI	R17,0x64
    00AC2 01FC      MOVW	R30,R24
    00AC3 8100      LD	R16,Z
    00AC4 5F0F      SUBI	R16,0xFF
    00AC5 940E 0D13 CALL	mod8u
    00AC7 01F1      MOVW	R30,R2
    00AC8 8300      ST	Z,R16
(0470)         } else {
    00AC9 C003      RJMP	0x0ACD
(0471)             RTbuf->R_overflow=1;
    00ACA E081      LDI	R24,1
    00ACB 01FA      MOVW	R30,R20
    00ACC 8383      STD	Z+3,R24
(0472)         }
(0473)     }
    00ACD 940C 0D95 JMP	pop_xgsetF00C
_uart0_tx_isr:
  RTbuf                --> R20
    00ACF 922A      ST	-Y,R2
    00AD0 923A      ST	-Y,R3
    00AD1 930A      ST	-Y,R16
    00AD2 931A      ST	-Y,R17
    00AD3 938A      ST	-Y,R24
    00AD4 939A      ST	-Y,R25
    00AD5 93EA      ST	-Y,R30
    00AD6 93FA      ST	-Y,R31
    00AD7 B62F      IN	R2,0x3F
    00AD8 922A      ST	-Y,R2
    00AD9 934A      ST	-Y,R20
    00ADA 935A      ST	-Y,R21
(0474) //SEI();
(0475) }
(0476) 
(0477) 
(0478) 
(0479) 
(0480) 
(0481) 
(0482) #pragma interrupt_handler uart0_tx_isr: iv_USART0_TXC
(0483) void uart0_tx_isr(void) {
(0484) //CLI();
(0485)     siocirqueue *RTbuf;
(0486) //WDR(); //喂狗
(0487)     RTbuf=&RTbuf_UART0;
    00ADB E949      LDI	R20,0x99
    00ADC E052      LDI	R21,2
(0488)     if (RTbuf->T_count>0) {
    00ADD E080      LDI	R24,0
    00ADE 01FA      MOVW	R30,R20
    00ADF 59E6      SUBI	R30,0x96
    00AE0 4FFF      SBCI	R31,0xFF
    00AE1 8020      LD	R2,Z
    00AE2 56EA      SUBI	R30,0x6A
    00AE3 40F0      SBCI	R31,0
    00AE4 1582      CP	R24,R2
    00AE5 F008      BCS	0x0AE7
    00AE6 C01F      RJMP	0x0B06
(0489)         UDR0=RTbuf->T_buf[RTbuf->T_front];
    00AE7 01CF      MOVW	R24,R30
    00AE8 5985      SUBI	R24,0x95
    00AE9 4F9F      SBCI	R25,0xFF
    00AEA 59E8      SUBI	R30,0x98
    00AEB 4FFF      SBCI	R31,0xFF
    00AEC 81E0      LD	R30,Z
    00AED 27FF      CLR	R31
    00AEE 0FE8      ADD	R30,R24
    00AEF 1FF9      ADC	R31,R25
    00AF0 8020      LD	R2,Z
    00AF1 B82C      OUT	0x0C,R2
(0490)         RTbuf->T_count--;
    00AF2 01CA      MOVW	R24,R20
    00AF3 5986      SUBI	R24,0x96
    00AF4 4F9F      SBCI	R25,0xFF
    00AF5 01FC      MOVW	R30,R24
    00AF6 8180      LD	R24,Z
    00AF7 5081      SUBI	R24,1
    00AF8 8380      ST	Z,R24
(0491)         RTbuf->T_front=(RTbuf->T_front+1) % TBUF_SIZE;
    00AF9 01CA      MOVW	R24,R20
    00AFA 5988      SUBI	R24,0x98
    00AFB 4F9F      SBCI	R25,0xFF
    00AFC 011C      MOVW	R2,R24
    00AFD E614      LDI	R17,0x64
    00AFE 01FC      MOVW	R30,R24
    00AFF 8100      LD	R16,Z
    00B00 5F0F      SUBI	R16,0xFF
    00B01 940E 0D13 CALL	mod8u
    00B03 01F1      MOVW	R30,R2
    00B04 8300      ST	Z,R16
(0492)     } else
    00B05 C005      RJMP	0x0B0B
(0493)         RTbuf->T_disabled=1;
    00B06 E081      LDI	R24,1
    00B07 01FA      MOVW	R30,R20
    00B08 53E1      SUBI	R30,0x31
    00B09 4FFF      SBCI	R31,0xFF
    00B0A 8380      ST	Z,R24
    00B0B 9159      LD	R21,Y+
    00B0C 9149      LD	R20,Y+
    00B0D 9029      LD	R2,Y+
    00B0E BE2F      OUT	0x3F,R2
    00B0F 91F9      LD	R31,Y+
    00B10 91E9      LD	R30,Y+
    00B11 9199      LD	R25,Y+
    00B12 9189      LD	R24,Y+
    00B13 9119      LD	R17,Y+
    00B14 9109      LD	R16,Y+
    00B15 9039      LD	R3,Y+
    00B16 9029      LD	R2,Y+
    00B17 9518      RETI
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\TWI.c
(0001) /************************************************
(0002) 文件：TWI.c
(0003) 用途：TWI操作函数
(0004) 注意：
(0005) 创建：2008.1.26
(0006) 修改：2008.1.26
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) /*************************************************************************
(0011) ** 函数名称: twi_init(void)
(0012) ** 功能描述: i2c通信初始化
(0013) ** 输　入: 
(0014) ** 输出	 : 
(0015) ** 全局变量: 无
(0016) ** 调用模块: 
(0017) ** 说明：
(0018) ** 注意：
(0019) **************************************************************************/
(0020) void twi_init(void)
(0021) {
(0022)  TWCR= 0x00; //disable twi
_twi_init:
    00B18 2422      CLR	R2
    00B19 9220 0074 STS	0x74,R2
(0023)  TWBR= (1<<6) | (1<<5) | (1<<2); //set bit rate
    00B1B E684      LDI	R24,0x64
    00B1C 9380 0070 STS	0x70,R24
(0024)  TWSR= 0x00; //set prescale
    00B1E 9220 0071 STS	0x71,R2
(0025)  TWAR= 0x00; //set slave address
    00B20 9220 0072 STS	0x72,R2
(0026)  TWCR= (1<<TWEN); //enable twi
    00B22 E084      LDI	R24,4
    00B23 9380 0074 STS	0x74,R24
    00B25 9508      RET
(0027) }
(0028) /*************************************************************************
(0029) ** 函数名称: i2cstart(void)
(0030) ** 功能描述: i2c通信开始
(0031) ** 输　入: 
(0032) ** 输出	 : 
(0033) ** 全局变量: 无
(0034) ** 调用模块: 
(0035) ** 说明：
(0036) ** 注意：
(0037) **************************************************************************/
(0038) void i2cstart(void)
(0039) { 
(0040) 	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN); 
_i2cstart:
    00B26 EA84      LDI	R24,0xA4
    00B27 9380 0074 STS	0x74,R24
(0041)    	while (!(TWCR & (1<<TWINT)));
    00B29 9020 0074 LDS	R2,0x74
    00B2B FE27      SBRS	R2,7
    00B2C CFFC      RJMP	0x0B29
    00B2D 9508      RET
(0042) }
(0043) /*************************************************************************
(0044) ** 函数名称: unsigned char i2cwt(unsigned char data)
(0045) ** 功能描述: i2c写数据,返回TWI状态
(0046) ** 输　入: 
(0047) ** 输  出: TWI状态
(0048) ** 全局变量: 无
(0049) ** 调用模块: 
(0050) ** 说明：
(0051) ** 注意：
(0052) **************************************************************************/
(0053) unsigned char i2cwt(unsigned char data)
(0054) { 
(0055) 	TWDR = data;
_i2cwt:
  data                 --> R16
    00B2E 9300 0073 STS	0x73,R16
(0056)    	TWCR = (1<<TWINT) | (1<<TWEN);
    00B30 E884      LDI	R24,0x84
    00B31 9380 0074 STS	0x74,R24
(0057)    	while (!(TWCR & (1<<TWINT)));
    00B33 9020 0074 LDS	R2,0x74
    00B35 FE27      SBRS	R2,7
    00B36 CFFC      RJMP	0x0B33
(0058)    	_NOP();
    00B37 0000      NOP
(0059)    	return(TWSR&0b11111000);
    00B38 9100 0071 LDS	R16,0x71
    00B3A 7F08      ANDI	R16,0xF8
    00B3B 9508      RET
(0060) }
(0061) /*************************************************************************
(0062) ** 函数名称: unsigned char i2crd(void)
(0063) ** 功能描述: i2c读数据
(0064) ** 输　入: 
(0065) ** 输出	 : 读取的数据
(0066) ** 全局变量: 无
(0067) ** 调用模块: 
(0068) ** 说明：
(0069) ** 注意：
(0070) **************************************************************************/
(0071) unsigned char i2crd(void)
(0072) {
(0073)    	TWCR= (1<<TWINT) | (1<<TWEA) | (1<<TWEN);
_i2crd:
    00B3C EC84      LDI	R24,0xC4
    00B3D 9380 0074 STS	0x74,R24
(0074)    	while (!(TWCR & (1<<TWINT)));
    00B3F 9020 0074 LDS	R2,0x74
    00B41 FE27      SBRS	R2,7
    00B42 CFFC      RJMP	0x0B3F
(0075)    	return(TWDR);
    00B43 9100 0073 LDS	R16,0x73
    00B45 9508      RET
(0076) }
(0077) /*************************************************************************
(0078) ** 函数名称: i2cstop(void)
(0079) ** 功能描述: i2c停止
(0080) ** 输　入: 
(0081) ** 输出	 : 
(0082) ** 全局变量: 无
(0083) ** 调用模块: 
(0084) ** 说明：
(0085) ** 注意：
(0086) **************************************************************************/
(0087) void i2cstop(void)
(0088) { 
(0089)    TWCR = (1<<TWINT) | (1<<TWSTO) | (1<<TWEN);
_i2cstop:
    00B46 E984      LDI	R24,0x94
    00B47 9380 0074 STS	0x74,R24
    00B49 9508      RET
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\spi.c
(0001) /************************************************
(0002) 文件：spi.c
(0003) 用途：SPI驱动
(0004) 注意：
(0005) 创建：2008.1.25
(0006) 修改：2008.1.25
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) /*************************************************************************
(0011) ** 函数名称: spi_init(void)
(0012) ** 功能描述: SPI初始化
(0013) ** 输　入: 
(0014) ** 输出	 : 
(0015) ** 全局变量: 无
(0016) ** 调用模块: 
(0017) ** 说明：
(0018) ** 注意：
(0019) **************************************************************************/
(0020) void spi_init(void)
(0021) {
(0022)  	 DDRB |= (1<<MOSI)|(1<<SCK)|(1<<SS);//设置MOSI，SCK输出
_spi_init:
    00B4A B387      IN	R24,0x17
    00B4B 6087      ORI	R24,7
    00B4C BB87      OUT	0x17,R24
(0023)  	 SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<SPR1);//使能SPI，主机模式
    00B4D E583      LDI	R24,0x53
    00B4E B98D      OUT	0x0D,R24
    00B4F 9508      RET
(0024) }
(0025) /*************************************************************************
(0026) ** 函数名称: SPI_MasterTransmit(char Data)
(0027) ** 功能描述: SPI主机发送数据
(0028) ** 输　入: Data 需要通过SPI传输的数据
(0029) ** 输出	 : 
(0030) ** 全局变量: 无
(0031) ** 调用模块: 
(0032) ** 说明：
(0033) ** 注意：
(0034) **************************************************************************/
(0035) void SPI_MasterTransmit(char Data)
(0036) {
(0037)  	 /* 启动数据传输 */
(0038)  	 SPDR = Data;
_SPI_MasterTransmit:
  Data                 --> R16
    00B50 B90F      OUT	0x0F,R16
(0039)  	 /* 等待传输结束 */
(0040)  	 while(!(SPSR & (1<<SPIF)))
    00B51 9B77      SBIS	0x0E,7
    00B52 CFFE      RJMP	0x0B51
    00B53 9508      RET
_init_ds18b20:
  status               --> R20
    00B54 934A      ST	-Y,R20
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\DS18B20.c
(0001) #include "..\config.h"
(0002) //#include <iom128v.h>
(0003) char current_temp_display_buffer[]={"Temp:         "};
(0004) unsigned char currentT=0;
(0005) const unsigned char df_table[]={0,1,1,2,2,3,4,4,5,6,6,7,7,8,9,9};
(0006) unsigned char ds18b20_error=0;
(0007) unsigned char temp_value[]={0x00,0x00};
(0008) unsigned char display_digit[]={0,0,0,0};
(0009) 
(0010) 
(0011) 
(0012) //初始化DS18B20
(0013) unsigned char init_ds18b20(void)
(0014) {
(0015)  unsigned char status;
(0016)  DQ_DDR_1();
    00B55 9180 0061 LDS	R24,0x61
    00B57 6084      ORI	R24,4
    00B58 9380 0061 STS	0x61,R24
(0017)  DQ_1();
    00B5A 9180 0062 LDS	R24,0x62
    00B5C 6084      ORI	R24,4
    00B5D 9380 0062 STS	0x62,R24
(0018)  DQ_0();
    00B5F 9180 0062 LDS	R24,0x62
    00B61 7F8B      ANDI	R24,0xFB
    00B62 9380 0062 STS	0x62,R24
(0019)  delay_nus(540); //主机拉低总线，占总线
    00B64 E10C      LDI	R16,0x1C
    00B65 E012      LDI	R17,2
    00B66 940E 0687 CALL	_delay_nus
(0020)  
(0021)  DQ_DDR_0();
    00B68 9180 0061 LDS	R24,0x61
    00B6A 7F8B      ANDI	R24,0xFB
    00B6B 9380 0061 STS	0x61,R24
(0022)  DQ_1();
    00B6D 9180 0062 LDS	R24,0x62
    00B6F 6084      ORI	R24,4
    00B70 9380 0062 STS	0x62,R24
(0023)  delay_nus(40); //PA4设为输入
    00B72 E208      LDI	R16,0x28
    00B73 E010      LDI	R17,0
    00B74 940E 0687 CALL	_delay_nus
(0024)  
(0025)  status=RD_DQ_VAL(); //读总线，为0时器件在线
    00B76 B140      IN	R20,0x00
    00B77 7044      ANDI	R20,4
(0026)  delay_nus(500);
    00B78 EF04      LDI	R16,0xF4
    00B79 E011      LDI	R17,1
    00B7A 940E 0687 CALL	_delay_nus
(0027)  DQ_1();        //释放总线
    00B7C 9180 0062 LDS	R24,0x62
    00B7E 6084      ORI	R24,4
    00B7F 9380 0062 STS	0x62,R24
(0028)  return status;
    00B81 2F04      MOV	R16,R20
    00B82 9149      LD	R20,Y+
    00B83 9508      RET
_readonebyte:
  dat                  --> R10
  i                    --> R20
    00B84 92AA      ST	-Y,R10
    00B85 934A      ST	-Y,R20
(0029)  
(0030) }
(0031) 
(0032) unsigned char readonebyte(void) //读一字节
(0033) {
(0034)   unsigned char i=0,dat=0;
    00B86 24AA      CLR	R10
(0035)    for(i=0;i<8;i++)
    00B87 2744      CLR	R20
    00B88 C023      RJMP	0x0BAC
(0036)    {  
(0037)      
(0038)       DQ_DDR_1();
    00B89 9180 0061 LDS	R24,0x61
    00B8B 6084      ORI	R24,4
    00B8C 9380 0061 STS	0x61,R24
(0039)       DQ_0();      //拉低总线
    00B8E 9180 0062 LDS	R24,0x62
    00B90 7F8B      ANDI	R24,0xFB
    00B91 9380 0062 STS	0x62,R24
(0040) 	  delay_nus(2);
    00B93 E002      LDI	R16,2
    00B94 E010      LDI	R17,0
    00B95 940E 0687 CALL	_delay_nus
(0041)       DQ_DDR_0();  //读PA4引脚
    00B97 9180 0061 LDS	R24,0x61
    00B99 7F8B      ANDI	R24,0xFB
    00B9A 9380 0061 STS	0x61,R24
(0042) 	  delay_nus(10);
    00B9C E00A      LDI	R16,0xA
    00B9D E010      LDI	R17,0
    00B9E 940E 0687 CALL	_delay_nus
(0043) 	  if(RD_DQ_VAL())
    00BA0 9B02      SBIS	0x00,2
    00BA1 C005      RJMP	0x0BA7
(0044) 	  dat|=(1<<i); //数据存放在dat中
    00BA2 E001      LDI	R16,1
    00BA3 2F14      MOV	R17,R20
    00BA4 940E 0DC3 CALL	lsl8
    00BA6 2AA0      OR	R10,R16
(0045) 	  delay_nus(80);
    00BA7 E500      LDI	R16,0x50
    00BA8 E010      LDI	R17,0
    00BA9 940E 0687 CALL	_delay_nus
    00BAB 9543      INC	R20
    00BAC 3048      CPI	R20,0x8
    00BAD F2D8      BCS	0x0B89
(0046)    }
(0047)    return dat;
    00BAE 2D0A      MOV	R16,R10
    00BAF 9149      LD	R20,Y+
    00BB0 90A9      LD	R10,Y+
    00BB1 9508      RET
_writeonebyte:
  i                    --> R20
  dat                  --> R10
    00BB2 92AA      ST	-Y,R10
    00BB3 934A      ST	-Y,R20
    00BB4 2EA0      MOV	R10,R16
(0048) }
(0049) 
(0050) 
(0051) 
(0052) void writeonebyte(unsigned char dat) //写一字节
(0053) {
(0054)    unsigned char i=0x01;
(0055)    for(i=0x01;i!=0x00;i<<=1)
    00BB5 E041      LDI	R20,1
    00BB6 C026      RJMP	0x0BDD
(0056)    {
(0057)       DQ_DDR_1();
    00BB7 9180 0061 LDS	R24,0x61
    00BB9 6084      ORI	R24,4
    00BBA 9380 0061 STS	0x61,R24
(0058)       DQ_0();      //拉低,占总线
    00BBC 9180 0062 LDS	R24,0x62
    00BBE 7F8B      ANDI	R24,0xFB
    00BBF 9380 0062 STS	0x62,R24
(0059) 	  delay_nus(10);//
    00BC1 E00A      LDI	R16,0xA
    00BC2 E010      LDI	R17,0
    00BC3 940E 0687 CALL	_delay_nus
(0060) 	  if(dat&i)
    00BC5 2C2A      MOV	R2,R10
    00BC6 2224      AND	R2,R20
    00BC7 F031      BEQ	0x0BCE
(0061) 	    DQ_1(); 
    00BC8 9180 0062 LDS	R24,0x62
    00BCA 6084      ORI	R24,4
    00BCB 9380 0062 STS	0x62,R24
    00BCD C005      RJMP	0x0BD3
(0062) 	  else
(0063) 	    DQ_0(); 
    00BCE 9180 0062 LDS	R24,0x62
    00BD0 7F8B      ANDI	R24,0xFB
    00BD1 9380 0062 STS	0x62,R24
(0064) 	  delay_nus(80);
    00BD3 E500      LDI	R16,0x50
    00BD4 E010      LDI	R17,0
    00BD5 940E 0687 CALL	_delay_nus
(0065) 	  DQ_1(); 
    00BD7 9180 0062 LDS	R24,0x62
    00BD9 6084      ORI	R24,4
    00BDA 9380 0062 STS	0x62,R24
    00BDC 0F44      LSL	R20
    00BDD 2344      TST	R20
    00BDE F6C1      BNE	0x0BB7
    00BDF 9149      LD	R20,Y+
    00BE0 90A9      LD	R10,Y+
    00BE1 9508      RET
_read_temperature:
  temp                 --> R10
    00BE2 92AA      ST	-Y,R10
(0066)    }
(0067) }
(0068) 
(0069) 
(0070) unsigned char read_temperature(void)
(0071) {
(0072) 
(0073)   unsigned char temp;
(0074) //  CLI();
(0075)   if(init_ds18b20()!=0x00){
    00BE3 DF70      RCALL	_init_ds18b20
    00BE4 2300      TST	R16
    00BE5 F021      BEQ	0x0BEA
(0076)      ds18b20_error=1;            //DS18B20发生故障
    00BE6 E081      LDI	R24,1
    00BE7 9380 0265 STS	ds18b20_error,R24
(0077) //     msc_to_pc("DS18B20_ERROR\n");
(0078)   }
    00BE9 C013      RJMP	0x0BFD
(0079)  else
(0080)  {
(0081)   // msc_to_pc("DS18B20_INIT_SUCCESS\n");
(0082)    writeonebyte(0xCC);           //跳过序列号匹配
    00BEA EC0C      LDI	R16,0xCC
    00BEB DFC6      RCALL	_writeonebyte
(0083)    writeonebyte(0x44);           //启动测温
    00BEC E404      LDI	R16,0x44
    00BED DFC4      RCALL	_writeonebyte
(0084)    init_ds18b20();
    00BEE DF65      RCALL	_init_ds18b20
(0085)    writeonebyte(0xCC);
    00BEF EC0C      LDI	R16,0xCC
    00BF0 DFC1      RCALL	_writeonebyte
(0086)    writeonebyte(0xBE);           //读取温度寄存器
    00BF1 EB0E      LDI	R16,0xBE
    00BF2 DFBF      RCALL	_writeonebyte
(0087)    temp_value[0]=readonebyte();  //温度低8位
    00BF3 DF90      RCALL	_readonebyte
    00BF4 9300 0266 STS	temp_value,R16
(0088)    temp_value[1]=readonebyte();  //温度高8位
    00BF6 DF8D      RCALL	_readonebyte
    00BF7 2EA0      MOV	R10,R16
    00BF8 92A0 0267 STS	temp_value+1,R10
(0089)    ds18b20_error=0;
    00BFA 2422      CLR	R2
    00BFB 9220 0265 STS	ds18b20_error,R2
(0090)    
(0091)  }
(0092)  temp=temp_value[1];
    00BFD 90A0 0267 LDS	R10,temp_value+1
(0093)  //SEI();
(0094)  return temp;
    00BFF 2D0A      MOV	R16,R10
    00C00 90A9      LD	R10,Y+
    00C01 9508      RET
_convert_temp_data:
  ng                   --> R20
    00C02 934A      ST	-Y,R20
(0095)  
(0096) }
(0097) 
(0098) //温度转换
(0099) void convert_temp_data(void)
(0100) {
(0101)    unsigned char ng=0;
    00C03 2744      CLR	R20
(0102)           
(0103)   if((temp_value[1]&0xF8)==0xF8) //判断温度的正负
    00C04 9180 0267 LDS	R24,temp_value+1
    00C06 7F88      ANDI	R24,0xF8
    00C07 3F88      CPI	R24,0xF8
    00C08 F491      BNE	0x0C1B
(0104)   {
(0105)     temp_value[1]=~temp_value[1];
    00C09 9020 0267 LDS	R2,temp_value+1
    00C0B 9420      COM	R2
    00C0C 9220 0267 STS	temp_value+1,R2
(0106) 	temp_value[0]=~temp_value[0]+1;
    00C0E 9180 0266 LDS	R24,temp_value
    00C10 9580      COM	R24
    00C11 5F8F      SUBI	R24,0xFF
    00C12 9380 0266 STS	temp_value,R24
(0107) 	if(temp_value[0]==0x00) temp_value[1]++;
    00C14 2388      TST	R24
    00C15 F421      BNE	0x0C1A
    00C16 2D82      MOV	R24,R2
    00C17 5F8F      SUBI	R24,0xFF
    00C18 9380 0267 STS	temp_value+1,R24
(0108) 	ng=1;                        //负数标志
    00C1A E041      LDI	R20,1
(0109)   }
(0110)   
(0111)   display_digit[0]=df_table[temp_value[0]&0x0F];    //温度小数部分
    00C1B E585      LDI	R24,0x55
    00C1C E092      LDI	R25,2
    00C1D 91E0 0266 LDS	R30,temp_value
    00C1F 27FF      CLR	R31
    00C20 70EF      ANDI	R30,0xF
    00C21 70F0      ANDI	R31,0
    00C22 0FE8      ADD	R30,R24
    00C23 1FF9      ADC	R31,R25
    00C24 8020      LD	R2,Z
    00C25 9220 0268 STS	display_digit,R2
(0112)   currentT=(temp_value[0]>>4)|(temp_value[1]<<4); //温度数值
    00C27 9180 0267 LDS	R24,temp_value+1
    00C29 708F      ANDI	R24,0xF
    00C2A 9582      SWAP	R24
    00C2B 9190 0266 LDS	R25,temp_value
    00C2D 9592      SWAP	R25
    00C2E 709F      ANDI	R25,0xF
    00C2F 2B98      OR	R25,R24
    00C30 9390 0254 STS	currentT,R25
(0113)   
(0114)   display_digit[3]=currentT/100;                    //温度百位
    00C32 E614      LDI	R17,0x64
    00C33 2F09      MOV	R16,R25
    00C34 940E 0D15 CALL	div8u
    00C36 9300 026B STS	display_digit+3,R16
(0115)   display_digit[2]=currentT%100/10;                 //温度十位
    00C38 E614      LDI	R17,0x64
    00C39 9100 0254 LDS	R16,currentT
    00C3B 940E 0D13 CALL	mod8u
    00C3D E01A      LDI	R17,0xA
    00C3E 940E 0D15 CALL	div8u
    00C40 9300 026A STS	display_digit+2,R16
(0116)   display_digit[1]=currentT%10;                     //温度个位
    00C42 E01A      LDI	R17,0xA
    00C43 9100 0254 LDS	R16,currentT
    00C45 940E 0D13 CALL	mod8u
    00C47 9300 0269 STS	display_digit+1,R16
(0117)   
(0118)   //温度显示预操作
(0119)   current_temp_display_buffer[11]=display_digit[0]+'0';
    00C49 9180 0268 LDS	R24,display_digit
    00C4B 5D80      SUBI	R24,0xD0
    00C4C 9380 0250 STS	current_temp_display_buffer+11,R24
(0120)   current_temp_display_buffer[10]='.';
    00C4E E28E      LDI	R24,0x2E
    00C4F 9380 024F STS	current_temp_display_buffer+10,R24
(0121)   current_temp_display_buffer[9]=display_digit[1]+'0';
    00C51 2F80      MOV	R24,R16
    00C52 5D80      SUBI	R24,0xD0
    00C53 9380 024E STS	current_temp_display_buffer+9,R24
(0122)   current_temp_display_buffer[8]=display_digit[2]+'0';
    00C55 9180 026A LDS	R24,display_digit+2
    00C57 5D80      SUBI	R24,0xD0
    00C58 9380 024D STS	current_temp_display_buffer+8,R24
(0123)   if(display_digit[3]!=0)
    00C5A 9020 026B LDS	R2,display_digit+3
    00C5C 2022      TST	R2
    00C5D F029      BEQ	0x0C63
(0124)   current_temp_display_buffer[7]=display_digit[3]+'0';
    00C5E 2D82      MOV	R24,R2
    00C5F 5D80      SUBI	R24,0xD0
    00C60 9380 024C STS	current_temp_display_buffer+7,R24
    00C62 C003      RJMP	0x0C66
(0125)   else
(0126)   current_temp_display_buffer[7]=' ';
    00C63 E280      LDI	R24,0x20
    00C64 9380 024C STS	current_temp_display_buffer+7,R24
(0127)   if(display_digit[2]==0 && display_digit[1]==0)
    00C66 9020 026A LDS	R2,display_digit+2
    00C68 2022      TST	R2
    00C69 F439      BNE	0x0C71
    00C6A 9020 0269 LDS	R2,display_digit+1
    00C6C 2022      TST	R2
    00C6D F419      BNE	0x0C71
(0128)   current_temp_display_buffer[8]=' ';
    00C6E E280      LDI	R24,0x20
    00C6F 9380 024D STS	current_temp_display_buffer+8,R24
(0129)   if(ng)                                       //温度为负
    00C71 2344      TST	R20
    00C72 F099      BEQ	0x0C86
(0130)   {
(0131)     if(current_temp_display_buffer[8]==' ')
    00C73 9180 024D LDS	R24,current_temp_display_buffer+8
    00C75 3280      CPI	R24,0x20
    00C76 F421      BNE	0x0C7B
(0132) 	   current_temp_display_buffer[8]='-';
    00C77 E28D      LDI	R24,0x2D
    00C78 9380 024D STS	current_temp_display_buffer+8,R24
    00C7A C00B      RJMP	0x0C86
(0133) 	else  
(0134)     if(current_temp_display_buffer[7]==' ')
    00C7B 9180 024C LDS	R24,current_temp_display_buffer+7
    00C7D 3280      CPI	R24,0x20
    00C7E F421      BNE	0x0C83
(0135) 	   current_temp_display_buffer[7]='-';
    00C7F E28D      LDI	R24,0x2D
    00C80 9380 024C STS	current_temp_display_buffer+7,R24
    00C82 C003      RJMP	0x0C86
(0136) 	else  
(0137) 	   current_temp_display_buffer[6]='-';
    00C83 E28D      LDI	R24,0x2D
    00C84 9380 024B STS	current_temp_display_buffer+6,R24
(0138)   }
FILE: <library>
    00C86 9149      LD	R20,Y+
    00C87 9508      RET
push_arg4:
    00C88 933A      ST	-Y,R19
    00C89 932A      ST	-Y,R18
push_arg2:
    00C8A 931A      ST	-Y,R17
    00C8B 930A      ST	-Y,R16
    00C8C 9508      RET
mod16u:
    00C8D 9468      BSET	6
    00C8E C001      RJMP	xdiv16u
div16u:
    00C8F 94E8      BCLR	6
xdiv16u:
    00C90 92EA      ST	-Y,R14
    00C91 92FA      ST	-Y,R15
    00C92 938A      ST	-Y,R24
    00C93 24EE      CLR	R14
    00C94 24FF      CLR	R15
    00C95 E180      LDI	R24,0x10
    00C96 0F00      LSL	R16
    00C97 1F11      ROL	R17
    00C98 1CEE      ROL	R14
    00C99 1CFF      ROL	R15
    00C9A 16E2      CP	R14,R18
    00C9B 06F3      CPC	R15,R19
    00C9C F018      BCS	0x0CA0
    00C9D 1AE2      SUB	R14,R18
    00C9E 0AF3      SBC	R15,R19
    00C9F 9503      INC	R16
    00CA0 958A      DEC	R24
    00CA1 F7A1      BNE	0x0C96
    00CA2 F416      BRTC	0x0CA5
    00CA3 2D0E      MOV	R16,R14
    00CA4 2D1F      MOV	R17,R15
    00CA5 9189      LD	R24,Y+
    00CA6 90F9      LD	R15,Y+
    00CA7 90E9      LD	R14,Y+
    00CA8 9508      RET
div32u:
    00CA9 94E8      BCLR	6
    00CAA C001      RJMP	0x0CAC
mod32u:
    00CAB 9468      BSET	6
    00CAC D030      RCALL	long_div_prolog
    00CAD 24CC      CLR	R12
    00CAE C009      RJMP	0x0CB8
div32s:
    00CAF 94E8      BCLR	6
    00CB0 C001      RJMP	0x0CB2
mod32s:
    00CB1 9468      BSET	6
    00CB2 D02A      RCALL	long_div_prolog
    00CB3 FD37      SBRC	R19,7
    00CB4 940E 0DAE CALL	neg32
    00CB6 FDB7      SBRC	R27,7
    00CB7 D052      RCALL	neg_R24_R27
    00CB8 2477      CLR	R7
    00CB9 2488      CLR	R8
    00CBA 2499      CLR	R9
    00CBB 24AA      CLR	R10
    00CBC 24BB      CLR	R11
    00CBD D042      RCALL	tst_R16_R19
    00CBE F0C1      BEQ	0x0CD7
    00CBF D045      RCALL	tst_R24_R27
    00CC0 F0B1      BEQ	0x0CD7
    00CC1 E2E8      LDI	R30,0x28
    00CC2 0F00      LSL	R16
    00CC3 1F11      ROL	R17
    00CC4 1F22      ROL	R18
    00CC5 1F33      ROL	R19
    00CC6 1C77      ROL	R7
    00CC7 1C88      ROL	R8
    00CC8 1C99      ROL	R9
    00CC9 1CAA      ROL	R10
    00CCA 1CBB      ROL	R11
    00CCB 1688      CP	R8,R24
    00CCC 0699      CPC	R9,R25
    00CCD 06AA      CPC	R10,R26
    00CCE 06BB      CPC	R11,R27
    00CCF F028      BCS	0x0CD5
    00CD0 1A88      SUB	R8,R24
    00CD1 0A99      SBC	R9,R25
    00CD2 0AAA      SBC	R10,R26
    00CD3 0ABB      SBC	R11,R27
    00CD4 9503      INC	R16
    00CD5 95EA      DEC	R30
    00CD6 F759      BNE	0x0CC2
    00CD7 F426      BRTC	0x0CDC
    00CD8 2D08      MOV	R16,R8
    00CD9 2D19      MOV	R17,R9
    00CDA 2D2A      MOV	R18,R10
    00CDB 2D3B      MOV	R19,R11
    00CDC C013      RJMP	long_div_epilog
long_div_prolog:
    00CDD 927A      ST	-Y,R7
    00CDE 928A      ST	-Y,R8
    00CDF 929A      ST	-Y,R9
    00CE0 92AA      ST	-Y,R10
    00CE1 92BA      ST	-Y,R11
    00CE2 92CA      ST	-Y,R12
    00CE3 93EA      ST	-Y,R30
    00CE4 938A      ST	-Y,R24
    00CE5 939A      ST	-Y,R25
    00CE6 93AA      ST	-Y,R26
    00CE7 93BA      ST	-Y,R27
    00CE8 858B      LDD	R24,Y+11
    00CE9 859C      LDD	R25,Y+12
    00CEA 85AD      LDD	R26,Y+13
    00CEB 85BE      LDD	R27,Y+14
    00CEC 2EC3      MOV	R12,R19
    00CED F00E      BRTS	0x0CEF
    00CEE 26CB      EOR	R12,R27
    00CEF 9508      RET
long_div_epilog:
    00CF0 FCC7      SBRC	R12,7
    00CF1 940E 0DAE CALL	neg32
    00CF3 91B9      LD	R27,Y+
    00CF4 91A9      LD	R26,Y+
    00CF5 9199      LD	R25,Y+
    00CF6 9189      LD	R24,Y+
    00CF7 91E9      LD	R30,Y+
    00CF8 90C9      LD	R12,Y+
    00CF9 90B9      LD	R11,Y+
    00CFA 90A9      LD	R10,Y+
    00CFB 9099      LD	R9,Y+
    00CFC 9089      LD	R8,Y+
    00CFD 9079      LD	R7,Y+
    00CFE 9624      ADIW	R28,4
    00CFF 9508      RET
tst_R16_R19:
    00D00 2FE0      MOV	R30,R16
    00D01 2BE1      OR	R30,R17
    00D02 2BE2      OR	R30,R18
    00D03 2BE3      OR	R30,R19
    00D04 9508      RET
tst_R24_R27:
    00D05 2FE8      MOV	R30,R24
    00D06 2BE9      OR	R30,R25
    00D07 2BEA      OR	R30,R26
    00D08 2BEB      OR	R30,R27
    00D09 9508      RET
neg_R24_R27:
    00D0A 9580      COM	R24
    00D0B 9590      COM	R25
    00D0C 95A0      COM	R26
    00D0D 95B0      COM	R27
    00D0E 5F8F      SUBI	R24,0xFF
    00D0F 4F9F      SBCI	R25,0xFF
    00D10 4FAF      SBCI	R26,0xFF
    00D11 4FBF      SBCI	R27,0xFF
    00D12 9508      RET
mod8u:
    00D13 9468      BSET	6
    00D14 C001      RJMP	xdiv8u
div8u:
    00D15 94E8      BCLR	6
xdiv8u:
    00D16 932A      ST	-Y,R18
    00D17 92FA      ST	-Y,R15
    00D18 92EA      ST	-Y,R14
    00D19 24FF      CLR	R15
    00D1A 24EE      CLR	R14
    00D1B E120      LDI	R18,0x10
    00D1C 0F00      LSL	R16
    00D1D 1CFF      ROL	R15
    00D1E 1CEE      ROL	R14
    00D1F 16E1      CP	R14,R17
    00D20 F010      BCS	0x0D23
    00D21 1AE1      SUB	R14,R17
    00D22 9503      INC	R16
    00D23 952A      DEC	R18
    00D24 F7B9      BNE	0x0D1C
    00D25 F40E      BRTC	0x0D27
    00D26 2D0E      MOV	R16,R14
    00D27 90E9      LD	R14,Y+
    00D28 90F9      LD	R15,Y+
    00D29 9129      LD	R18,Y+
    00D2A 9508      RET
elpm32:
    00D2B 93EA      ST	-Y,R30
    00D2C 93FA      ST	-Y,R31
    00D2D 920A      ST	-Y,R0
    00D2E 2FE0      MOV	R30,R16
    00D2F 2FF1      MOV	R31,R17
    00D30 95D8      ELPM
    00D31 2D00      MOV	R16,R0
    00D32 9631      ADIW	R30,1
    00D33 95D8      ELPM
    00D34 2D10      MOV	R17,R0
    00D35 9631      ADIW	R30,1
    00D36 95D8      ELPM
    00D37 2D20      MOV	R18,R0
    00D38 9631      ADIW	R30,1
    00D39 95D8      ELPM
    00D3A 2D30      MOV	R19,R0
    00D3B 9009      LD	R0,Y+
    00D3C 91F9      LD	R31,Y+
    00D3D 91E9      LD	R30,Y+
    00D3E 9508      RET
empy16s:
    00D3F 920A      ST	-Y,R0
    00D40 921A      ST	-Y,R1
    00D41 938A      ST	-Y,R24
    00D42 939A      ST	-Y,R25
    00D43 9F02      MUL	R16,R18
    00D44 01C0      MOVW	R24,R0
    00D45 9F12      MUL	R17,R18
    00D46 0D90      ADD	R25,R0
    00D47 9F03      MUL	R16,R19
    00D48 0D90      ADD	R25,R0
    00D49 018C      MOVW	R16,R24
    00D4A 9199      LD	R25,Y+
    00D4B 9189      LD	R24,Y+
    00D4C 9019      LD	R1,Y+
    00D4D 9009      LD	R0,Y+
    00D4E 9508      RET
pop_xgset003C:
    00D4F 90A9      LD	R10,Y+
    00D50 90B9      LD	R11,Y+
    00D51 90C9      LD	R12,Y+
    00D52 90D9      LD	R13,Y+
    00D53 9508      RET
pop_xgset00FC:
    00D54 90A9      LD	R10,Y+
    00D55 90B9      LD	R11,Y+
    00D56 90C9      LD	R12,Y+
    00D57 90D9      LD	R13,Y+
    00D58 90E9      LD	R14,Y+
    00D59 90F9      LD	R15,Y+
    00D5A 9508      RET
pop_xgset30FC:
    00D5B 90A9      LD	R10,Y+
    00D5C 90B9      LD	R11,Y+
    00D5D 90C9      LD	R12,Y+
    00D5E 90D9      LD	R13,Y+
    00D5F 90E9      LD	R14,Y+
    00D60 90F9      LD	R15,Y+
    00D61 9149      LD	R20,Y+
    00D62 9159      LD	R21,Y+
    00D63 9508      RET
pop_xgsetF0FC:
    00D64 90A9      LD	R10,Y+
    00D65 90B9      LD	R11,Y+
    00D66 90C9      LD	R12,Y+
    00D67 90D9      LD	R13,Y+
    00D68 90E9      LD	R14,Y+
    00D69 90F9      LD	R15,Y+
    00D6A 9149      LD	R20,Y+
    00D6B 9159      LD	R21,Y+
    00D6C 9169      LD	R22,Y+
    00D6D 9179      LD	R23,Y+
    00D6E 9508      RET
push_xgsetF0FC:
    00D6F 937A      ST	-Y,R23
    00D70 936A      ST	-Y,R22
push_xgset30FC:
    00D71 935A      ST	-Y,R21
    00D72 934A      ST	-Y,R20
push_xgset00FC:
    00D73 92FA      ST	-Y,R15
    00D74 92EA      ST	-Y,R14
push_xgset003C:
    00D75 92DA      ST	-Y,R13
    00D76 92CA      ST	-Y,R12
    00D77 92BA      ST	-Y,R11
    00D78 92AA      ST	-Y,R10
    00D79 9508      RET
push_xgset300C:
    00D7A 935A      ST	-Y,R21
    00D7B 934A      ST	-Y,R20
    00D7C 92BA      ST	-Y,R11
    00D7D 92AA      ST	-Y,R10
    00D7E 9508      RET
pop_xgset300C:
    00D7F 90A9      LD	R10,Y+
    00D80 90B9      LD	R11,Y+
    00D81 9149      LD	R20,Y+
    00D82 9159      LD	R21,Y+
    00D83 9508      RET
push_xgsetF000:
    00D84 937A      ST	-Y,R23
    00D85 936A      ST	-Y,R22
    00D86 935A      ST	-Y,R21
    00D87 934A      ST	-Y,R20
    00D88 9508      RET
pop_xgsetF000:
    00D89 9149      LD	R20,Y+
    00D8A 9159      LD	R21,Y+
    00D8B 9169      LD	R22,Y+
    00D8C 9179      LD	R23,Y+
    00D8D 9508      RET
push_xgsetF00C:
    00D8E 937A      ST	-Y,R23
    00D8F 936A      ST	-Y,R22
    00D90 935A      ST	-Y,R21
    00D91 934A      ST	-Y,R20
    00D92 92BA      ST	-Y,R11
    00D93 92AA      ST	-Y,R10
    00D94 9508      RET
pop_xgsetF00C:
    00D95 90A9      LD	R10,Y+
    00D96 90B9      LD	R11,Y+
    00D97 9149      LD	R20,Y+
    00D98 9159      LD	R21,Y+
    00D99 9169      LD	R22,Y+
    00D9A 9179      LD	R23,Y+
    00D9B 9508      RET
push_xgsetF03C:
    00D9C 937A      ST	-Y,R23
    00D9D 936A      ST	-Y,R22
    00D9E 935A      ST	-Y,R21
    00D9F 934A      ST	-Y,R20
    00DA0 92DA      ST	-Y,R13
    00DA1 92CA      ST	-Y,R12
    00DA2 92BA      ST	-Y,R11
    00DA3 92AA      ST	-Y,R10
    00DA4 9508      RET
pop_xgsetF03C:
    00DA5 90A9      LD	R10,Y+
    00DA6 90B9      LD	R11,Y+
    00DA7 90C9      LD	R12,Y+
    00DA8 90D9      LD	R13,Y+
    00DA9 9149      LD	R20,Y+
    00DAA 9159      LD	R21,Y+
    00DAB 9169      LD	R22,Y+
    00DAC 9179      LD	R23,Y+
    00DAD 9508      RET
neg32:
    00DAE 9500      COM	R16
    00DAF 9510      COM	R17
    00DB0 9520      COM	R18
    00DB1 9530      COM	R19
    00DB2 5F0F      SUBI	R16,0xFF
    00DB3 4F1F      SBCI	R17,0xFF
    00DB4 4F2F      SBCI	R18,0xFF
    00DB5 4F3F      SBCI	R19,0xFF
    00DB6 9508      RET
lsl32:
    00DB7 920F      PUSH	R0
    00DB8 9009      LD	R0,Y+
    00DB9 2000      TST	R0
    00DBA F031      BEQ	0x0DC1
    00DBB 0F00      LSL	R16
    00DBC 1F11      ROL	R17
    00DBD 1F22      ROL	R18
    00DBE 1F33      ROL	R19
    00DBF 940A      DEC	R0
    00DC0 CFF8      RJMP	0x0DB9
    00DC1 900F      POP	R0
    00DC2 9508      RET
lsl8:
    00DC3 2311      TST	R17
    00DC4 F019      BEQ	0x0DC8
    00DC5 0F00      LSL	R16
    00DC6 951A      DEC	R17
    00DC7 CFFB      RJMP	lsl8
    00DC8 9508      RET
fpsub:
    00DC9 9468      BSET	6
    00DCA C001      RJMP	fpadd_alt
fpadd:
    00DCB 94E8      BCLR	6
fpadd_alt:
    00DCC 940E 0EDE CALL	saveFPRegs
    00DCE 940E 0E70 CALL	unpacks
    00DD0 F409      BNE	0x0DD2
    00DD1 C048      RJMP	0x0E1A
    00DD2 2CE6      MOV	R14,R6
    00DD3 2CD5      MOV	R13,R5
    00DD4 2CC4      MOV	R12,R4
    00DD5 2EB3      MOV	R11,R19
    00DD6 2EA2      MOV	R10,R18
    00DD7 2E91      MOV	R9,R17
    00DD8 2E80      MOV	R8,R16
    00DD9 8100      LD	R16,Z
    00DDA 8111      LDD	R17,Z+1
    00DDB 8122      LDD	R18,Z+2
    00DDC 8133      LDD	R19,Z+3
    00DDD 940E 0E70 CALL	unpacks
    00DDF F409      BNE	0x0DE1
    00DE0 C044      RJMP	0x0E25
    00DE1 2D84      MOV	R24,R4
    00DE2 2D95      MOV	R25,R5
    00DE3 198C      SUB	R24,R12
    00DE4 099D      SBC	R25,R13
    00DE5 F0B9      BEQ	0x0DFD
    00DE6 F472      BPL	0x0DF5
    00DE7 9590      COM	R25
    00DE8 9580      COM	R24
    00DE9 9601      ADIW	R24,1
    00DEA 2C4C      MOV	R4,R12
    00DEB 2C5D      MOV	R5,R13
    00DEC 3188      CPI	R24,0x18
    00DED F5B8      BCC	0x0E25
    00DEE 9535      ASR	R19
    00DEF 9527      ROR	R18
    00DF0 9517      ROR	R17
    00DF1 9507      ROR	R16
    00DF2 9701      SBIW	R24,1
    00DF3 F7D1      BNE	0x0DEE
    00DF4 C008      RJMP	0x0DFD
    00DF5 3188      CPI	R24,0x18
    00DF6 F518      BCC	0x0E1A
    00DF7 94B5      ASR	R11
    00DF8 94A7      ROR	R10
    00DF9 9497      ROR	R9
    00DFA 9487      ROR	R8
    00DFB 9701      SBIW	R24,1
    00DFC F7D1      BNE	0x0DF7
    00DFD 2466      CLR	R6
    00DFE F02E      BRTS	0x0E04
    00DFF 0D08      ADD	R16,R8
    00E00 1D19      ADC	R17,R9
    00E01 1D2A      ADC	R18,R10
    00E02 1D3B      ADC	R19,R11
    00E03 C009      RJMP	0x0E0D
    00E04 1A80      SUB	R8,R16
    00E05 0A91      SBC	R9,R17
    00E06 0AA2      SBC	R10,R18
    00E07 0AB3      SBC	R11,R19
    00E08 2D08      MOV	R16,R8
    00E09 2D19      MOV	R17,R9
    00E0A 2D2A      MOV	R18,R10
    00E0B 2D3B      MOV	R19,R11
    00E0C 2333      TST	R19
    00E0D F422      BPL	0x0E12
    00E0E 940E 0DAE CALL	neg32
    00E10 E880      LDI	R24,0x80
    00E11 2E68      MOV	R6,R24
    00E12 940E 0E99 CALL	normalize_and_pack
    00E14 C002      RJMP	0x0E17
    00E15 940E 0ECE CALL	pack
    00E17 940E 0EED CALL	restoreFPRegs
    00E19 9508      RET
    00E1A 8100      LD	R16,Z
    00E1B 8111      LDD	R17,Z+1
    00E1C 8122      LDD	R18,Z+2
    00E1D 8133      LDD	R19,Z+3
    00E1E F7C6      BRTC	0x0E17
    00E1F 940E 0E78 CALL	tstR16_R19
    00E21 F3A9      BEQ	0x0E17
    00E22 E880      LDI	R24,0x80
    00E23 2738      EOR	R19,R24
    00E24 CFF2      RJMP	0x0E17
    00E25 2D08      MOV	R16,R8
    00E26 2D19      MOV	R17,R9
    00E27 2D2A      MOV	R18,R10
    00E28 2D3B      MOV	R19,R11
    00E29 2C4C      MOV	R4,R12
    00E2A 2C5D      MOV	R5,R13
    00E2B 2C6E      MOV	R6,R14
    00E2C 2333      TST	R19
    00E2D F73A      BPL	0x0E15
    00E2E 940E 0DAE CALL	neg32
    00E30 E880      LDI	R24,0x80
    00E31 2E68      MOV	R6,R24
    00E32 CFE2      RJMP	0x0E15
fpadd2:
    00E33 93FA      ST	-Y,R31
    00E34 93EA      ST	-Y,R30
    00E35 2FEC      MOV	R30,R28
    00E36 2FFD      MOV	R31,R29
    00E37 9632      ADIW	R30,2
    00E38 940E 0DCB CALL	fpadd
    00E3A 91E9      LD	R30,Y+
    00E3B 91F9      LD	R31,Y+
    00E3C 9624      ADIW	R28,4
    00E3D 9508      RET
fpint:
    00E3E 924A      ST	-Y,R4
    00E3F 925A      ST	-Y,R5
    00E40 926A      ST	-Y,R6
    00E41 938A      ST	-Y,R24
    00E42 940E 0E80 CALL	unpacku
    00E44 F111      BEQ	0x0E67
    00E45 2055      TST	R5
    00E46 F0E2      BMI	0x0E63
    00E47 E18F      LDI	R24,0x1F
    00E48 1648      CP	R4,R24
    00E49 F4C0      BCC	0x0E62
    00E4A E187      LDI	R24,0x17
    00E4B 1648      CP	R4,R24
    00E4C F0D1      BEQ	0x0E67
    00E4D F458      BCC	0x0E59
    00E4E 9441      NEG	R4
    00E4F EE89      LDI	R24,0xE9
    00E50 1A48      SUB	R4,R24
    00E51 C005      RJMP	0x0E57
    00E52 9535      ASR	R19
    00E53 9527      ROR	R18
    00E54 9517      ROR	R17
    00E55 9507      ROR	R16
    00E56 944A      DEC	R4
    00E57 F7D1      BNE	0x0E52
    00E58 C00E      RJMP	0x0E67
    00E59 E187      LDI	R24,0x17
    00E5A 1A48      SUB	R4,R24
    00E5B 0F00      LSL	R16
    00E5C 1F11      ROL	R17
    00E5D 1F22      ROL	R18
    00E5E 1F33      ROL	R19
    00E5F 944A      DEC	R4
    00E60 F7D1      BNE	0x0E5B
    00E61 C005      RJMP	0x0E67
    00E62 E73F      LDI	R19,0x7F
    00E63 2F23      MOV	R18,R19
    00E64 2F13      MOV	R17,R19
    00E65 2F03      MOV	R16,R19
    00E66 C004      RJMP	0x0E6B
    00E67 2066      TST	R6
    00E68 F011      BEQ	0x0E6B
    00E69 940E 0DAE CALL	neg32
    00E6B 9189      LD	R24,Y+
    00E6C 9069      LD	R6,Y+
    00E6D 9059      LD	R5,Y+
    00E6E 9049      LD	R4,Y+
    00E6F 9508      RET
unpacks:
    00E70 D00F      RCALL	unpacku
    00E71 F029      BEQ	0x0E77
    00E72 2066      TST	R6
    00E73 F011      BEQ	0x0E76
    00E74 940E 0DAE CALL	neg32
    00E76 9498      BCLR	1
    00E77 9508      RET
tstR16_R19:
    00E78 2300      TST	R16
    00E79 F429      BNE	0x0E7F
    00E7A 2311      TST	R17
    00E7B F419      BNE	0x0E7F
    00E7C 2322      TST	R18
    00E7D F409      BNE	0x0E7F
    00E7E 2333      TST	R19
    00E7F 9508      RET
unpacku:
    00E80 DFF7      RCALL	tstR16_R19
    00E81 F099      BEQ	0x0E95
    00E82 938A      ST	-Y,R24
    00E83 2E63      MOV	R6,R19
    00E84 E880      LDI	R24,0x80
    00E85 2268      AND	R6,R24
    00E86 0F22      LSL	R18
    00E87 1F33      ROL	R19
    00E88 2E43      MOV	R4,R19
    00E89 E78F      LDI	R24,0x7F
    00E8A 1A48      SUB	R4,R24
    00E8B 2455      CLR	R5
    00E8C 2788      CLR	R24
    00E8D 0A58      SBC	R5,R24
    00E8E 9526      LSR	R18
    00E8F E830      LDI	R19,0x80
    00E90 2B23      OR	R18,R19
    00E91 2733      CLR	R19
    00E92 9189      LD	R24,Y+
    00E93 9498      BCLR	1
    00E94 9508      RET
    00E95 2444      CLR	R4
    00E96 2455      CLR	R5
    00E97 2466      CLR	R6
    00E98 9508      RET
normalize_and_pack:
    00E99 DFDE      RCALL	tstR16_R19
    00E9A F409      BNE	0x0E9C
    00E9B 9508      RET
    00E9C 93AA      ST	-Y,R26
    00E9D 93BA      ST	-Y,R27
    00E9E 01D2      MOVW	R26,R4
    00E9F 939A      ST	-Y,R25
    00EA0 938A      ST	-Y,R24
    00EA1 E78E      LDI	R24,0x7E
    00EA2 E090      LDI	R25,0
    00EA3 2333      TST	R19
    00EA4 F049      BEQ	0x0EAE
    00EA5 9536      LSR	R19
    00EA6 9527      ROR	R18
    00EA7 9517      ROR	R17
    00EA8 9507      ROR	R16
    00EA9 17A8      CP	R26,R24
    00EAA 07B9      CPC	R27,R25
    00EAB F4CC      BGE	0x0EC5
    00EAC 9611      ADIW	R26,1
    00EAD CFF5      RJMP	0x0EA3
    00EAE 9580      COM	R24
    00EAF 9590      COM	R25
    00EB0 9601      ADIW	R24,1
    00EB1 2322      TST	R18
    00EB2 F0BA      BMI	0x0ECA
    00EB3 0F00      LSL	R16
    00EB4 1F11      ROL	R17
    00EB5 1F22      ROL	R18
    00EB6 17A8      CP	R26,R24
    00EB7 07B9      CPC	R27,R25
    00EB8 F014      BLT	0x0EBB
    00EB9 9711      SBIW	R26,1
    00EBA CFF6      RJMP	0x0EB1
    00EBB 2700      CLR	R16
    00EBC 2711      CLR	R17
    00EBD 2722      CLR	R18
    00EBE 2733      CLR	R19
    00EBF 9189      LD	R24,Y+
    00EC0 9199      LD	R25,Y+
    00EC1 012D      MOVW	R4,R26
    00EC2 91B9      LD	R27,Y+
    00EC3 91A9      LD	R26,Y+
    00EC4 9508      RET
    00EC5 2733      CLR	R19
    00EC6 EF0F      LDI	R16,0xFF
    00EC7 2F10      MOV	R17,R16
    00EC8 E72F      LDI	R18,0x7F
    00EC9 2F32      MOV	R19,R18
    00ECA 9189      LD	R24,Y+
    00ECB 9199      LD	R25,Y+
    00ECC 012D      MOVW	R4,R26
    00ECD C002      RJMP	0x0ED0
pack:
    00ECE 93AA      ST	-Y,R26
    00ECF 93BA      ST	-Y,R27
    00ED0 DFA7      RCALL	tstR16_R19
    00ED1 F049      BEQ	0x0EDB
    00ED2 01D2      MOVW	R26,R4
    00ED3 58A1      SUBI	R26,0x81
    00ED4 4FBF      SBCI	R27,0xFF
    00ED5 012D      MOVW	R4,R26
    00ED6 2D34      MOV	R19,R4
    00ED7 0F22      LSL	R18
    00ED8 9536      LSR	R19
    00ED9 9527      ROR	R18
    00EDA 2936      OR	R19,R6
    00EDB 91B9      LD	R27,Y+
    00EDC 91A9      LD	R26,Y+
    00EDD 9508      RET
saveFPRegs:
    00EDE 924A      ST	-Y,R4
    00EDF 925A      ST	-Y,R5
    00EE0 926A      ST	-Y,R6
    00EE1 927A      ST	-Y,R7
    00EE2 928A      ST	-Y,R8
    00EE3 929A      ST	-Y,R9
    00EE4 92AA      ST	-Y,R10
    00EE5 92BA      ST	-Y,R11
    00EE6 92CA      ST	-Y,R12
    00EE7 92DA      ST	-Y,R13
    00EE8 92EA      ST	-Y,R14
    00EE9 92FA      ST	-Y,R15
    00EEA 938A      ST	-Y,R24
    00EEB 939A      ST	-Y,R25
    00EEC 9508      RET
restoreFPRegs:
    00EED 9199      LD	R25,Y+
    00EEE 9189      LD	R24,Y+
    00EEF 90F9      LD	R15,Y+
    00EF0 90E9      LD	R14,Y+
    00EF1 90D9      LD	R13,Y+
    00EF2 90C9      LD	R12,Y+
    00EF3 90B9      LD	R11,Y+
    00EF4 90A9      LD	R10,Y+
    00EF5 9099      LD	R9,Y+
    00EF6 9089      LD	R8,Y+
    00EF7 9079      LD	R7,Y+
    00EF8 9069      LD	R6,Y+
    00EF9 9059      LD	R5,Y+
    00EFA 9049      LD	R4,Y+
    00EFB 9508      RET
fpmule:
    00EFC 940E 0EDE CALL	saveFPRegs
    00EFE 93AA      ST	-Y,R26
    00EFF 93BA      ST	-Y,R27
    00F00 940E 0E80 CALL	unpacku
    00F02 F1E1      BEQ	0x0F3F
    00F03 2CE6      MOV	R14,R6
    00F04 2CD5      MOV	R13,R5
    00F05 2CC4      MOV	R12,R4
    00F06 2EB3      MOV	R11,R19
    00F07 2EA2      MOV	R10,R18
    00F08 2E91      MOV	R9,R17
    00F09 2E80      MOV	R8,R16
    00F0A 8100      LD	R16,Z
    00F0B 8111      LDD	R17,Z+1
    00F0C 8122      LDD	R18,Z+2
    00F0D 8133      LDD	R19,Z+3
    00F0E 940E 0E80 CALL	unpacku
    00F10 F171      BEQ	0x0F3F
    00F11 246E      EOR	R6,R14
    00F12 0C4C      ADD	R4,R12
    00F13 1C5D      ADC	R5,R13
    00F14 E880      LDI	R24,0x80
    00F15 1648      CP	R4,R24
    00F16 0653      CPC	R5,R19
    00F17 F564      BGE	0x0F44
    00F18 E881      LDI	R24,0x81
    00F19 1648      CP	R4,R24
    00F1A EF8F      LDI	R24,0xFF
    00F1B 0658      CPC	R5,R24
    00F1C F16C      BLT	0x0F4A
    00F1D 9EA2      MUL	R10,R18
    00F1E 2DB1      MOV	R27,R1
    00F1F 2DA0      MOV	R26,R0
    00F20 9E91      MUL	R9,R17
    00F21 2D91      MOV	R25,R1
    00F22 2D80      MOV	R24,R0
    00F23 9EA0      MUL	R10,R16
    00F24 0D80      ADD	R24,R0
    00F25 1D91      ADC	R25,R1
    00F26 1FA3      ADC	R26,R19
    00F27 1FB3      ADC	R27,R19
    00F28 9E82      MUL	R8,R18
    00F29 0D80      ADD	R24,R0
    00F2A 1D91      ADC	R25,R1
    00F2B 1FA3      ADC	R26,R19
    00F2C 1FB3      ADC	R27,R19
    00F2D 9E92      MUL	R9,R18
    00F2E 0D90      ADD	R25,R0
    00F2F 1DA1      ADC	R26,R1
    00F30 1FB3      ADC	R27,R19
    00F31 9EA1      MUL	R10,R17
    00F32 0D90      ADD	R25,R0
    00F33 1DA1      ADC	R26,R1
    00F34 1FB3      ADC	R27,R19
    00F35 2F2B      MOV	R18,R27
    00F36 2F1A      MOV	R17,R26
    00F37 2F09      MOV	R16,R25
    00F38 0F88      LSL	R24
    00F39 1F00      ROL	R16
    00F3A 1F11      ROL	R17
    00F3B 1F22      ROL	R18
    00F3C 1F33      ROL	R19
    00F3D 940E 0E99 CALL	normalize_and_pack
    00F3F 91B9      LD	R27,Y+
    00F40 91A9      LD	R26,Y+
    00F41 940E 0EED CALL	restoreFPRegs
    00F43 9508      RET
    00F44 EF0F      LDI	R16,0xFF
    00F45 2F10      MOV	R17,R16
    00F46 E72F      LDI	R18,0x7F
    00F47 E78F      LDI	R24,0x7F
    00F48 2E48      MOV	R4,R24
    00F49 CFF5      RJMP	0x0F3F
    00F4A 2700      CLR	R16
    00F4B 2F10      MOV	R17,R16
    00F4C 2F20      MOV	R18,R16
    00F4D 2F30      MOV	R19,R16
    00F4E CFF0      RJMP	0x0F3F
fpmule1:
    00F4F 93FA      ST	-Y,R31
    00F50 93EA      ST	-Y,R30
    00F51 81EA      LDD	R30,Y+2
    00F52 81FB      LDD	R31,Y+3
    00F53 940E 0EFC CALL	fpmule
    00F55 91E9      LD	R30,Y+
    00F56 91F9      LD	R31,Y+
    00F57 9622      ADIW	R28,2
    00F58 9508      RET
fpcmp:
    00F59 940E 0DC9 CALL	fpsub
    00F5B 2333      TST	R19
    00F5C F03A      BMI	0x0F64
    00F5D 940E 0E78 CALL	tstR16_R19
    00F5F F011      BEQ	0x0F62
    00F60 E001      LDI	R16,1
    00F61 9508      RET
    00F62 2700      CLR	R16
    00F63 9508      RET
    00F64 EF0F      LDI	R16,0xFF
    00F65 9508      RET
fpcmp1:
    00F66 93FA      ST	-Y,R31
    00F67 93EA      ST	-Y,R30
    00F68 81EA      LDD	R30,Y+2
    00F69 81FB      LDD	R31,Y+3
    00F6A 940E 0F59 CALL	fpcmp
    00F6C 91E9      LD	R30,Y+
    00F6D 91F9      LD	R31,Y+
    00F6E 9622      ADIW	R28,2
    00F6F 2300      TST	R16
    00F70 9508      RET
