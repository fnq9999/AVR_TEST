Interrupt Vectors
    00000 940C 010A JMP	__text_start|__start
    00024 940C 0A53 JMP	_uart0_rx_isr
    00028 940C 0AC4 JMP	_uart0_tx_isr

Program Code (text area)
__text_start|__start:
    0010A EFCF      LDI	R28,0xFF
    0010B E1D0      LDI	R29,0x10
    0010C BFCD      OUT	0x3D,R28
    0010D BFDE      OUT	0x3E,R29
    0010E 51CE      SUBI	R28,0x1E
    0010F 40D0      SBCI	R29,0
    00110 EA0A      LDI	R16,0xAA
    00111 8308      ST	Y,R16
    00112 2400      CLR	R0
    00113 E6EB      LDI	R30,0x6B
    00114 E0F2      LDI	R31,2
    00115 E013      LDI	R17,3
    00116 36E8      CPI	R30,0x68
    00117 07F1      CPC	R31,R17
    00118 F011      BEQ	0x011B
    00119 9201      ST	Z+,R0
    0011A CFFB      RJMP	0x0116
    0011B 8300      ST	Z,R16
    0011C EAE8      LDI	R30,0xA8
    0011D E0F0      LDI	R31,0
    0011E E0A0      LDI	R26,0
    0011F E0B1      LDI	R27,1
    00120 E012      LDI	R17,2
    00121 E000      LDI	R16,0
    00122 BF0B      OUT	0x3B,R16
    00123 31E3      CPI	R30,0x13
    00124 07F1      CPC	R31,R17
    00125 F021      BEQ	0x012A
    00126 95C8      LPM
    00127 9631      ADIW	R30,1
    00128 920D      ST	X+,R0
    00129 CFF9      RJMP	0x0123
    0012A 940E 03D5 CALL	_main
_exit:
    0012C CFFF      RJMP	_exit
_val_pc_to_msc:
  i                    --> R20
  t                    --> R16
    0012D 940E 0D5D CALL	push_xgset300C
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\main.c
(0001) /************************************************
(0002) 文件：main.c
(0003) 用途：
(0004) 注意：内部8M晶振
(0005) 创建：2008.4.1
(0006) 修改：2008.4.1
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) 
(0010) #include "config.h"
(0011) #include<time.h>
(0012) 
(0013) unsigned char tem[20];
(0014) unsigned char tem2[20];
(0015) unsigned char read_buf[20]="201110123000";
(0016) unsigned char out_buf[50]="201110095000";
(0017) unsigned char ind=0;
(0018) #define uint8 unsigned char
(0019) 
(0020) void val_pc_to_msc(unsigned char *t){/// string to bcd
(0021) 	 unsigned char i=0;
    0012F 2744      CLR	R20
(0022) 	 for(ind=0;ind<6;++ind){  
    00130 2422      CLR	R2
    00131 9220 0146 STS	ind,R2
    00133 C02E      RJMP	0x0162
(0023) 	 	tem[ind]=(0xf0)&((t[2*ind]-'0'))<<4;
    00134 9020 0146 LDS	R2,ind
    00136 2DE2      MOV	R30,R2
    00137 27FF      CLR	R31
    00138 0FEE      LSL	R30
    00139 1FFF      ROL	R31
    0013A 0FE0      ADD	R30,R16
    0013B 1FF1      ADC	R31,R17
    0013C 8180      LD	R24,Z
    0013D 5380      SUBI	R24,0x30
    0013E 708F      ANDI	R24,0xF
    0013F 9582      SWAP	R24
    00140 7F80      ANDI	R24,0xF0
    00141 E7EF      LDI	R30,0x7F
    00142 E0F2      LDI	R31,2
    00143 2DA2      MOV	R26,R2
    00144 27BB      CLR	R27
    00145 0FAE      ADD	R26,R30
    00146 1FBF      ADC	R27,R31
    00147 938C      ST	X,R24
(0024) 		tem[ind]|=(0x0f)&(t[2*ind+1]-'0');
    00148 9020 0146 LDS	R2,ind
    0014A E78F      LDI	R24,0x7F
    0014B E092      LDI	R25,2
    0014C 2CA2      MOV	R10,R2
    0014D 24BB      CLR	R11
    0014E 0EA8      ADD	R10,R24
    0014F 1EB9      ADC	R11,R25
    00150 2DE2      MOV	R30,R2
    00151 27FF      CLR	R31
    00152 0FEE      LSL	R30
    00153 1FFF      ROL	R31
    00154 0FE0      ADD	R30,R16
    00155 1FF1      ADC	R31,R17
    00156 8181      LDD	R24,Z+1
    00157 5380      SUBI	R24,0x30
    00158 708F      ANDI	R24,0xF
    00159 01F5      MOVW	R30,R10
    0015A 8020      LD	R2,Z
    0015B 2A28      OR	R2,R24
    0015C 8220      ST	Z,R2
    0015D 9180 0146 LDS	R24,ind
    0015F 5F8F      SUBI	R24,0xFF
    00160 9380 0146 STS	ind,R24
    00162 9180 0146 LDS	R24,ind
    00164 3086      CPI	R24,6
    00165 F408      BCC	0x0167
    00166 CFCD      RJMP	0x0134
(0025) 	 }
(0026) 	 for(i=0;i<6;++i){
    00167 2744      CLR	R20
    00168 C011      RJMP	0x017A
(0027) 	 	t[i]=tem[5-i];
    00169 2E24      MOV	R2,R20
    0016A 2433      CLR	R3
    0016B E0E5      LDI	R30,5
    0016C E0F0      LDI	R31,0
    0016D 19E2      SUB	R30,R2
    0016E 09F3      SBC	R31,R3
    0016F E78F      LDI	R24,0x7F
    00170 E092      LDI	R25,2
    00171 0FE8      ADD	R30,R24
    00172 1FF9      ADC	R31,R25
    00173 8020      LD	R2,Z
    00174 2FE4      MOV	R30,R20
    00175 27FF      CLR	R31
    00176 0FE0      ADD	R30,R16
    00177 1FF1      ADC	R31,R17
    00178 8220      ST	Z,R2
    00179 9543      INC	R20
    0017A 3046      CPI	R20,6
    0017B F368      BCS	0x0169
    0017C 940C 0D62 JMP	pop_xgset300C
_time_init:
  s                    --> R20
    0017E 934A      ST	-Y,R20
    0017F 935A      ST	-Y,R21
    00180 01A8      MOVW	R20,R16
(0028) 	 }
(0029) }
(0030) 
(0031) 
(0032) 
(0033) 
(0034) void time_init(uint8 *s)// s is a string 
(0035) {
(0036) 
(0037)      	val_pc_to_msc(s);
    00181 018A      MOVW	R16,R20
    00182 DFAA      RCALL	_val_pc_to_msc
(0038)          pcf_set_byte(0x02,s[0]);         //秒
    00183 01FA      MOVW	R30,R20
    00184 8120      LD	R18,Z
    00185 2733      CLR	R19
    00186 E002      LDI	R16,2
    00187 940E 0518 CALL	_pcf_set_byte
(0039)          pcf_set_byte(0x03,s[1]);         //分钟    
    00189 01FA      MOVW	R30,R20
    0018A 8121      LDD	R18,Z+1
    0018B 2733      CLR	R19
    0018C E003      LDI	R16,3
    0018D 940E 0518 CALL	_pcf_set_byte
(0040)          pcf_set_byte(0x04,s[2]);          //时             
    0018F 01FA      MOVW	R30,R20
    00190 8122      LDD	R18,Z+2
    00191 2733      CLR	R19
    00192 E004      LDI	R16,4
    00193 940E 0518 CALL	_pcf_set_byte
(0041)          pcf_set_byte(0x05,s[3]);          //日
    00195 01FA      MOVW	R30,R20
    00196 8123      LDD	R18,Z+3
    00197 2733      CLR	R19
    00198 E005      LDI	R16,5
    00199 940E 0518 CALL	_pcf_set_byte
(0042)          pcf_set_byte(0x06,0x00);          //星期
    0019B 2722      CLR	R18
    0019C 2733      CLR	R19
    0019D E006      LDI	R16,6
    0019E 940E 0518 CALL	_pcf_set_byte
(0043)          pcf_set_byte(0x07,s[4]);          //月
    001A0 01FA      MOVW	R30,R20
    001A1 8124      LDD	R18,Z+4
    001A2 2733      CLR	R19
    001A3 E007      LDI	R16,7
    001A4 940E 0518 CALL	_pcf_set_byte
(0044)          pcf_set_byte(0x08,s[5]);          //年
    001A6 01FA      MOVW	R30,R20
    001A7 8125      LDD	R18,Z+5
    001A8 2733      CLR	R19
    001A9 E008      LDI	R16,0x8
    001AA 940E 0518 CALL	_pcf_set_byte
(0045) 		 pcf_start();
    001AC 940E 0627 CALL	_pcf_start
    001AE 9159      LD	R21,Y+
    001AF 9149      LD	R20,Y+
    001B0 9508      RET
_pre_transfer:
  t                    --> R16
    001B1 934A      ST	-Y,R20
    001B2 935A      ST	-Y,R21
(0046) }
(0047) 
(0048) 
(0049) 
(0050) void pre_transfer(unsigned char *t){
(0051) 	 t[0]&=0x7f;	 t[1]&=0x7f;
    001B3 01F8      MOVW	R30,R16
    001B4 8180      LD	R24,Z
    001B5 778F      ANDI	R24,0x7F
    001B6 8380      ST	Z,R24
    001B7 01CF      MOVW	R24,R30
    001B8 9601      ADIW	R24,1
    001B9 01FC      MOVW	R30,R24
    001BA 8180      LD	R24,Z
    001BB 778F      ANDI	R24,0x7F
    001BC 8380      ST	Z,R24
(0052) 	 t[2]&=0x3f;	 t[3]&=0x3f;
    001BD 01C8      MOVW	R24,R16
    001BE 9602      ADIW	R24,2
    001BF 01FC      MOVW	R30,R24
    001C0 8180      LD	R24,Z
    001C1 738F      ANDI	R24,0x3F
    001C2 8380      ST	Z,R24
    001C3 01A8      MOVW	R20,R16
    001C4 5F4D      SUBI	R20,0xFD
    001C5 4F5F      SBCI	R21,0xFF
    001C6 01FA      MOVW	R30,R20
    001C7 8180      LD	R24,Z
    001C8 738F      ANDI	R24,0x3F
    001C9 8380      ST	Z,R24
(0053)  	 t[4]&=0x07;	 t[5]&=0x1f;
    001CA 01A8      MOVW	R20,R16
    001CB 5F4C      SUBI	R20,0xFC
    001CC 4F5F      SBCI	R21,0xFF
    001CD 01FA      MOVW	R30,R20
    001CE 8180      LD	R24,Z
    001CF 7087      ANDI	R24,7
    001D0 8380      ST	Z,R24
    001D1 01A8      MOVW	R20,R16
    001D2 5F4B      SUBI	R20,0xFB
    001D3 4F5F      SBCI	R21,0xFF
    001D4 01FA      MOVW	R30,R20
    001D5 8180      LD	R24,Z
    001D6 718F      ANDI	R24,0x1F
    001D7 8380      ST	Z,R24
    001D8 9159      LD	R21,Y+
    001D9 9149      LD	R20,Y+
    001DA 9508      RET
_val_msc_to_pc:
  i                    --> R20
  t                    --> R10
    001DB 940E 0D5D CALL	push_xgset300C
    001DD 0158      MOVW	R10,R16
(0054) }
(0055) 
(0056) 
(0057) ///use_to_display_val_to_com_string_ok
(0058) void val_msc_to_pc(unsigned char *t){
(0059) 	 unsigned char i=0;
(0060) 	 ind=0;
    001DE 2422      CLR	R2
    001DF 9220 0146 STS	ind,R2
(0061) 	 for(i=0;i<7;++i){  
    001E1 2744      CLR	R20
    001E2 C02F      RJMP	0x0212
(0062) 	 	tem[ind++]='0'+(t[i]/16);
    001E3 9020 0146 LDS	R2,ind
    001E5 2433      CLR	R3
    001E6 2D82      MOV	R24,R2
    001E7 5F8F      SUBI	R24,0xFF
    001E8 9380 0146 STS	ind,R24
    001EA 2FE4      MOV	R30,R20
    001EB 27FF      CLR	R31
    001EC 0DEA      ADD	R30,R10
    001ED 1DFB      ADC	R31,R11
    001EE 8180      LD	R24,Z
    001EF 9582      SWAP	R24
    001F0 708F      ANDI	R24,0xF
    001F1 5D80      SUBI	R24,0xD0
    001F2 E7EF      LDI	R30,0x7F
    001F3 E0F2      LDI	R31,2
    001F4 2DA2      MOV	R26,R2
    001F5 27BB      CLR	R27
    001F6 0FAE      ADD	R26,R30
    001F7 1FBF      ADC	R27,R31
    001F8 938C      ST	X,R24
(0063) 		tem[ind++]='0'+(t[i]%16);
    001F9 9020 0146 LDS	R2,ind
    001FB 2433      CLR	R3
    001FC 2D82      MOV	R24,R2
    001FD 5F8F      SUBI	R24,0xFF
    001FE 9380 0146 STS	ind,R24
    00200 2FE4      MOV	R30,R20
    00201 27FF      CLR	R31
    00202 0DEA      ADD	R30,R10
    00203 1DFB      ADC	R31,R11
    00204 8100      LD	R16,Z
    00205 E110      LDI	R17,0x10
    00206 940E 0CF6 CALL	mod8u
    00208 2F80      MOV	R24,R16
    00209 5D80      SUBI	R24,0xD0
    0020A E7EF      LDI	R30,0x7F
    0020B E0F2      LDI	R31,2
    0020C 2DA2      MOV	R26,R2
    0020D 27BB      CLR	R27
    0020E 0FAE      ADD	R26,R30
    0020F 1FBF      ADC	R27,R31
    00210 938C      ST	X,R24
    00211 9543      INC	R20
    00212 3047      CPI	R20,7
    00213 F408      BCC	0x0215
    00214 CFCE      RJMP	0x01E3
(0064) 	 }
(0065) 	 tem[ind]='\0';
    00215 E78F      LDI	R24,0x7F
    00216 E092      LDI	R25,2
    00217 91E0 0146 LDS	R30,ind
    00219 27FF      CLR	R31
    0021A 0FE8      ADD	R30,R24
    0021B 1FF9      ADC	R31,R25
    0021C 2422      CLR	R2
    0021D 8220      ST	Z,R2
(0066) 	 for(i=0;tem[i];++i){
    0021E 2744      CLR	R20
    0021F C00D      RJMP	0x022D
(0067) 	 	t[i]=tem[i];
    00220 E78F      LDI	R24,0x7F
    00221 E092      LDI	R25,2
    00222 2FE4      MOV	R30,R20
    00223 27FF      CLR	R31
    00224 0FE8      ADD	R30,R24
    00225 1FF9      ADC	R31,R25
    00226 8020      LD	R2,Z
    00227 2FE4      MOV	R30,R20
    00228 27FF      CLR	R31
    00229 0DEA      ADD	R30,R10
    0022A 1DFB      ADC	R31,R11
    0022B 8220      ST	Z,R2
    0022C 9543      INC	R20
    0022D E78F      LDI	R24,0x7F
    0022E E092      LDI	R25,2
    0022F 2FE4      MOV	R30,R20
    00230 27FF      CLR	R31
    00231 0FE8      ADD	R30,R24
    00232 1FF9      ADC	R31,R25
    00233 8020      LD	R2,Z
    00234 2022      TST	R2
    00235 F751      BNE	0x0220
(0068) 	 }
(0069) 	 t[i]='\0';
    00236 2FE4      MOV	R30,R20
    00237 27FF      CLR	R31
    00238 0DEA      ADD	R30,R10
    00239 1DFB      ADC	R31,R11
    0023A 2422      CLR	R2
    0023B 8220      ST	Z,R2
    0023C 940C 0D62 JMP	pop_xgset300C
_len:
  cnt                  --> R10
  i                    --> R12
  s                    --> R16
    0023E 92AA      ST	-Y,R10
    0023F 92CA      ST	-Y,R12
(0070) 	 
(0071) }
(0072) 
(0073) #define uint8 unsigned char
(0074) unsigned char len(unsigned char *s){
(0075) 		 uint8 i=0,cnt=0;
    00240 24CC      CLR	R12
    00241 24AA      CLR	R10
(0076) 		 for(;s[i];++i){
    00242 C002      RJMP	0x0245
(0077) 		 	++cnt;
    00243 94A3      INC	R10
    00244 94C3      INC	R12
    00245 2DEC      MOV	R30,R12
    00246 27FF      CLR	R31
    00247 0FE0      ADD	R30,R16
    00248 1FF1      ADC	R31,R17
    00249 8020      LD	R2,Z
    0024A 2022      TST	R2
    0024B F7B9      BNE	0x0243
(0078) 		 }
(0079) 		 return cnt;
    0024C 2D0A      MOV	R16,R10
    0024D 90C9      LD	R12,Y+
    0024E 90A9      LD	R10,Y+
    0024F 9508      RET
_msc_to_pc:
  s                    --> R10
    00250 92AA      ST	-Y,R10
    00251 92BA      ST	-Y,R11
    00252 0158      MOVW	R10,R16
    00253 9722      SBIW	R28,2
(0080) }
(0081) 
(0082) 
(0083) /// com_packet
(0084) void msc_to_pc(unsigned char *s){
(0085) 	 Com_putstring (s,len(s),&RTbuf_UART0);
    00254 0185      MOVW	R16,R10
    00255 DFE8      RCALL	_len
    00256 E988      LDI	R24,0x98
    00257 E092      LDI	R25,2
    00258 8399      STD	Y+1,R25
    00259 8388      ST	Y,R24
    0025A 2F20      MOV	R18,R16
    0025B 0185      MOVW	R16,R10
    0025C 940E 092E CALL	_Com_putstring
    0025E 9622      ADIW	R28,2
    0025F 90B9      LD	R11,Y+
    00260 90A9      LD	R10,Y+
    00261 9508      RET
_pc_to_msc:
  len                  --> R12
  p                    --> R10
    00262 940E 0D58 CALL	push_xgset003C
    00264 2EC2      MOV	R12,R18
    00265 0158      MOVW	R10,R16
    00266 9722      SBIW	R28,2
(0086) }
(0087) void pc_to_msc(unsigned char *p,uint8 len){
(0088) 	 Com_getstring (p,len,&RTbuf_UART0);
    00267 E988      LDI	R24,0x98
    00268 E092      LDI	R25,2
    00269 8399      STD	Y+1,R25
    0026A 8388      ST	Y,R24
    0026B 2D2C      MOV	R18,R12
    0026C 0185      MOVW	R16,R10
    0026D 940E 097B CALL	_Com_getstring
    0026F 9622      ADIW	R28,2
    00270 940C 0D32 JMP	pop_xgset003C
_out_to_user:
  s                    --> R20
    00272 940E 0D67 CALL	push_xgsetF000
    00274 01A8      MOVW	R20,R16
(0089) }/// com_packet_end
(0090) 
(0091) void out_to_user(uint8 *s){
(0092) 	 ind=0;
    00275 2422      CLR	R2
    00276 9220 0146 STS	ind,R2
(0093)      out_buf[ind++]='2';
    00278 2433      CLR	R3
    00279 2D82      MOV	R24,R2
    0027A 5F8F      SUBI	R24,0xFF
    0027B 9380 0146 STS	ind,R24
    0027D E184      LDI	R24,0x14
    0027E E091      LDI	R25,1
    0027F 2DE2      MOV	R30,R2
    00280 27FF      CLR	R31
    00281 0FE8      ADD	R30,R24
    00282 1FF9      ADC	R31,R25
    00283 E382      LDI	R24,0x32
    00284 8380      ST	Z,R24
(0094) 	 out_buf[ind++]='0';
    00285 9020 0146 LDS	R2,ind
    00287 2433      CLR	R3
    00288 2D82      MOV	R24,R2
    00289 5F8F      SUBI	R24,0xFF
    0028A 9380 0146 STS	ind,R24
    0028C E184      LDI	R24,0x14
    0028D E091      LDI	R25,1
    0028E 2DE2      MOV	R30,R2
    0028F 27FF      CLR	R31
    00290 0FE8      ADD	R30,R24
    00291 1FF9      ADC	R31,R25
    00292 E380      LDI	R24,0x30
    00293 8380      ST	Z,R24
(0095)      out_buf[ind++]=s[12];
    00294 9160 0146 LDS	R22,ind
    00296 2777      CLR	R23
    00297 2F86      MOV	R24,R22
    00298 5F8F      SUBI	R24,0xFF
    00299 9380 0146 STS	ind,R24
    0029B E184      LDI	R24,0x14
    0029C E091      LDI	R25,1
    0029D 2FE6      MOV	R30,R22
    0029E 27FF      CLR	R31
    0029F 0FE8      ADD	R30,R24
    002A0 1FF9      ADC	R31,R25
    002A1 01DA      MOVW	R26,R20
    002A2 961C      ADIW	R26,0xC
    002A3 902C      LD	R2,X
    002A4 8220      ST	Z,R2
(0096) 	 out_buf[ind++]=s[13];
    002A5 9160 0146 LDS	R22,ind
    002A7 2777      CLR	R23
    002A8 2F86      MOV	R24,R22
    002A9 5F8F      SUBI	R24,0xFF
    002AA 9380 0146 STS	ind,R24
    002AC E184      LDI	R24,0x14
    002AD E091      LDI	R25,1
    002AE 2FE6      MOV	R30,R22
    002AF 27FF      CLR	R31
    002B0 0FE8      ADD	R30,R24
    002B1 1FF9      ADC	R31,R25
    002B2 01DA      MOVW	R26,R20
    002B3 961D      ADIW	R26,0xD
    002B4 902C      LD	R2,X
    002B5 8220      ST	Z,R2
(0097) 	 out_buf[ind++]='-';
    002B6 9160 0146 LDS	R22,ind
    002B8 2777      CLR	R23
    002B9 2F86      MOV	R24,R22
    002BA 5F8F      SUBI	R24,0xFF
    002BB 9380 0146 STS	ind,R24
    002BD E184      LDI	R24,0x14
    002BE E091      LDI	R25,1
    002BF 2FE6      MOV	R30,R22
    002C0 27FF      CLR	R31
    002C1 0FE8      ADD	R30,R24
    002C2 1FF9      ADC	R31,R25
    002C3 E28D      LDI	R24,0x2D
    002C4 8380      ST	Z,R24
(0098)      
(0099)      out_buf[ind++]=s[10];
    002C5 9160 0146 LDS	R22,ind
    002C7 2777      CLR	R23
    002C8 2F86      MOV	R24,R22
    002C9 5F8F      SUBI	R24,0xFF
    002CA 9380 0146 STS	ind,R24
    002CC E184      LDI	R24,0x14
    002CD E091      LDI	R25,1
    002CE 2FE6      MOV	R30,R22
    002CF 27FF      CLR	R31
    002D0 0FE8      ADD	R30,R24
    002D1 1FF9      ADC	R31,R25
    002D2 01DA      MOVW	R26,R20
    002D3 961A      ADIW	R26,0xA
    002D4 902C      LD	R2,X
    002D5 8220      ST	Z,R2
(0100) 	 out_buf[ind++]=s[11];
    002D6 9160 0146 LDS	R22,ind
    002D8 2777      CLR	R23
    002D9 2F86      MOV	R24,R22
    002DA 5F8F      SUBI	R24,0xFF
    002DB 9380 0146 STS	ind,R24
    002DD E184      LDI	R24,0x14
    002DE E091      LDI	R25,1
    002DF 2FE6      MOV	R30,R22
    002E0 27FF      CLR	R31
    002E1 0FE8      ADD	R30,R24
    002E2 1FF9      ADC	R31,R25
    002E3 01DA      MOVW	R26,R20
    002E4 961B      ADIW	R26,0xB
    002E5 902C      LD	R2,X
    002E6 8220      ST	Z,R2
(0101) 	 out_buf[ind++]='-';
    002E7 9160 0146 LDS	R22,ind
    002E9 2777      CLR	R23
    002EA 2F86      MOV	R24,R22
    002EB 5F8F      SUBI	R24,0xFF
    002EC 9380 0146 STS	ind,R24
    002EE E184      LDI	R24,0x14
    002EF E091      LDI	R25,1
    002F0 2FE6      MOV	R30,R22
    002F1 27FF      CLR	R31
    002F2 0FE8      ADD	R30,R24
    002F3 1FF9      ADC	R31,R25
    002F4 E28D      LDI	R24,0x2D
    002F5 8380      ST	Z,R24
(0102)      
(0103)      out_buf[ind++]=s[6];
    002F6 9160 0146 LDS	R22,ind
    002F8 2777      CLR	R23
    002F9 2F86      MOV	R24,R22
    002FA 5F8F      SUBI	R24,0xFF
    002FB 9380 0146 STS	ind,R24
    002FD E184      LDI	R24,0x14
    002FE E091      LDI	R25,1
    002FF 2FE6      MOV	R30,R22
    00300 27FF      CLR	R31
    00301 0FE8      ADD	R30,R24
    00302 1FF9      ADC	R31,R25
    00303 01DA      MOVW	R26,R20
    00304 9616      ADIW	R26,6
    00305 902C      LD	R2,X
    00306 8220      ST	Z,R2
(0104) 	 out_buf[ind++]=s[7];
    00307 9160 0146 LDS	R22,ind
    00309 2777      CLR	R23
    0030A 2F86      MOV	R24,R22
    0030B 5F8F      SUBI	R24,0xFF
    0030C 9380 0146 STS	ind,R24
    0030E E184      LDI	R24,0x14
    0030F E091      LDI	R25,1
    00310 2FE6      MOV	R30,R22
    00311 27FF      CLR	R31
    00312 0FE8      ADD	R30,R24
    00313 1FF9      ADC	R31,R25
    00314 01DA      MOVW	R26,R20
    00315 9617      ADIW	R26,7
    00316 902C      LD	R2,X
    00317 8220      ST	Z,R2
(0105) 	 out_buf[ind++]=' ';out_buf[ind++]=' ';
    00318 9160 0146 LDS	R22,ind
    0031A 2777      CLR	R23
    0031B 2F86      MOV	R24,R22
    0031C 5F8F      SUBI	R24,0xFF
    0031D 9380 0146 STS	ind,R24
    0031F E184      LDI	R24,0x14
    00320 E091      LDI	R25,1
    00321 2FE6      MOV	R30,R22
    00322 27FF      CLR	R31
    00323 0FE8      ADD	R30,R24
    00324 1FF9      ADC	R31,R25
    00325 E280      LDI	R24,0x20
    00326 8380      ST	Z,R24
    00327 9160 0146 LDS	R22,ind
    00329 2777      CLR	R23
    0032A 2F86      MOV	R24,R22
    0032B 5F8F      SUBI	R24,0xFF
    0032C 9380 0146 STS	ind,R24
    0032E E184      LDI	R24,0x14
    0032F E091      LDI	R25,1
    00330 2FE6      MOV	R30,R22
    00331 27FF      CLR	R31
    00332 0FE8      ADD	R30,R24
    00333 1FF9      ADC	R31,R25
    00334 E280      LDI	R24,0x20
    00335 8380      ST	Z,R24
(0106)      
(0107)      out_buf[ind++]=s[4];
    00336 9160 0146 LDS	R22,ind
    00338 2777      CLR	R23
    00339 2F86      MOV	R24,R22
    0033A 5F8F      SUBI	R24,0xFF
    0033B 9380 0146 STS	ind,R24
    0033D E184      LDI	R24,0x14
    0033E E091      LDI	R25,1
    0033F 2FE6      MOV	R30,R22
    00340 27FF      CLR	R31
    00341 0FE8      ADD	R30,R24
    00342 1FF9      ADC	R31,R25
    00343 01DA      MOVW	R26,R20
    00344 9614      ADIW	R26,4
    00345 902C      LD	R2,X
    00346 8220      ST	Z,R2
(0108) 	 out_buf[ind++]=s[5];
    00347 9160 0146 LDS	R22,ind
    00349 2777      CLR	R23
    0034A 2F86      MOV	R24,R22
    0034B 5F8F      SUBI	R24,0xFF
    0034C 9380 0146 STS	ind,R24
    0034E E184      LDI	R24,0x14
    0034F E091      LDI	R25,1
    00350 2FE6      MOV	R30,R22
    00351 27FF      CLR	R31
    00352 0FE8      ADD	R30,R24
    00353 1FF9      ADC	R31,R25
    00354 01DA      MOVW	R26,R20
    00355 9615      ADIW	R26,5
    00356 902C      LD	R2,X
    00357 8220      ST	Z,R2
(0109) 	 out_buf[ind++]=':';
    00358 9160 0146 LDS	R22,ind
    0035A 2777      CLR	R23
    0035B 2F86      MOV	R24,R22
    0035C 5F8F      SUBI	R24,0xFF
    0035D 9380 0146 STS	ind,R24
    0035F E184      LDI	R24,0x14
    00360 E091      LDI	R25,1
    00361 2FE6      MOV	R30,R22
    00362 27FF      CLR	R31
    00363 0FE8      ADD	R30,R24
    00364 1FF9      ADC	R31,R25
    00365 E38A      LDI	R24,0x3A
    00366 8380      ST	Z,R24
(0110) 	 out_buf[ind++]=s[2];
    00367 9160 0146 LDS	R22,ind
    00369 2777      CLR	R23
    0036A 2F86      MOV	R24,R22
    0036B 5F8F      SUBI	R24,0xFF
    0036C 9380 0146 STS	ind,R24
    0036E E184      LDI	R24,0x14
    0036F E091      LDI	R25,1
    00370 2FE6      MOV	R30,R22
    00371 27FF      CLR	R31
    00372 0FE8      ADD	R30,R24
    00373 1FF9      ADC	R31,R25
    00374 01DA      MOVW	R26,R20
    00375 9612      ADIW	R26,2
    00376 902C      LD	R2,X
    00377 8220      ST	Z,R2
(0111) 	 out_buf[ind++]=s[3];
    00378 9160 0146 LDS	R22,ind
    0037A 2777      CLR	R23
    0037B 2F86      MOV	R24,R22
    0037C 5F8F      SUBI	R24,0xFF
    0037D 9380 0146 STS	ind,R24
    0037F E184      LDI	R24,0x14
    00380 E091      LDI	R25,1
    00381 2FE6      MOV	R30,R22
    00382 27FF      CLR	R31
    00383 0FE8      ADD	R30,R24
    00384 1FF9      ADC	R31,R25
    00385 01DA      MOVW	R26,R20
    00386 9613      ADIW	R26,3
    00387 902C      LD	R2,X
    00388 8220      ST	Z,R2
(0112) 	 out_buf[ind++]=':';
    00389 9160 0146 LDS	R22,ind
    0038B 2777      CLR	R23
    0038C 2F86      MOV	R24,R22
    0038D 5F8F      SUBI	R24,0xFF
    0038E 9380 0146 STS	ind,R24
    00390 E184      LDI	R24,0x14
    00391 E091      LDI	R25,1
    00392 2FE6      MOV	R30,R22
    00393 27FF      CLR	R31
    00394 0FE8      ADD	R30,R24
    00395 1FF9      ADC	R31,R25
    00396 E38A      LDI	R24,0x3A
    00397 8380      ST	Z,R24
(0113) 	 out_buf[ind++]=s[0];
    00398 9160 0146 LDS	R22,ind
    0039A 2777      CLR	R23
    0039B 2F86      MOV	R24,R22
    0039C 5F8F      SUBI	R24,0xFF
    0039D 9380 0146 STS	ind,R24
    0039F E184      LDI	R24,0x14
    003A0 E091      LDI	R25,1
    003A1 2FE6      MOV	R30,R22
    003A2 27FF      CLR	R31
    003A3 0FE8      ADD	R30,R24
    003A4 1FF9      ADC	R31,R25
    003A5 01DA      MOVW	R26,R20
    003A6 902C      LD	R2,X
    003A7 8220      ST	Z,R2
(0114) 	 out_buf[ind++]=s[1];
    003A8 9160 0146 LDS	R22,ind
    003AA 2777      CLR	R23
    003AB 2F86      MOV	R24,R22
    003AC 5F8F      SUBI	R24,0xFF
    003AD 9380 0146 STS	ind,R24
    003AF E184      LDI	R24,0x14
    003B0 E091      LDI	R25,1
    003B1 2FE6      MOV	R30,R22
    003B2 27FF      CLR	R31
    003B3 0FE8      ADD	R30,R24
    003B4 1FF9      ADC	R31,R25
    003B5 9611      ADIW	R26,1
    003B6 902C      LD	R2,X
    003B7 8220      ST	Z,R2
(0115) 	 out_buf[ind++]='\n';
    003B8 9140 0146 LDS	R20,ind
    003BA 2755      CLR	R21
    003BB 2F84      MOV	R24,R20
    003BC 5F8F      SUBI	R24,0xFF
    003BD 9380 0146 STS	ind,R24
    003BF E184      LDI	R24,0x14
    003C0 E091      LDI	R25,1
    003C1 2FE4      MOV	R30,R20
    003C2 27FF      CLR	R31
    003C3 0FE8      ADD	R30,R24
    003C4 1FF9      ADC	R31,R25
    003C5 E08A      LDI	R24,0xA
    003C6 8380      ST	Z,R24
(0116) 	 out_buf[ind]='\0';
    003C7 E184      LDI	R24,0x14
    003C8 E091      LDI	R25,1
    003C9 91E0 0146 LDS	R30,ind
    003CB 27FF      CLR	R31
    003CC 0FE8      ADD	R30,R24
    003CD 1FF9      ADC	R31,R25
    003CE 2422      CLR	R2
    003CF 8220      ST	Z,R2
(0117)    	 msc_to_pc(out_buf);	
    003D0 E104      LDI	R16,0x14
    003D1 E011      LDI	R17,1
    003D2 DE7D      RCALL	_msc_to_pc
    003D3 940C 0D6C JMP	pop_xgsetF000
_main:
  ng                   --> R10
  W_Buff               --> R20
  R_Buff               --> R20
  key_brk              --> R22
  Key                  --> R10
  i                    --> R22
  j                    --> R10
    003D5 9722      SBIW	R28,2
(0118) }
(0119) 
(0120) void main(void)
(0121) {
(0122)      unsigned char *W_Buff="www.avrvi.com",*R_Buff="\0",i=0,j=0,Key,key_brk,ng;
    003D6 E147      LDI	R20,0x17
    003D7 E052      LDI	R21,2
    003D8 24AA      CLR	R10
(0123) 	 
(0124) 	 //// init_process
(0125) 	 CLI();
    003D9 94F8      BCLR	7
(0126) 	 Com_init();
    003DA 940E 08DE CALL	_Com_init
(0127) 	 twi_init();
    003DC 940E 0B0D CALL	_twi_init
(0128) 	 SEI();
    003DE 9478      BSET	7
(0129)  	 //// init_process_end
(0130) 	 
(0131) 	 //pcf 
(0132) //	 msc_to_pc("Plead write the time to the msc now!\n\n");
(0133) //     while(1);
(0134) // msc_to_pc("24C01 Write: www.avrvi.com\n\n");
(0135) //	 time_init(read_buf);
(0136) //	 pcf_start();
(0137) 	//pcf_init_end	
(0138) //	 delay_nms(5000);	 
(0139) 
(0140) //////////////////////////////////////////////exp_process
(0141) 
(0142) /////////////////////////led_test
(0143) 
(0144) 
(0145)    	 msc_to_pc("led_test\n");
    003DF E00D      LDI	R16,0xD
    003E0 E012      LDI	R17,2
    003E1 DE6E      RCALL	_msc_to_pc
(0146) 
(0147)  PORTE = 0xFF;
    003E2 EF8F      LDI	R24,0xFF
    003E3 B983      OUT	0x03,R24
(0148)  DDRE  = 0xFF;
    003E4 B982      OUT	0x02,R24
(0149) 
(0150)  	   for(i=0;i<3;i++)
    003E5 2766      CLR	R22
    003E6 C00D      RJMP	0x03F4
(0151) 	 	 {
(0152) 		  PORTE = 0;
    003E7 2422      CLR	R2
    003E8 B823      OUT	0x03,R2
(0153) 		  delay_nms(300);
    003E9 E20C      LDI	R16,0x2C
    003EA E011      LDI	R17,1
    003EB 940E 068E CALL	_delay_nms
(0154) 		  PORTE = 0xff;
    003ED EF8F      LDI	R24,0xFF
    003EE B983      OUT	0x03,R24
(0155) 		  delay_nms(300);
    003EF E20C      LDI	R16,0x2C
    003F0 E011      LDI	R17,1
    003F1 940E 068E CALL	_delay_nms
    003F3 9563      INC	R22
    003F4 3063      CPI	R22,3
    003F5 F388      BCS	0x03E7
(0156) 		 }
(0157) 
(0158) //.///////////////////////led_test_end
(0159) 
(0160) 
(0161) 
(0162) /////////////////////////seg7
(0163) 
(0164)    	 msc_to_pc("SEG7_test\n");
    003F6 E002      LDI	R16,2
    003F7 E012      LDI	R17,2
    003F8 DE57      RCALL	_msc_to_pc
(0165) 		HC_595_init();
    003F9 940E 069C CALL	_HC_595_init
(0166) 		//  Seg7_Led_display(111*i)
(0167) 		 for(i=0;i<10;i++)
    003FB 2766      CLR	R22
    003FC C013      RJMP	0x0410
(0168) 	 	 {
(0169) 		  for(j=0;j<200;++j){
    003FD 24AA      CLR	R10
    003FE C00D      RJMP	0x040C
(0170) 		  	Seg7_Led_display(1111*i);
    003FF 2F26      MOV	R18,R22
    00400 2733      CLR	R19
    00401 E507      LDI	R16,0x57
    00402 E014      LDI	R17,4
    00403 940E 0D22 CALL	empy16s
    00405 940E 0732 CALL	_Seg7_Led_display
(0171)      		  delay_nms(1);
    00407 E001      LDI	R16,1
    00408 E010      LDI	R17,0
    00409 940E 068E CALL	_delay_nms
    0040B 94A3      INC	R10
    0040C 2D8A      MOV	R24,R10
    0040D 3C88      CPI	R24,0xC8
    0040E F380      BCS	0x03FF
    0040F 9563      INC	R22
    00410 306A      CPI	R22,0xA
    00411 F358      BCS	0x03FD
(0172) 		  }  
(0173) 		 }
(0174) 
(0175) 
(0176) /////////////////////////seg7_test_end
(0177) 
(0178) 
(0179) 
(0180) /////////////////////////BUZZ_KEY_test
(0181)    	 msc_to_pc("BUZZ_KEY_test\n");
    00412 EF03      LDI	R16,0xF3
    00413 E011      LDI	R17,1
    00414 DE3B      RCALL	_msc_to_pc
(0182)       DDRE = 0xFF;
    00415 EF8F      LDI	R24,0xFF
    00416 B982      OUT	0x02,R24
(0183)        PORTE = 0xFF;
    00417 B983      OUT	0x03,R24
(0184)     Key_init();
    00418 940E 08BA CALL	_Key_init
(0185)     Buzz_init();
    0041A 940E 0653 CALL	_Buzz_init
(0186) 	key_brk=0;
    0041C 2766      CLR	R22
    0041D C071      RJMP	0x048F
(0187) 	while(1) {
(0188) 		if(key_brk)break;
    0041E 2366      TST	R22
    0041F F009      BEQ	0x0421
    00420 C06F      RJMP	0x0490
(0189)         Key=get_key();
    00421 940E 08BF CALL	_get_key
    00423 2EA0      MOV	R10,R16
(0190)         switch(Key) {
    00424 24BB      CLR	R11
    00425 01C5      MOVW	R24,R10
    00426 3B80      CPI	R24,0xB0
    00427 E0E0      LDI	R30,0
    00428 079E      CPC	R25,R30
    00429 F409      BNE	0x042B
    0042A C037      RJMP	0x0462
    0042B EB80      LDI	R24,0xB0
    0042C 158A      CP	R24,R10
    0042D 059B      CPC	R25,R11
    0042E F034      BLT	0x0435
    0042F 01C5      MOVW	R24,R10
    00430 3780      CPI	R24,0x70
    00431 E0E0      LDI	R30,0
    00432 079E      CPC	R25,R30
    00433 F099      BEQ	0x0447
    00434 C05A      RJMP	0x048F
    00435 01C5      MOVW	R24,R10
    00436 3D80      CPI	R24,0xD0
    00437 E0E0      LDI	R30,0
    00438 079E      CPC	R25,R30
    00439 F409      BNE	0x043B
    0043A C03C      RJMP	0x0477
    0043B 3D80      CPI	R24,0xD0
    0043C E0E0      LDI	R30,0
    0043D 079E      CPC	R25,R30
    0043E F40C      BGE	0x0440
    0043F C04F      RJMP	0x048F
    00440 01C5      MOVW	R24,R10
    00441 3E80      CPI	R24,0xE0
    00442 E0E0      LDI	R30,0
    00443 079E      CPC	R25,R30
    00444 F409      BNE	0x0446
    00445 C040      RJMP	0x0486
    00446 C048      RJMP	0x048F
(0191)             case ( ((1<<S4)^0xF0) ): {
(0192)                 PORTE =~ (1<<3);
    00447 EF87      LDI	R24,0xF7
    00448 B983      OUT	0x03,R24
(0193)                 Beep(100,50);
    00449 E322      LDI	R18,0x32
    0044A E030      LDI	R19,0
    0044B E604      LDI	R16,0x64
    0044C E010      LDI	R17,0
    0044D 940E 065E CALL	_Beep
(0194)                 Beep(100,50);
    0044F E322      LDI	R18,0x32
    00450 E030      LDI	R19,0
    00451 E604      LDI	R16,0x64
    00452 E010      LDI	R17,0
    00453 940E 065E CALL	_Beep
(0195)                 Beep(100,50);
    00455 E322      LDI	R18,0x32
    00456 E030      LDI	R19,0
    00457 E604      LDI	R16,0x64
    00458 E010      LDI	R17,0
    00459 940E 065E CALL	_Beep
(0196)                 Beep(100,50);
    0045B E322      LDI	R18,0x32
    0045C E030      LDI	R19,0
    0045D E604      LDI	R16,0x64
    0045E E010      LDI	R17,0
    0045F 940E 065E CALL	_Beep
(0197) 				break;
    00461 C02D      RJMP	0x048F
(0198)             }
(0199)             case ( ((1<<S3)^0xF0) ): {
(0200)                 PORTE =~ (1<<2);
    00462 EF8B      LDI	R24,0xFB
    00463 B983      OUT	0x03,R24
(0201)                 Beep(100,50);
    00464 E322      LDI	R18,0x32
    00465 E030      LDI	R19,0
    00466 E604      LDI	R16,0x64
    00467 E010      LDI	R17,0
    00468 940E 065E CALL	_Beep
(0202)                 Beep(100,50);
    0046A E322      LDI	R18,0x32
    0046B E030      LDI	R19,0
    0046C E604      LDI	R16,0x64
    0046D E010      LDI	R17,0
    0046E 940E 065E CALL	_Beep
(0203)                 Beep(100,50);
    00470 E322      LDI	R18,0x32
    00471 E030      LDI	R19,0
    00472 E604      LDI	R16,0x64
    00473 E010      LDI	R17,0
    00474 940E 065E CALL	_Beep
(0204) 				break;
    00476 C018      RJMP	0x048F
(0205)             }
(0206)             case ( ((1<<S2)^0xF0) ): {
(0207)                 PORTE =~ (1<<1);
    00477 EF8D      LDI	R24,0xFD
    00478 B983      OUT	0x03,R24
(0208)                 Beep(100,50);
    00479 E322      LDI	R18,0x32
    0047A E030      LDI	R19,0
    0047B E604      LDI	R16,0x64
    0047C E010      LDI	R17,0
    0047D 940E 065E CALL	_Beep
(0209)                 Beep(100,50);
    0047F E322      LDI	R18,0x32
    00480 E030      LDI	R19,0
    00481 E604      LDI	R16,0x64
    00482 E010      LDI	R17,0
    00483 940E 065E CALL	_Beep
(0210) 				break;
    00485 C009      RJMP	0x048F
(0211)             }
(0212)             case ( ((1<<S1)^0xF0) ): {
(0213)                 PORTE =~ (1<<0);
    00486 EF8E      LDI	R24,0xFE
    00487 B983      OUT	0x03,R24
(0214)                 Beep(100,50);
    00488 E322      LDI	R18,0x32
    00489 E030      LDI	R19,0
    0048A E604      LDI	R16,0x64
    0048B E010      LDI	R17,0
    0048C 940E 065E CALL	_Beep
(0215) 				key_brk=1;
    0048E E061      LDI	R22,1
    0048F CF8E      RJMP	0x041E
(0216)                 break;
(0217)             }
(0218)             default: {
(0219)                 break;
(0220)             }
(0221)         }
(0222) 
(0223)     }
(0224) 	
(0225) 	
(0226) 
(0227) /////////////////////////BUZZ_KEY_test_end
(0228) // 1.read the pcf_init_data
(0229) 
(0230)    	 msc_to_pc("read the pcf_init_data\n");
    00490 ED0B      LDI	R16,0xDB
    00491 E011      LDI	R17,1
    00492 DDBD      RCALL	_msc_to_pc
(0231) 	 pcfread(tem2,2,7);/// get the bcd_to_year
    00493 E087      LDI	R24,7
    00494 E090      LDI	R25,0
    00495 8399      STD	Y+1,R25
    00496 8388      ST	Y,R24
    00497 E022      LDI	R18,2
    00498 E030      LDI	R19,0
    00499 E60B      LDI	R16,0x6B
    0049A E012      LDI	R17,2
    0049B 940E 0644 CALL	_pcfread
(0232) 	 pre_transfer(tem2);///and op
    0049D E60B      LDI	R16,0x6B
    0049E E012      LDI	R17,2
    0049F DD11      RCALL	_pre_transfer
(0233)      val_msc_to_pc(tem2);/// bcd to string
    004A0 E60B      LDI	R16,0x6B
    004A1 E012      LDI	R17,2
    004A2 DD38      RCALL	_val_msc_to_pc
(0234)    	 msc_to_pc("read the pcf_init_data_end\n");
    004A3 EB0F      LDI	R16,0xBF
    004A4 E011      LDI	R17,1
    004A5 DDAA      RCALL	_msc_to_pc
(0235) // 2.pcf_init_data_read to pc
(0236)    out_to_user(tem2);
    004A6 E60B      LDI	R16,0x6B
    004A7 E012      LDI	R17,2
    004A8 DDC9      RCALL	_out_to_user
(0237) //3. update the pcf data_to now time
(0238)    	 msc_to_pc("update the pcf data_to now time\n");	 
    004A9 E90E      LDI	R16,0x9E
    004AA E011      LDI	R17,1
    004AB DDA4      RCALL	_msc_to_pc
(0239)      time_init(read_buf);
    004AC E000      LDI	R16,0
    004AD E011      LDI	R17,1
    004AE DCCF      RCALL	_time_init
(0240) // 4.read the pcd_now_data
(0241)     pcfread(tem2,2,7);/// get the bcd_to_year
    004AF E087      LDI	R24,7
    004B0 E090      LDI	R25,0
    004B1 8399      STD	Y+1,R25
    004B2 8388      ST	Y,R24
    004B3 E022      LDI	R18,2
    004B4 E030      LDI	R19,0
    004B5 E60B      LDI	R16,0x6B
    004B6 E012      LDI	R17,2
    004B7 940E 0644 CALL	_pcfread
(0242) 	pre_transfer(tem2);///and op
    004B9 E60B      LDI	R16,0x6B
    004BA E012      LDI	R17,2
    004BB DCF5      RCALL	_pre_transfer
(0243) 	val_msc_to_pc(tem2);/// bcd to string
    004BC E60B      LDI	R16,0x6B
    004BD E012      LDI	R17,2
    004BE DD1C      RCALL	_val_msc_to_pc
(0244) 	
(0245) // 5.pcf_now_data_read to pc
(0246) 	out_to_user(tem2);
    004BF E60B      LDI	R16,0x6B
    004C0 E012      LDI	R17,2
    004C1 DDB0      RCALL	_out_to_user
(0247) // 6.write_to_at24c01
(0248)    	msc_to_pc("The string written to the AT24C01 is: \"GOOD_EXP\"\n");
    004C2 E60C      LDI	R16,0x6C
    004C3 E011      LDI	R17,1
    004C4 DD8B      RCALL	_msc_to_pc
(0249) 	 //wt24c(W_Buff,0x00,13);
(0250) 	 wt24c("GOOD_EXP\n\0",0x00,10);
    004C5 E08A      LDI	R24,0xA
    004C6 E090      LDI	R25,0
    004C7 8399      STD	Y+1,R25
    004C8 8388      ST	Y,R24
    004C9 2722      CLR	R18
    004CA 2733      CLR	R19
    004CB E601      LDI	R16,0x61
    004CC E011      LDI	R17,1
    004CD 940E 0558 CALL	_wt24c
(0251) //7.at24c01_to_pc
(0252)    	msc_to_pc("GET THE STRING:\n");
    004CF E500      LDI	R16,0x50
    004D0 E011      LDI	R17,1
    004D1 DD7E      RCALL	_msc_to_pc
(0253) 	rd24c(R_Buff,0x00,10);
    004D2 E08A      LDI	R24,0xA
    004D3 E090      LDI	R25,0
    004D4 8399      STD	Y+1,R25
    004D5 8388      ST	Y,R24
    004D6 2722      CLR	R18
    004D7 2733      CLR	R19
    004D8 018A      MOVW	R16,R20
    004D9 940E 05BC CALL	_rd24c
(0254) 	msc_to_pc(R_Buff);
    004DB 018A      MOVW	R16,R20
    004DC DD73      RCALL	_msc_to_pc
(0255) //8.ds18b20
(0256)     
(0257)     msc_to_pc("DS18B20\n");
    004DD E407      LDI	R16,0x47
    004DE E011      LDI	R17,1
    004DF DD70      RCALL	_msc_to_pc
(0258)     ng= read_temperature();
    004E0 940E 0BC5 CALL	_read_temperature
    004E2 2EA0      MOV	R10,R16
(0259)     convert_temp_data();
    004E3 940E 0BE5 CALL	_convert_temp_data
(0260)     msc_to_pc(current_temp_display_buffer);
    004E5 E404      LDI	R16,0x44
    004E6 E012      LDI	R17,2
    004E7 DD68      RCALL	_msc_to_pc
(0261)     
(0262) while(1);
    004E8 CFFF      RJMP	0x04E8
(0263) ////////////////////////////////////////exp_process_end
(0264) 
(0265) 	 wt24c(W_Buff,0x00,13);
(0266) 	 delay_nms(500);
(0267) 	 //Com_putstring ("24C01 Read: ",12,&RTbuf_UART0);
(0268) 	 rd24c(R_Buff,0x00,13);Com_putstring (R_Buff,13,&RTbuf_UART0);
(0269) 	 //Com_putstring ("\n\n",2,&RTbuf_UART0);
(0270)      delay_nms(500);
(0271) 	 while(1)
    004E9 CFFF      RJMP	0x04E9
    004EA 9622      ADIW	R28,2
    004EB 9508      RET
_wt24c_fc:
  t                    --> R22
  n                    --> R10
  ad                   --> R12
  p                    --> R20
    004EC 940E 0D7F CALL	push_xgsetF03C
    004EE 0169      MOVW	R12,R18
    004EF 01A8      MOVW	R20,R16
    004F0 84A8      LDD	R10,Y+8
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\AT24C01.c
(0001) /************************************************
(0002) 文件：AT24C01.c
(0003) 用途：AT24C01操作函数
(0004) 注意：
(0005) 创建：2008.1.26
(0006) 修改：2008.1.26
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) unsigned char syserr;
(0011) /*************************************************************************
(0012) ** 函数名称: unsigned char * wt24c_fc(unsigned char *p, unsigned int ad, unsigned char n)
(0013) ** 功能描述: 向24Cxx写入数据wt24c_h()所要调用的函数
(0014) ** 输　入: 
(0015) ** 输出	 : 返回写入n个字节后的主机内存指针
(0016) ** 全局变量: 无
(0017) ** 调用模块: 
(0018) ** 说明：
(0019) ** 注意：
(0020) **************************************************************************/
(0021) 
(0022) 
(0023) 
(0024) unsigned char * wt24c_fc(unsigned char *p, unsigned int ad, unsigned char n)
(0025) {
(0026) 	unsigned char t=0;
(0027) 
(0028) 	#if e2prom<32
(0029) 	t=ad>>8;
    004F1 01B6      MOVW	R22,R12
    004F2 2F67      MOV	R22,R23
    004F3 2777      CLR	R23
(0030) 	t<<=1;
    004F4 0F66      LSL	R22
(0031) 	#endif
(0032) 	
(0033) 	i2cstart();					//发送起始信号
    004F5 940E 0B1B CALL	_i2cstart
(0034) 		
(0035) 	if(i2cwt(W_ADD_COM+t)==SLAW)//发送SLA_W, 写字节命令及器件地址
    004F7 2F06      MOV	R16,R22
    004F8 5600      SUBI	R16,0x60
    004F9 940E 0B23 CALL	_i2cwt
    004FB 3108      CPI	R16,0x18
    004FC F479      BNE	0x050C
(0036) 	{	
(0037) 		#if e2prom>16
(0038) 		i2cwt(ad>>8);			//ad_dst的高位到器件
(0039) 		#endif
(0040) 		i2cwt(ad);				//ad_dst的低位到器件
    004FD 2D0C      MOV	R16,R12
    004FE 940E 0B23 CALL	_i2cwt
(0041) 			
(0042) 		for(;n>0;n--)			//发送要写入的数据
    00500 C007      RJMP	0x0508
(0043) 		{
(0044) 		    i2cwt(*p);
    00501 01FA      MOVW	R30,R20
    00502 8100      LD	R16,Z
    00503 940E 0B23 CALL	_i2cwt
(0045) 			p++;
    00505 5F4F      SUBI	R20,0xFF
    00506 4F5F      SBCI	R21,0xFF
    00507 94AA      DEC	R10
    00508 E080      LDI	R24,0
    00509 158A      CP	R24,R10
    0050A F3B0      BCS	0x0501
(0046) 		}
(0047) 	}
    0050B C003      RJMP	0x050F
(0048) 	else syserr=ERR_SLAW;		//写字节命令及器件地址错
    0050C E081      LDI	R24,1
    0050D 9380 0293 STS	syserr,R24
(0049) 	
(0050) 	i2cstop();
    0050F 940E 0B3B CALL	_i2cstop
(0051)     delay_nms(6);						//延时6ms
    00511 E006      LDI	R16,6
    00512 E010      LDI	R17,0
    00513 940E 068E CALL	_delay_nms
(0052) 	
(0053) 	return(p);
    00515 018A      MOVW	R16,R20
    00516 940C 0D88 JMP	pop_xgsetF03C
_pcf_set_byte:
  startcode            --> Y,+2
  ad                   --> R12
  p                    --> R10
    00518 92AA      ST	-Y,R10
    00519 92CA      ST	-Y,R12
    0051A 0169      MOVW	R12,R18
    0051B 2EA0      MOV	R10,R16
    0051C 9723      SBIW	R28,3
(0054) }
(0055) 
(0056) void pcf_set_byte(unsigned char p, unsigned int ad){
(0057)  unsigned char startcode=ad;
    0051D 82CA      STD	Y+2,R12
(0058)   wt24c_fc_pcf(&startcode,p,1);
    0051E E081      LDI	R24,1
    0051F E090      LDI	R25,0
    00520 8399      STD	Y+1,R25
    00521 8388      ST	Y,R24
    00522 2D2A      MOV	R18,R10
    00523 2733      CLR	R19
    00524 018E      MOVW	R16,R28
    00525 5F0E      SUBI	R16,0xFE
    00526 4F1F      SBCI	R17,0xFF
    00527 D004      RCALL	_wt24c_fc_pcf
    00528 9623      ADIW	R28,3
    00529 90C9      LD	R12,Y+
    0052A 90A9      LD	R10,Y+
    0052B 9508      RET
_wt24c_fc_pcf:
  t                    --> R22
  n                    --> R10
  ad                   --> R12
  p                    --> R20
    0052C 940E 0D7F CALL	push_xgsetF03C
    0052E 0169      MOVW	R12,R18
    0052F 01A8      MOVW	R20,R16
    00530 84A8      LDD	R10,Y+8
(0059) }
(0060) 
(0061) 
(0062) 
(0063) unsigned char * wt24c_fc_pcf(unsigned char *p, unsigned int ad, unsigned char n)
(0064) {
(0065) 
(0066) 	unsigned char t=0;
(0067) 	#if e2prom<32
(0068) 	t=ad>>8;
    00531 01B6      MOVW	R22,R12
    00532 2F67      MOV	R22,R23
    00533 2777      CLR	R23
(0069) 	t<<=1;
    00534 0F66      LSL	R22
(0070) 	#endif
(0071) 	
(0072) 	i2cstart();					//发送起始信号
    00535 940E 0B1B CALL	_i2cstart
(0073) 		
(0074) 	if(i2cwt(W_ADD_COM_PCF+t)==SLAW)//发送SLA_W, 写字节命令及器件地址
    00537 2F06      MOV	R16,R22
    00538 550E      SUBI	R16,0x5E
    00539 940E 0B23 CALL	_i2cwt
    0053B 3108      CPI	R16,0x18
    0053C F479      BNE	0x054C
(0075) 	{	
(0076) 		#if e2prom>16
(0077) 		i2cwt(ad>>8);			//ad_dst的高位到器件
(0078) 		#endif
(0079) 		i2cwt(ad);				//ad_dst的低位到器件
    0053D 2D0C      MOV	R16,R12
    0053E 940E 0B23 CALL	_i2cwt
(0080) 			
(0081) 		for(;n>0;n--)			//发送要写入的数据
    00540 C007      RJMP	0x0548
(0082) 		{
(0083) 		    i2cwt(*p);
    00541 01FA      MOVW	R30,R20
    00542 8100      LD	R16,Z
    00543 940E 0B23 CALL	_i2cwt
(0084) 			p++;
    00545 5F4F      SUBI	R20,0xFF
    00546 4F5F      SBCI	R21,0xFF
    00547 94AA      DEC	R10
    00548 E080      LDI	R24,0
    00549 158A      CP	R24,R10
    0054A F3B0      BCS	0x0541
(0085) 		}
(0086) 	}
    0054B C003      RJMP	0x054F
(0087) 	else syserr=ERR_SLAW;		//写字节命令及器件地址错
    0054C E081      LDI	R24,1
    0054D 9380 0293 STS	syserr,R24
(0088) 	
(0089) 	i2cstop();
    0054F 940E 0B3B CALL	_i2cstop
(0090)     delay_nms(6);						//延时6ms
    00551 E006      LDI	R16,6
    00552 E010      LDI	R17,0
    00553 940E 068E CALL	_delay_nms
(0091) 	
(0092) 	return(p);
    00555 018A      MOVW	R16,R20
    00556 940C 0D88 JMP	pop_xgsetF03C
_wt24c:
  n                    --> R12
  num                  --> R22
  ad_dst               --> R20
  p_rsc                --> R10
    00558 940E 0D7F CALL	push_xgsetF03C
    0055A 01A9      MOVW	R20,R18
    0055B 0158      MOVW	R10,R16
    0055C 9721      SBIW	R28,1
    0055D 8569      LDD	R22,Y+9
    0055E 857A      LDD	R23,Y+10
(0093) }
(0094) 
(0095) 
(0096) /*************************************************************************
(0097) ** 函数名称: 
(0098) ** 功能描述: 向24Cxx写入数据
(0099) ** 输　入: *p_rsc要输出数据的主机内存地址指针; ad_dst要写入数据的i2c的地址(双字节); num数据个数
(0100) ** 输出	 : 
(0101) ** 全局变量: 无
(0102) ** 调用模块: 
(0103) ** 说明：ad_dst: ad_dst+(num-1)不能大于器件的最高地址; num必须>0;
(0104) ** 注意：
(0105) **************************************************************************/
(0106) void wt24c(unsigned char *p_rsc, unsigned int ad_dst, unsigned int num)
(0107) {
(0108)     unsigned int n;
(0109) 
(0110)     n=ad_dst/PAGE_SIZE;		//确定地址与块地址的差
    0055F 016A      MOVW	R12,R20
    00560 94D6      LSR	R13
    00561 94C7      ROR	R12
    00562 94D6      LSR	R13
    00563 94C7      ROR	R12
    00564 94D6      LSR	R13
    00565 94C7      ROR	R12
(0111) 	if(n) n=(unsigned long)PAGE_SIZE*(n+1)-ad_dst;
    00566 20CC      TST	R12
    00567 F411      BNE	0x056A
    00568 20DD      TST	R13
    00569 F0A9      BEQ	0x057F
    0056A E083      LDI	R24,3
    0056B E090      LDI	R25,0
    0056C 0186      MOVW	R16,R12
    0056D 5F0F      SUBI	R16,0xFF
    0056E 4F1F      SBCI	R17,0xFF
    0056F 2722      CLR	R18
    00570 2733      CLR	R19
    00571 938A      ST	-Y,R24
    00572 940E 0D9A CALL	lsl32
    00574 0118      MOVW	R2,R16
    00575 0129      MOVW	R4,R18
    00576 013A      MOVW	R6,R20
    00577 2488      CLR	R8
    00578 2499      CLR	R9
    00579 1826      SUB	R2,R6
    0057A 0837      SBC	R3,R7
    0057B 0848      SBC	R4,R8
    0057C 0859      SBC	R5,R9
    0057D 0161      MOVW	R12,R2
    0057E C005      RJMP	0x0584
(0112) 	else n=PAGE_SIZE-ad_dst;
    0057F E088      LDI	R24,0x8
    00580 E090      LDI	R25,0
    00581 016C      MOVW	R12,R24
    00582 1AC4      SUB	R12,R20
    00583 0AD5      SBC	R13,R21
(0113) 	
(0114)     if(n>=num)		//如果ad_dst所在的数据块的末尾地址 >= ad_dst + num, 就直接写入num个数据
    00584 16C6      CP	R12,R22
    00585 06D7      CPC	R13,R23
    00586 F048      BCS	0x0590
(0115)     {
(0116) 	 	wt24c_fc(p_rsc, ad_dst, num);
    00587 8368      ST	Y,R22
    00588 019A      MOVW	R18,R20
    00589 0185      MOVW	R16,R10
    0058A DF61      RCALL	_wt24c_fc
(0117)     	if(syserr!=0) return;
    0058B 9020 0293 LDS	R2,syserr
    0058D 2022      TST	R2
    0058E F151      BEQ	0x05B9
    0058F C029      RJMP	0x05B9
(0118)     }
(0119)     else			//如果ad_dst所在的数据块末尾地址 < ad_dst + num, 就先写入ad_dst所在的数据块末尾地址与 ad_dst 之差个数据
(0120)     {
(0121) 	    p_rsc=wt24c_fc(p_rsc, ad_dst, n);
    00590 82C8      ST	Y,R12
    00591 019A      MOVW	R18,R20
    00592 0185      MOVW	R16,R10
    00593 DF58      RCALL	_wt24c_fc
    00594 0158      MOVW	R10,R16
(0122)     	if(syserr!=0) return;
    00595 9020 0293 LDS	R2,syserr
    00597 2022      TST	R2
    00598 F009      BEQ	0x059A
    00599 C01F      RJMP	0x05B9
(0123) 		
(0124) 		num-=n;     //更新剩下数据个数
    0059A 196C      SUB	R22,R12
    0059B 097D      SBC	R23,R13
(0125)         ad_dst+=n;	//更新剩下数据的起始地址
    0059C 0D4C      ADD	R20,R12
    0059D 1D5D      ADC	R21,R13
    0059E C00F      RJMP	0x05AE
(0126) 
(0127)         //把剩下数据写入器件
(0128)         while(num>=PAGE_SIZE)	//先按PAGE_SIZE为长度一页一页的写入
(0129)         {
(0130) 		 	p_rsc=wt24c_fc(p_rsc, ad_dst, PAGE_SIZE);
    0059F E088      LDI	R24,0x8
    005A0 8388      ST	Y,R24
    005A1 019A      MOVW	R18,R20
    005A2 0185      MOVW	R16,R10
    005A3 DF48      RCALL	_wt24c_fc
    005A4 0158      MOVW	R10,R16
(0131)         	if(syserr!=0) return;
    005A5 9020 0293 LDS	R2,syserr
    005A7 2022      TST	R2
    005A8 F009      BEQ	0x05AA
    005A9 C00F      RJMP	0x05B9
(0132)         	
(0133)             num-=PAGE_SIZE;		//更新剩余数据个数
    005AA 5068      SUBI	R22,0x8
    005AB 4070      SBCI	R23,0
(0134)         	ad_dst+=PAGE_SIZE;	//更新剩下数据的起始地址
    005AC 5F48      SUBI	R20,0xF8
    005AD 4F5F      SBCI	R21,0xFF
    005AE 3068      CPI	R22,0x8
    005AF E0E0      LDI	R30,0
    005B0 077E      CPC	R23,R30
    005B1 F768      BCC	0x059F
(0135) 		}
(0136)         
(0137) 		if(num)			//把最后剩下的小于一个PAGE_SIZE长度的数据写入器件
    005B2 3060      CPI	R22,0
    005B3 0767      CPC	R22,R23
    005B4 F021      BEQ	0x05B9
(0138) 			wt24c_fc(p_rsc, ad_dst, num);
    005B5 8368      ST	Y,R22
    005B6 019A      MOVW	R18,R20
    005B7 0185      MOVW	R16,R10
    005B8 DF33      RCALL	_wt24c_fc
(0139)     }
    005B9 9621      ADIW	R28,1
    005BA 940C 0D88 JMP	pop_xgsetF03C
_rd24c:
  t                    --> R10
  num                  --> R22
  ad_rsc               --> R12
  p_dst                --> R20
    005BC 940E 0D7F CALL	push_xgsetF03C
    005BE 0169      MOVW	R12,R18
    005BF 01A8      MOVW	R20,R16
    005C0 8568      LDD	R22,Y+8
    005C1 8579      LDD	R23,Y+9
(0140) }
(0141) /*************************************************************************
(0142) ** 函数名称: 
(0143) ** 功能描述: 从24cxx读出数据
(0144) ** 输　入: *p_dst要读入数据的主机内存地址指针; ad_rsc要输出数据的i2c的地址(整形); num数据个数(整形)
(0145) ** 输出	 : 
(0146) ** 全局变量: 无
(0147) ** 调用模块: 
(0148) ** 说明：ad_dst+(num-1)不能大于器件的最高地址; num必须>0;
(0149) ** 注意：
(0150) **************************************************************************/
(0151) void rd24c(unsigned char *p_dst, unsigned int ad_rsc, unsigned int num)
(0152) {
(0153) 
(0154) 
(0155)  	 
(0156)     unsigned char t=0;
(0157) 
(0158) 	#if e2prom<32
(0159) 	t=ad_rsc>>8;
    005C2 0156      MOVW	R10,R12
    005C3 2CAB      MOV	R10,R11
    005C4 24BB      CLR	R11
(0160) 	t<<=1;
    005C5 0CAA      LSL	R10
(0161) 	#endif
(0162) 	
(0163) 	i2cstart();					//发送起始信号
    005C6 940E 0B1B CALL	_i2cstart
(0164) 		
(0165) 	if(i2cwt(W_ADD_COM+t)==SLAW)//发送SLA_W, 写字节命令及器件地址
    005C8 2D0A      MOV	R16,R10
    005C9 5600      SUBI	R16,0x60
    005CA 940E 0B23 CALL	_i2cwt
    005CC 3108      CPI	R16,0x18
    005CD F4B1      BNE	0x05E4
(0166) 	{	
(0167) 		#if e2prom>16
(0168) 		i2cwt(ad_rsc>>8);		//ad_rsc的高位,  发送要读出数据的地址
(0169) 		#endif
(0170) 		i2cwt(ad_rsc);			//ad_rsc的低位
    005CE 2D0C      MOV	R16,R12
    005CF 940E 0B23 CALL	_i2cwt
(0171) 				
(0172) 		i2cstart();				//再发送起始信号
    005D1 940E 0B1B CALL	_i2cstart
(0173) 		i2cwt(R_ADD_COM+t);		//发送SLA_R, 读命令字节及器件地址
    005D3 2D0A      MOV	R16,R10
    005D4 550F      SUBI	R16,0x5F
    005D5 940E 0B23 CALL	_i2cwt
(0174) 				
(0175) 		for(;num>0;num--)
    005D7 C008      RJMP	0x05E0
(0176) 		{
(0177) 		    *p_dst=i2crd();		//从器件读出一个字节
    005D8 940E 0B31 CALL	_i2crd
    005DA 01FA      MOVW	R30,R20
    005DB 8300      ST	Z,R16
(0178) 			p_dst++;
    005DC 5F4F      SUBI	R20,0xFF
    005DD 4F5F      SBCI	R21,0xFF
    005DE 5061      SUBI	R22,1
    005DF 4070      SBCI	R23,0
    005E0 3060      CPI	R22,0
    005E1 0767      CPC	R22,R23
    005E2 F7A9      BNE	0x05D8
(0179) 		}
(0180) 	}
    005E3 C003      RJMP	0x05E7
(0181) 	else syserr=ERR_SLAW;		//写字节命令及器件地址错或对方无应答
    005E4 E081      LDI	R24,1
    005E5 9380 0293 STS	syserr,R24
(0182) 		
(0183) 	i2cstop();
    005E7 940E 0B3B CALL	_i2cstop
    005E9 940C 0D88 JMP	pop_xgsetF03C
_rd24c_pcf:
  t                    --> R10
  num                  --> R22
  ad_rsc               --> R12
  p_dst                --> R20
    005EB 940E 0D7F CALL	push_xgsetF03C
    005ED 0169      MOVW	R12,R18
    005EE 01A8      MOVW	R20,R16
    005EF 8568      LDD	R22,Y+8
    005F0 8579      LDD	R23,Y+9
(0184) 
(0185) }
(0186) 
(0187) 
(0188) 
(0189) 
(0190) 
(0191) 
(0192) 
(0193) void rd24c_pcf(unsigned char *p_dst, unsigned int ad_rsc, unsigned int num)
(0194) {
(0195) 
(0196)     unsigned char t=0;
(0197) 	#if e2prom<32
(0198) 	t=ad_rsc>>8;
    005F1 0156      MOVW	R10,R12
    005F2 2CAB      MOV	R10,R11
    005F3 24BB      CLR	R11
(0199) 	t<<=1;
    005F4 0CAA      LSL	R10
(0200) 	#endif
(0201) 	
(0202) 	i2cstart();					//发送起始信号
    005F5 940E 0B1B CALL	_i2cstart
(0203) 		
(0204) 	if(i2cwt(W_ADD_COM_PCF+t)==SLAW)//发送SLA_W, 写字节命令及器件地址
    005F7 2D0A      MOV	R16,R10
    005F8 550E      SUBI	R16,0x5E
    005F9 940E 0B23 CALL	_i2cwt
    005FB 3108      CPI	R16,0x18
    005FC F4B1      BNE	0x0613
(0205) 	{	
(0206) 		#if e2prom>16
(0207) 		i2cwt(ad_rsc>>8);		//ad_rsc的高位,  发送要读出数据的地址
(0208) 		#endif
(0209) 		i2cwt(ad_rsc);			//ad_rsc的低位
    005FD 2D0C      MOV	R16,R12
    005FE 940E 0B23 CALL	_i2cwt
(0210) 				
(0211) 		i2cstart();				//再发送起始信号
    00600 940E 0B1B CALL	_i2cstart
(0212) 		i2cwt(R_ADD_COM_PCF+t);		//发送SLA_R, 读命令字节及器件地址
    00602 2D0A      MOV	R16,R10
    00603 550D      SUBI	R16,0x5D
    00604 940E 0B23 CALL	_i2cwt
(0213) 				
(0214) 		for(;num>0;num--)
    00606 C008      RJMP	0x060F
(0215) 		{
(0216) 		    *p_dst=i2crd();		//从器件读出一个字节
    00607 940E 0B31 CALL	_i2crd
    00609 01FA      MOVW	R30,R20
    0060A 8300      ST	Z,R16
(0217) 			p_dst++;
    0060B 5F4F      SUBI	R20,0xFF
    0060C 4F5F      SBCI	R21,0xFF
    0060D 5061      SUBI	R22,1
    0060E 4070      SBCI	R23,0
    0060F 3060      CPI	R22,0
    00610 0767      CPC	R22,R23
    00611 F7A9      BNE	0x0607
(0218) 		}
(0219) 	}
    00612 C003      RJMP	0x0616
(0220) 	else syserr=ERR_SLAW;		//写字节命令及器件地址错或对方无应答
    00613 E081      LDI	R24,1
    00614 9380 0293 STS	syserr,R24
(0221) 		
(0222) 	i2cstop();
    00616 940E 0B3B CALL	_i2cstop
    00618 940C 0D88 JMP	pop_xgsetF03C
_pcf_stop:
  stopcode             --> Y,+1
    0061A 9722      SBIW	R28,2
(0223) 
(0224) }
(0225) 
(0226) 
(0227) 
(0228) void pcf_stop(void)
(0229) {
(0230)  unsigned char stopcode=0x20;
    0061B E280      LDI	R24,0x20
    0061C 8389      STD	Y+1,R24
(0231)  wt24c_fc_pcf(&stopcode,0,1);
    0061D E081      LDI	R24,1
    0061E 8388      ST	Y,R24
    0061F 2722      CLR	R18
    00620 2733      CLR	R19
    00621 018E      MOVW	R16,R28
    00622 5F0F      SUBI	R16,0xFF
    00623 4F1F      SBCI	R17,0xFF
    00624 DF07      RCALL	_wt24c_fc_pcf
    00625 9622      ADIW	R28,2
    00626 9508      RET
_pcf_start:
  startcode            --> Y,+1
    00627 9722      SBIW	R28,2
(0232) }
(0233) void pcf_start(void)
(0234) {
(0235)  unsigned char startcode=0x00;
    00628 2422      CLR	R2
    00629 8229      STD	Y+1,R2
(0236)   wt24c_fc_pcf(&startcode,0,1);
    0062A E081      LDI	R24,1
    0062B 8388      ST	Y,R24
    0062C 2722      CLR	R18
    0062D 2733      CLR	R19
    0062E 018E      MOVW	R16,R28
    0062F 5F0F      SUBI	R16,0xFF
    00630 4F1F      SBCI	R17,0xFF
    00631 DEFA      RCALL	_wt24c_fc_pcf
    00632 9622      ADIW	R28,2
    00633 9508      RET
_pcfset:
  n                    --> R14
  ad                   --> R12
  p                    --> R10
    00634 940E 0D56 CALL	push_xgset00FC
    00636 0169      MOVW	R12,R18
    00637 0158      MOVW	R10,R16
    00638 9721      SBIW	R28,1
    00639 80EF      LDD	R14,Y+7
(0237) }
(0238) 
(0239) unsigned char * pcfset(unsigned char *p, unsigned int ad, unsigned char n){
(0240) 		 pcf_stop();
    0063A DFDF      RCALL	_pcf_stop
(0241) 		 wt24c_fc_pcf(p,ad,n);
    0063B 82E8      ST	Y,R14
    0063C 0196      MOVW	R18,R12
    0063D 0185      MOVW	R16,R10
    0063E DEED      RCALL	_wt24c_fc_pcf
(0242) 		 pcf_start();
    0063F DFE7      RCALL	_pcf_start
(0243) 		 return(p);		 
    00640 0185      MOVW	R16,R10
    00641 9621      ADIW	R28,1
    00642 940C 0D37 JMP	pop_xgset00FC
_pcfread:
  num                  --> R14
  ad_rsc               --> R12
  p_dst                --> R10
    00644 940E 0D56 CALL	push_xgset00FC
    00646 0169      MOVW	R12,R18
    00647 0158      MOVW	R10,R16
    00648 9722      SBIW	R28,2
    00649 84E8      LDD	R14,Y+8
    0064A 84F9      LDD	R15,Y+9
(0244) }
(0245) 
(0246) void pcfread(unsigned char *p_dst, unsigned int ad_rsc, unsigned int num){	 
(0247) 	 rd24c_pcf(p_dst,ad_rsc,num);
    0064B 82F9      STD	Y+1,R15
    0064C 82E8      ST	Y,R14
    0064D 0196      MOVW	R18,R12
    0064E 0185      MOVW	R16,R10
    0064F DF9B      RCALL	_rd24c_pcf
    00650 9622      ADIW	R28,2
    00651 940C 0D37 JMP	pop_xgset00FC
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\buzz.c
(0001) /************************************************
(0002) 文件：buzz.c
(0003) 用途：
(0004) 注意：内部8M晶振
(0005) 创建：2008.4.1
(0006) 修改：2008.4.1
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) /*************************************************************************
(0011) ** 函数名称:蜂鸣器初始化
(0012) ** 功能描述:
(0013) ** 输　入:
(0014) ** 输出	 :
(0015) ** 全局变量:
(0016) ** 调用模块:
(0017) ** 说明：
(0018) ** 注意：
(0019) **************************************************************************/
(0020) void Buzz_init(void)
(0021) {
(0022)  BUZZ_DDR |= (1<<SPK);
_Buzz_init:
    00653 9180 0064 LDS	R24,0x64
    00655 6180      ORI	R24,0x10
    00656 9380 0064 STS	0x64,R24
(0023)  BUZZ_PORT &=~ (1<<SPK);
    00658 9180 0065 LDS	R24,0x65
    0065A 7E8F      ANDI	R24,0xEF
    0065B 9380 0065 STS	0x65,R24
    0065D 9508      RET
_Beep:
  L_time               --> R10
  H_time               --> R12
    0065E 940E 0D58 CALL	push_xgset003C
    00660 0159      MOVW	R10,R18
    00661 0168      MOVW	R12,R16
(0024) }
(0025) /*************************************************************************
(0026) ** 函数名称:蜂鸣
(0027) ** 功能描述:
(0028) ** 输　入: H_time: 响的时间 L_time: 不响的时间
(0029) ** 输出	 :
(0030) ** 全局变量:
(0031) ** 调用模块:
(0032) ** 说明：
(0033) ** 注意：
(0034) **************************************************************************/
(0035) void Beep(unsigned int H_time,unsigned int L_time)
(0036) {
(0037)  BUZZ_PORT |= (1<<SPK);
    00662 9180 0065 LDS	R24,0x65
    00664 6180      ORI	R24,0x10
    00665 9380 0065 STS	0x65,R24
(0038)  delay_nms(H_time);
    00667 0186      MOVW	R16,R12
    00668 940E 068E CALL	_delay_nms
(0039)  BUZZ_PORT &=~ (1<<SPK);
    0066A 9180 0065 LDS	R24,0x65
    0066C 7E8F      ANDI	R24,0xEF
    0066D 9380 0065 STS	0x65,R24
(0040)  delay_nms(L_time);
    0066F 0185      MOVW	R16,R10
    00670 940E 068E CALL	_delay_nms
    00672 940C 0D32 JMP	pop_xgset003C
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\delay.c
(0001) /************************************************
(0002) 文件：delay.c
(0003) 用途：延时函数
(0004) 注意：系统时钟8M
(0005) 创建：2008.1.25
(0006) 修改：2008.1.25
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include <iom128v.h>
(0010) void delay_1us(void)                 //1us延时函数
(0011)   {
(0012)    asm("nop");
_delay_1us:
    00674 0000      NOP
    00675 9508      RET
_delay_nus:
  i                    --> R20
  n                    --> R10
    00676 940E 0D5D CALL	push_xgset300C
    00678 0158      MOVW	R10,R16
(0013)   }
(0014) 
(0015) void delay_nus(unsigned int n)       //N us延时函数
(0016)   {
(0017)    unsigned int i=0;
(0018)    for (i=0;i<n;i++)
    00679 2744      CLR	R20
    0067A 2755      CLR	R21
    0067B C003      RJMP	0x067F
(0019)    delay_1us();
    0067C DFF7      RCALL	_delay_1us
    0067D 5F4F      SUBI	R20,0xFF
    0067E 4F5F      SBCI	R21,0xFF
    0067F 154A      CP	R20,R10
    00680 055B      CPC	R21,R11
    00681 F3D0      BCS	0x067C
    00682 940C 0D62 JMP	pop_xgset300C
(0020)   }
(0021)   
(0022) void delay_1ms(void)                 //1ms延时函数
(0023)   {
(0024)    unsigned int i;
(0025)    for (i=0;i<1140;i++);
_delay_1ms:
  i                    --> R16
    00684 2700      CLR	R16
    00685 2711      CLR	R17
    00686 C002      RJMP	0x0689
    00687 5F0F      SUBI	R16,0xFF
    00688 4F1F      SBCI	R17,0xFF
    00689 3704      CPI	R16,0x74
    0068A E0E4      LDI	R30,4
    0068B 071E      CPC	R17,R30
    0068C F3D0      BCS	0x0687
    0068D 9508      RET
_delay_nms:
  i                    --> R20
  n                    --> R10
    0068E 940E 0D5D CALL	push_xgset300C
    00690 0158      MOVW	R10,R16
(0026)   }
(0027)   
(0028) void delay_nms(unsigned int n)       //N ms延时函数
(0029)   {
(0030)    unsigned int i=0;
(0031)    for (i=0;i<n;i++)
    00691 2744      CLR	R20
    00692 2755      CLR	R21
    00693 C003      RJMP	0x0697
(0032)    delay_1ms();
    00694 DFEF      RCALL	_delay_1ms
    00695 5F4F      SUBI	R20,0xFF
    00696 4F5F      SBCI	R21,0xFF
    00697 154A      CP	R20,R10
    00698 055B      CPC	R21,R11
    00699 F3D0      BCS	0x0694
    0069A 940C 0D62 JMP	pop_xgset300C
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\hc595.c
(0001) /************************************************
(0002) 文件：hc595.c
(0003) 用途：
(0004) 注意：内部8M晶振
(0005) 创建：2008.4.1
(0006) 修改：2008.4.1
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) const unsigned char Seg7_Data[]={0x3F,0x06,0x5B,0x4F,0x66,             //0,1,2,3,4
(0011)                                  0x6D,0x7D,0x07,0x7F,0x6F,             //5,6,7,8,9
(0012) 						         0x77,0x7C,0x39,0x5E,0x79,0x71,0x00};  //a,b,c,d,e,f
(0013) volatile unsigned char Seg7_Led_Buf[4],point=0,point_pos=0;//point是小数点标志1代表有小数点point_pos表示小数点位置
(0014) /*************************************************************************
(0015) ** 函数名称:HC595初始化
(0016) ** 功能描述:
(0017) ** 输　入:
(0018) ** 输出	 :
(0019) ** 全局变量:
(0020) ** 调用模块:
(0021) ** 说明：
(0022) ** 注意：
(0023) **************************************************************************/
(0024) void HC_595_init(void)
(0025) {
(0026)  OE_DDR |= (1<<OE);
_HC_595_init:
    0069C 9AA7      SBI	0x14,7
(0027)  OE_PORT &= (1<<OE);
    0069D B385      IN	R24,0x15
    0069E 7880      ANDI	R24,0x80
    0069F BB85      OUT	0x15,R24
(0028)  PORTB = 0x0F;
    006A0 E08F      LDI	R24,0xF
    006A1 BB88      OUT	0x18,R24
(0029)  spi_init();
    006A2 940E 0B3F CALL	_spi_init
(0030)  Seg7_Led_Buf[0]=16;
    006A4 E180      LDI	R24,0x10
    006A5 9380 0294 STS	Seg7_Led_Buf,R24
(0031)  Seg7_Led_Buf[1]=16;
    006A7 9380 0295 STS	Seg7_Led_Buf+1,R24
(0032)  Seg7_Led_Buf[2]=16;
    006A9 9380 0296 STS	Seg7_Led_Buf+2,R24
(0033)  Seg7_Led_Buf[3]=16;
    006AB 9380 0297 STS	Seg7_Led_Buf+3,R24
    006AD 9508      RET
_HC_595_OUT:
  data                 --> R10
    006AE 92AA      ST	-Y,R10
    006AF 2EA0      MOV	R10,R16
(0034) }
(0035) /*************************************************************************
(0036) ** 函数名称:HC595送数据
(0037) ** 功能描述:
(0038) ** 输　入:
(0039) ** 输出	 :
(0040) ** 全局变量:
(0041) ** 调用模块: 
(0042) ** 说明：
(0043) ** 注意：
(0044) **************************************************************************/
(0045) void HC_595_OUT(unsigned char data)
(0046) {
(0047)  	 SS_L();
    006B0 98C0      CBI	0x18,0
(0048) 	 SPI_MasterTransmit(data);
    006B1 2D0A      MOV	R16,R10
    006B2 940E 0B45 CALL	_SPI_MasterTransmit
(0049)  	 SS_H();
    006B4 9AC0      SBI	0x18,0
    006B5 90A9      LD	R10,Y+
    006B6 9508      RET
(0050) }
(0051) /*************************************************************************
(0052) ** 函数名称:HC595刷新显示
(0053) ** 功能描述:
(0054) ** 输　入:
(0055) ** 输出	 :
(0056) ** 全局变量:
(0057) ** 调用模块: 
(0058) ** 说明：
(0059) ** 注意：
(0060) **************************************************************************/
(0061) void Seg7_Led_Update(void)
(0062) {
(0063)  HC_595_OUT(Seg7_Data[Seg7_Led_Buf[0]]); 
_Seg7_Led_Update:
    006B7 E287      LDI	R24,0x27
    006B8 E092      LDI	R25,2
    006B9 91E0 0294 LDS	R30,Seg7_Led_Buf
    006BB 27FF      CLR	R31
    006BC 0FE8      ADD	R30,R24
    006BD 1FF9      ADC	R31,R25
    006BE 8100      LD	R16,Z
    006BF DFEE      RCALL	_HC_595_OUT
(0064)  Seg7_Bit0_En(); 
    006C0 9ABC      SBI	0x17,4
    006C1 9AC4      SBI	0x18,4
(0065)  delay_nus(60); 
    006C2 E30C      LDI	R16,0x3C
    006C3 E010      LDI	R17,0
    006C4 940E 0676 CALL	_delay_nus
(0066)  Seg7_Bit0_Dis();
    006C6 9ABC      SBI	0x17,4
    006C7 98C4      CBI	0x18,4
(0067)  
(0068)  HC_595_OUT(Seg7_Data[Seg7_Led_Buf[1]]);
    006C8 E287      LDI	R24,0x27
    006C9 E092      LDI	R25,2
    006CA 91E0 0295 LDS	R30,Seg7_Led_Buf+1
    006CC 27FF      CLR	R31
    006CD 0FE8      ADD	R30,R24
    006CE 1FF9      ADC	R31,R25
    006CF 8100      LD	R16,Z
    006D0 DFDD      RCALL	_HC_595_OUT
(0069)  if((point==1)&&(point_pos==1))
    006D1 9180 0238 LDS	R24,point
    006D3 3081      CPI	R24,1
    006D4 F471      BNE	0x06E3
    006D5 9180 0239 LDS	R24,point_pos
    006D7 3081      CPI	R24,1
    006D8 F451      BNE	0x06E3
(0070)  HC_595_OUT((Seg7_Data[Seg7_Led_Buf[1]])|(1<<dp));
    006D9 E287      LDI	R24,0x27
    006DA E092      LDI	R25,2
    006DB 91E0 0295 LDS	R30,Seg7_Led_Buf+1
    006DD 27FF      CLR	R31
    006DE 0FE8      ADD	R30,R24
    006DF 1FF9      ADC	R31,R25
    006E0 8100      LD	R16,Z
    006E1 6800      ORI	R16,0x80
    006E2 DFCB      RCALL	_HC_595_OUT
(0071)  Seg7_Bit1_En();
    006E3 9ABD      SBI	0x17,5
    006E4 9AC5      SBI	0x18,5
(0072)  delay_nus(60);
    006E5 E30C      LDI	R16,0x3C
    006E6 E010      LDI	R17,0
    006E7 940E 0676 CALL	_delay_nus
(0073)  Seg7_Bit1_Dis();
    006E9 9ABD      SBI	0x17,5
    006EA 98C5      CBI	0x18,5
(0074)  
(0075)  HC_595_OUT(Seg7_Data[Seg7_Led_Buf[2]]); 
    006EB E287      LDI	R24,0x27
    006EC E092      LDI	R25,2
    006ED 91E0 0296 LDS	R30,Seg7_Led_Buf+2
    006EF 27FF      CLR	R31
    006F0 0FE8      ADD	R30,R24
    006F1 1FF9      ADC	R31,R25
    006F2 8100      LD	R16,Z
    006F3 DFBA      RCALL	_HC_595_OUT
(0076)  if((point==1)&&(point_pos==2))
    006F4 9180 0238 LDS	R24,point
    006F6 3081      CPI	R24,1
    006F7 F471      BNE	0x0706
    006F8 9180 0239 LDS	R24,point_pos
    006FA 3082      CPI	R24,2
    006FB F451      BNE	0x0706
(0077)  HC_595_OUT((Seg7_Data[Seg7_Led_Buf[2]])|(1<<dp));
    006FC E287      LDI	R24,0x27
    006FD E092      LDI	R25,2
    006FE 91E0 0296 LDS	R30,Seg7_Led_Buf+2
    00700 27FF      CLR	R31
    00701 0FE8      ADD	R30,R24
    00702 1FF9      ADC	R31,R25
    00703 8100      LD	R16,Z
    00704 6800      ORI	R16,0x80
    00705 DFA8      RCALL	_HC_595_OUT
(0078)  Seg7_Bit2_En();
    00706 9ABE      SBI	0x17,6
    00707 9AC6      SBI	0x18,6
(0079)  delay_nus(60);
    00708 E30C      LDI	R16,0x3C
    00709 E010      LDI	R17,0
    0070A 940E 0676 CALL	_delay_nus
(0080)  Seg7_Bit2_Dis();
    0070C 9ABE      SBI	0x17,6
    0070D 98C6      CBI	0x18,6
(0081)  
(0082)  HC_595_OUT(Seg7_Data[Seg7_Led_Buf[3]]);
    0070E E287      LDI	R24,0x27
    0070F E092      LDI	R25,2
    00710 91E0 0297 LDS	R30,Seg7_Led_Buf+3
    00712 27FF      CLR	R31
    00713 0FE8      ADD	R30,R24
    00714 1FF9      ADC	R31,R25
    00715 8100      LD	R16,Z
    00716 DF97      RCALL	_HC_595_OUT
(0083)  if((point==1)&&(point_pos==3))
    00717 9180 0238 LDS	R24,point
    00719 3081      CPI	R24,1
    0071A F471      BNE	0x0729
    0071B 9180 0239 LDS	R24,point_pos
    0071D 3083      CPI	R24,3
    0071E F451      BNE	0x0729
(0084)  HC_595_OUT((Seg7_Data[Seg7_Led_Buf[3]])|(1<<dp));
    0071F E287      LDI	R24,0x27
    00720 E092      LDI	R25,2
    00721 91E0 0297 LDS	R30,Seg7_Led_Buf+3
    00723 27FF      CLR	R31
    00724 0FE8      ADD	R30,R24
    00725 1FF9      ADC	R31,R25
    00726 8100      LD	R16,Z
    00727 6800      ORI	R16,0x80
    00728 DF85      RCALL	_HC_595_OUT
(0085)  Seg7_Bit3_En();
    00729 9ABF      SBI	0x17,7
    0072A 9AC7      SBI	0x18,7
(0086)  delay_nus(60);
    0072B E30C      LDI	R16,0x3C
    0072C E010      LDI	R17,0
    0072D 940E 0676 CALL	_delay_nus
(0087)  Seg7_Bit3_Dis();
    0072F 9ABF      SBI	0x17,7
    00730 98C7      CBI	0x18,7
    00731 9508      RET
_Seg7_Led_display:
  data                 --> R10
    00732 92AA      ST	-Y,R10
    00733 92BA      ST	-Y,R11
    00734 0158      MOVW	R10,R16
(0088) }
(0089) /*************************************************************************
(0090) ** 函数名称:Hc595显示整形数据
(0091) ** 功能描述:
(0092) ** 输　入:0~9999
(0093) ** 输出	 :
(0094) ** 全局变量:
(0095) ** 调用模块: 
(0096) ** 说明：
(0097) ** 注意：
(0098) **************************************************************************/
(0099) void Seg7_Led_display(unsigned int data)
(0100) {
(0101) if(data==0){
    00735 20AA      TST	R10
    00736 F461      BNE	0x0743
    00737 20BB      TST	R11
    00738 F451      BNE	0x0743
(0102)       Seg7_Led_Buf[3]=0;
    00739 2422      CLR	R2
    0073A 9220 0297 STS	Seg7_Led_Buf+3,R2
(0103)  	 Seg7_Led_Buf[2]=0;
    0073C 9220 0296 STS	Seg7_Led_Buf+2,R2
(0104)  	 Seg7_Led_Buf[1]=0;
    0073E 9220 0295 STS	Seg7_Led_Buf+1,R2
(0105)  	 Seg7_Led_Buf[0]=0;
    00740 9220 0294 STS	Seg7_Led_Buf,R2
(0106) 	 Seg7_Led_Update();
    00742 DF74      RCALL	_Seg7_Led_Update
(0107) }
(0108)  if(data>9999) //错误处理,超出显示范围则全亮
    00743 E08F      LDI	R24,0xF
    00744 E297      LDI	R25,0x27
    00745 158A      CP	R24,R10
    00746 059B      CPC	R25,R11
    00747 F430      BCC	0x074E
(0109)  	{
(0110) 	 HC_595_OUT(0xFF);
    00748 EF0F      LDI	R16,0xFF
    00749 DF64      RCALL	_HC_595_OUT
(0111) 	 Seg7_Bitselect_PORT|=((1<<Seg7_Bit0)|(1<<Seg7_Bit1)|(1<<Seg7_Bit2)|(1<<Seg7_Bit3));
    0074A B388      IN	R24,0x18
    0074B 6F80      ORI	R24,0xF0
    0074C BB88      OUT	0x18,R24
(0112) 	}
    0074D C07F      RJMP	0x07CD
(0113)  else if(data>999)
    0074E EE87      LDI	R24,0xE7
    0074F E093      LDI	R25,3
    00750 158A      CP	R24,R10
    00751 059B      CPC	R25,R11
    00752 F530      BCC	0x0779
(0114)  	{
(0115) 	 Seg7_Led_Buf[3]=data/1000;
    00753 EE28      LDI	R18,0xE8
    00754 E033      LDI	R19,3
    00755 0185      MOVW	R16,R10
    00756 940E 0C72 CALL	div16u
    00758 9300 0297 STS	Seg7_Led_Buf+3,R16
(0116)  	 Seg7_Led_Buf[2]=(data%1000)/100;
    0075A EE28      LDI	R18,0xE8
    0075B E033      LDI	R19,3
    0075C 0185      MOVW	R16,R10
    0075D 940E 0C70 CALL	mod16u
    0075F E624      LDI	R18,0x64
    00760 E030      LDI	R19,0
    00761 940E 0C72 CALL	div16u
    00763 9300 0296 STS	Seg7_Led_Buf+2,R16
(0117)  	 Seg7_Led_Buf[1]=(data%100)/10;
    00765 E624      LDI	R18,0x64
    00766 E030      LDI	R19,0
    00767 0185      MOVW	R16,R10
    00768 940E 0C70 CALL	mod16u
    0076A E02A      LDI	R18,0xA
    0076B E030      LDI	R19,0
    0076C 940E 0C72 CALL	div16u
    0076E 9300 0295 STS	Seg7_Led_Buf+1,R16
(0118)  	 Seg7_Led_Buf[0]=data%10;
    00770 E02A      LDI	R18,0xA
    00771 E030      LDI	R19,0
    00772 0185      MOVW	R16,R10
    00773 940E 0C70 CALL	mod16u
    00775 9300 0294 STS	Seg7_Led_Buf,R16
(0119) 	 Seg7_Led_Update();
    00777 DF3F      RCALL	_Seg7_Led_Update
(0120) 	}
    00778 C054      RJMP	0x07CD
(0121)  else if(data>99)
    00779 E683      LDI	R24,0x63
    0077A E090      LDI	R25,0
    0077B 158A      CP	R24,R10
    0077C 059B      CPC	R25,R11
    0077D F510      BCC	0x07A0
(0122)  	{
(0123) 	 Seg7_Led_Buf[3]=0;
    0077E 2422      CLR	R2
    0077F 9220 0297 STS	Seg7_Led_Buf+3,R2
(0124)  	 Seg7_Led_Buf[2]=(data%1000)/100;
    00781 EE28      LDI	R18,0xE8
    00782 E033      LDI	R19,3
    00783 0185      MOVW	R16,R10
    00784 940E 0C70 CALL	mod16u
    00786 E624      LDI	R18,0x64
    00787 E030      LDI	R19,0
    00788 940E 0C72 CALL	div16u
    0078A 9300 0296 STS	Seg7_Led_Buf+2,R16
(0125)  	 Seg7_Led_Buf[1]=(data%100)/10;
    0078C E624      LDI	R18,0x64
    0078D E030      LDI	R19,0
    0078E 0185      MOVW	R16,R10
    0078F 940E 0C70 CALL	mod16u
    00791 E02A      LDI	R18,0xA
    00792 E030      LDI	R19,0
    00793 940E 0C72 CALL	div16u
    00795 9300 0295 STS	Seg7_Led_Buf+1,R16
(0126)  	 Seg7_Led_Buf[0]=data%10;
    00797 E02A      LDI	R18,0xA
    00798 E030      LDI	R19,0
    00799 0185      MOVW	R16,R10
    0079A 940E 0C70 CALL	mod16u
    0079C 9300 0294 STS	Seg7_Led_Buf,R16
(0127) 	 Seg7_Led_Update();
    0079E DF18      RCALL	_Seg7_Led_Update
(0128) 	}
    0079F C02D      RJMP	0x07CD
(0129)  else if(data>9)
    007A0 E089      LDI	R24,0x9
    007A1 E090      LDI	R25,0
    007A2 158A      CP	R24,R10
    007A3 059B      CPC	R25,R11
    007A4 F4C8      BCC	0x07BE
(0130)  	{
(0131) 	 Seg7_Led_Buf[3]=0;
    007A5 2422      CLR	R2
    007A6 9220 0297 STS	Seg7_Led_Buf+3,R2
(0132)  	 Seg7_Led_Buf[2]=0;
    007A8 9220 0296 STS	Seg7_Led_Buf+2,R2
(0133)  	 Seg7_Led_Buf[1]=(data%100)/10;
    007AA E624      LDI	R18,0x64
    007AB E030      LDI	R19,0
    007AC 0185      MOVW	R16,R10
    007AD 940E 0C70 CALL	mod16u
    007AF E02A      LDI	R18,0xA
    007B0 E030      LDI	R19,0
    007B1 940E 0C72 CALL	div16u
    007B3 9300 0295 STS	Seg7_Led_Buf+1,R16
(0134)  	 Seg7_Led_Buf[0]=data%10;
    007B5 E02A      LDI	R18,0xA
    007B6 E030      LDI	R19,0
    007B7 0185      MOVW	R16,R10
    007B8 940E 0C70 CALL	mod16u
    007BA 9300 0294 STS	Seg7_Led_Buf,R16
(0135) 	 Seg7_Led_Update();
    007BC DEFA      RCALL	_Seg7_Led_Update
(0136) 	}
    007BD C00F      RJMP	0x07CD
(0137)  else
(0138)  	{
(0139) 	 Seg7_Led_Buf[3]=0;
    007BE 2422      CLR	R2
    007BF 9220 0297 STS	Seg7_Led_Buf+3,R2
(0140)  	 Seg7_Led_Buf[2]=0;
    007C1 9220 0296 STS	Seg7_Led_Buf+2,R2
(0141)  	 Seg7_Led_Buf[1]=0;
    007C3 9220 0295 STS	Seg7_Led_Buf+1,R2
(0142)  	 Seg7_Led_Buf[0]=data%10;
    007C5 E02A      LDI	R18,0xA
    007C6 E030      LDI	R19,0
    007C7 0185      MOVW	R16,R10
    007C8 940E 0C70 CALL	mod16u
    007CA 9300 0294 STS	Seg7_Led_Buf,R16
(0143) 	 Seg7_Led_Update();
    007CC DEEA      RCALL	_Seg7_Led_Update
(0144) 	}
    007CD 90B9      LD	R11,Y+
    007CE 90A9      LD	R10,Y+
    007CF 9508      RET
_Seg7_Led_float:
  temp                 --> R10
  data                 --> Y,+2
    007D0 940E 0C6B CALL	push_arg4
    007D2 92AA      ST	-Y,R10
    007D3 92BA      ST	-Y,R11
(0145) }
(0146) /*************************************************************************
(0147) ** 函数名称:HC595显示浮点数据
(0148) ** 功能描述:
(0149) ** 输　入:
(0150) ** 输出	 :
(0151) ** 全局变量:
(0152) ** 调用模块: 
(0153) ** 说明：
(0154) ** 注意：
(0155) **************************************************************************/
(0156) void Seg7_Led_float(float data)
(0157) {
(0158)  unsigned int temp;
(0159)  /*
(0160)  重要说明:data+=0.00001;其中0.00001为容错值
(0161)  解决float数据类型在计算机内部存储的误差问题，可以解决显示问题
(0162)  但是会引入新的计算误差，如果精度要求大于0.00001建议更改容错值或者将此处注释掉 
(0163)  */
(0164)  data+=0.00001;
    007D4 802A      LDD	R2,Y+2
    007D5 803B      LDD	R3,Y+3
    007D6 804C      LDD	R4,Y+4
    007D7 805D      LDD	R5,Y+5
    007D8 EA04      LDI	R16,0xA4
    007D9 E010      LDI	R17,0
    007DA 940E 0D0E CALL	elpm32
    007DC 933A      ST	-Y,R19
    007DD 932A      ST	-Y,R18
    007DE 931A      ST	-Y,R17
    007DF 930A      ST	-Y,R16
    007E0 0181      MOVW	R16,R2
    007E1 0192      MOVW	R18,R4
    007E2 940E 0E16 CALL	fpadd2
    007E4 830A      STD	Y+2,R16
    007E5 831B      STD	Y+3,R17
    007E6 832C      STD	Y+4,R18
    007E7 833D      STD	Y+5,R19
(0165)  point=1;
    007E8 E081      LDI	R24,1
    007E9 9380 0238 STS	point,R24
(0166)  if(data>999) //错误处理,超出显示范围则全亮
    007EB 01CE      MOVW	R24,R28
    007EC 9602      ADIW	R24,2
    007ED 011C      MOVW	R2,R24
    007EE EA00      LDI	R16,0xA0
    007EF E010      LDI	R17,0
    007F0 940E 0D0E CALL	elpm32
    007F2 923A      ST	-Y,R3
    007F3 922A      ST	-Y,R2
    007F4 940E 0F49 CALL	fpcmp1
    007F6 F434      BGE	0x07FD
(0167)  	{
(0168) 	 HC_595_OUT(0xFF);
    007F7 EF0F      LDI	R16,0xFF
    007F8 DEB5      RCALL	_HC_595_OUT
(0169) 	 Seg7_Bitselect_PORT|=((1<<Seg7_Bit0)|(1<<Seg7_Bit1)|(1<<Seg7_Bit2)|(1<<Seg7_Bit3));
    007F9 B388      IN	R24,0x18
    007FA 6F80      ORI	R24,0xF0
    007FB BB88      OUT	0x18,R24
(0170) 	}
    007FC C0B6      RJMP	0x08B3
(0171)  else if(data>99)
    007FD 01CE      MOVW	R24,R28
    007FE 9602      ADIW	R24,2
    007FF 011C      MOVW	R2,R24
    00800 E90C      LDI	R16,0x9C
    00801 E010      LDI	R17,0
    00802 940E 0D0E CALL	elpm32
    00804 923A      ST	-Y,R3
    00805 922A      ST	-Y,R2
    00806 940E 0F49 CALL	fpcmp1
    00808 F5AC      BGE	0x083E
(0172)  	{
(0173) 	 temp=data*10;
    00809 E908      LDI	R16,0x98
    0080A E010      LDI	R17,0
    0080B 940E 0D0E CALL	elpm32
    0080D 01CE      MOVW	R24,R28
    0080E 9602      ADIW	R24,2
    0080F 939A      ST	-Y,R25
    00810 938A      ST	-Y,R24
    00811 940E 0F32 CALL	fpmule1
    00813 940E 0E21 CALL	fpint
    00815 0158      MOVW	R10,R16
(0174) 	 point_pos=1;
    00816 E081      LDI	R24,1
    00817 9380 0239 STS	point_pos,R24
(0175) 	 Seg7_Led_Buf[3]=temp/1000;
    00819 EE28      LDI	R18,0xE8
    0081A E033      LDI	R19,3
    0081B 940E 0C72 CALL	div16u
    0081D 9300 0297 STS	Seg7_Led_Buf+3,R16
(0176)  	 Seg7_Led_Buf[2]=(temp%1000)/100;
    0081F EE28      LDI	R18,0xE8
    00820 E033      LDI	R19,3
    00821 0185      MOVW	R16,R10
    00822 940E 0C70 CALL	mod16u
    00824 E624      LDI	R18,0x64
    00825 E030      LDI	R19,0
    00826 940E 0C72 CALL	div16u
    00828 9300 0296 STS	Seg7_Led_Buf+2,R16
(0177)  	 Seg7_Led_Buf[1]=(temp%100)/10;
    0082A E624      LDI	R18,0x64
    0082B E030      LDI	R19,0
    0082C 0185      MOVW	R16,R10
    0082D 940E 0C70 CALL	mod16u
    0082F E02A      LDI	R18,0xA
    00830 E030      LDI	R19,0
    00831 940E 0C72 CALL	div16u
    00833 9300 0295 STS	Seg7_Led_Buf+1,R16
(0178)  	 Seg7_Led_Buf[0]=temp%10;
    00835 E02A      LDI	R18,0xA
    00836 E030      LDI	R19,0
    00837 0185      MOVW	R16,R10
    00838 940E 0C70 CALL	mod16u
    0083A 9300 0294 STS	Seg7_Led_Buf,R16
(0179) 	 Seg7_Led_Update();
    0083C DE7A      RCALL	_Seg7_Led_Update
(0180) 	}
    0083D C075      RJMP	0x08B3
(0181)  else if(data>9)
    0083E 01CE      MOVW	R24,R28
    0083F 9602      ADIW	R24,2
    00840 011C      MOVW	R2,R24
    00841 E904      LDI	R16,0x94
    00842 E010      LDI	R17,0
    00843 940E 0D0E CALL	elpm32
    00845 923A      ST	-Y,R3
    00846 922A      ST	-Y,R2
    00847 940E 0F49 CALL	fpcmp1
    00849 F5AC      BGE	0x087F
(0182)  	{
(0183) 	 temp=data*100;
    0084A E900      LDI	R16,0x90
    0084B E010      LDI	R17,0
    0084C 940E 0D0E CALL	elpm32
    0084E 01CE      MOVW	R24,R28
    0084F 9602      ADIW	R24,2
    00850 939A      ST	-Y,R25
    00851 938A      ST	-Y,R24
    00852 940E 0F32 CALL	fpmule1
    00854 940E 0E21 CALL	fpint
    00856 0158      MOVW	R10,R16
(0184) 	 point_pos=2;
    00857 E082      LDI	R24,2
    00858 9380 0239 STS	point_pos,R24
(0185) 	 Seg7_Led_Buf[3]=temp/1000;
    0085A EE28      LDI	R18,0xE8
    0085B E033      LDI	R19,3
    0085C 940E 0C72 CALL	div16u
    0085E 9300 0297 STS	Seg7_Led_Buf+3,R16
(0186)  	 Seg7_Led_Buf[2]=(temp%1000)/100;
    00860 EE28      LDI	R18,0xE8
    00861 E033      LDI	R19,3
    00862 0185      MOVW	R16,R10
    00863 940E 0C70 CALL	mod16u
    00865 E624      LDI	R18,0x64
    00866 E030      LDI	R19,0
    00867 940E 0C72 CALL	div16u
    00869 9300 0296 STS	Seg7_Led_Buf+2,R16
(0187)  	 Seg7_Led_Buf[1]=(temp%100)/10;
    0086B E624      LDI	R18,0x64
    0086C E030      LDI	R19,0
    0086D 0185      MOVW	R16,R10
    0086E 940E 0C70 CALL	mod16u
    00870 E02A      LDI	R18,0xA
    00871 E030      LDI	R19,0
    00872 940E 0C72 CALL	div16u
    00874 9300 0295 STS	Seg7_Led_Buf+1,R16
(0188)  	 Seg7_Led_Buf[0]=temp%10;
    00876 E02A      LDI	R18,0xA
    00877 E030      LDI	R19,0
    00878 0185      MOVW	R16,R10
    00879 940E 0C70 CALL	mod16u
    0087B 9300 0294 STS	Seg7_Led_Buf,R16
(0189) 	 Seg7_Led_Update();
    0087D DE39      RCALL	_Seg7_Led_Update
(0190) 	}
    0087E C034      RJMP	0x08B3
(0191)  else
(0192)  	{
(0193) 	 temp=data*1000;
    0087F E80C      LDI	R16,0x8C
    00880 E010      LDI	R17,0
    00881 940E 0D0E CALL	elpm32
    00883 01CE      MOVW	R24,R28
    00884 9602      ADIW	R24,2
    00885 939A      ST	-Y,R25
    00886 938A      ST	-Y,R24
    00887 940E 0F32 CALL	fpmule1
    00889 940E 0E21 CALL	fpint
    0088B 0158      MOVW	R10,R16
(0194) 	 point_pos=3;
    0088C E083      LDI	R24,3
    0088D 9380 0239 STS	point_pos,R24
(0195) 	 Seg7_Led_Buf[3]=temp/1000;
    0088F EE28      LDI	R18,0xE8
    00890 E033      LDI	R19,3
    00891 940E 0C72 CALL	div16u
    00893 9300 0297 STS	Seg7_Led_Buf+3,R16
(0196)  	 Seg7_Led_Buf[2]=(temp%1000)/100;
    00895 EE28      LDI	R18,0xE8
    00896 E033      LDI	R19,3
    00897 0185      MOVW	R16,R10
    00898 940E 0C70 CALL	mod16u
    0089A E624      LDI	R18,0x64
    0089B E030      LDI	R19,0
    0089C 940E 0C72 CALL	div16u
    0089E 9300 0296 STS	Seg7_Led_Buf+2,R16
(0197)  	 Seg7_Led_Buf[1]=(temp%100)/10;
    008A0 E624      LDI	R18,0x64
    008A1 E030      LDI	R19,0
    008A2 0185      MOVW	R16,R10
    008A3 940E 0C70 CALL	mod16u
    008A5 E02A      LDI	R18,0xA
    008A6 E030      LDI	R19,0
    008A7 940E 0C72 CALL	div16u
    008A9 9300 0295 STS	Seg7_Led_Buf+1,R16
(0198)  	 Seg7_Led_Buf[0]=temp%10;
    008AB E02A      LDI	R18,0xA
    008AC E030      LDI	R19,0
    008AD 0185      MOVW	R16,R10
    008AE 940E 0C70 CALL	mod16u
    008B0 9300 0294 STS	Seg7_Led_Buf,R16
(0199) 	 Seg7_Led_Update();
    008B2 DE04      RCALL	_Seg7_Led_Update
(0200) 	}
(0201)  point=0;
    008B3 2422      CLR	R2
    008B4 9220 0238 STS	point,R2
    008B6 90B9      LD	R11,Y+
    008B7 90A9      LD	R10,Y+
    008B8 9624      ADIW	R28,4
    008B9 9508      RET
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\key.c
(0001) /************************************************
(0002) 文件：key.c
(0003) 用途：
(0004) 注意：内部8M晶振
(0005) 创建：2008.4.1
(0006) 修改：2008.4.1
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) /*************************************************************************
(0011) ** 函数名称:键盘初始化
(0012) ** 功能描述:
(0013) ** 输　入:
(0014) ** 输出	 :
(0015) ** 全局变量:
(0016) ** 调用模块:
(0017) ** 说明：
(0018) ** 注意：
(0019) **************************************************************************/
(0020) void Key_init(void)
(0021) {
(0022)  KEY_DDR &=~ (1<<S1)|(1<<S2)|(1<<S3)|(1<<S4);
_Key_init:
    008BA 988C      CBI	0x11,4
(0023)  KEY_PORT |= (1<<S1)|(1<<S2)|(1<<S3)|(1<<S4);
    008BB B382      IN	R24,0x12
    008BC 6F80      ORI	R24,0xF0
    008BD BB82      OUT	0x12,R24
    008BE 9508      RET
_get_key:
  tmp                  --> Y,+1
  Key_Value            --> R20
    008BF 934A      ST	-Y,R20
(0024) }
(0025) /*************************************************************************
(0026) ** 函数名称:键盘扫描
(0027) ** 功能描述:
(0028) ** 输　入:
(0029) ** 输出	 :
(0030) ** 全局变量:
(0031) ** 调用模块:
(0032) ** 说明：
(0033) ** 注意：
(0034) **************************************************************************/
(0035) unsigned char get_key(void)
(0036) {
(0037)  unsigned char Key_Value=0xFF,tmp;
    008C0 EF4F      LDI	R20,0xFF
(0038) 
(0039)  Key_Value=KEY_PIN & ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4));
    008C1 B340      IN	R20,0x10
    008C2 7F40      ANDI	R20,0xF0
(0040)  if( Key_Value != ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4)) )
    008C3 3F40      CPI	R20,0xF0
    008C4 F0B1      BEQ	0x08DB
(0041)  	 {
(0042) 	  delay_nms(2);
    008C5 E002      LDI	R16,2
    008C6 E010      LDI	R17,0
    008C7 940E 068E CALL	_delay_nms
(0043) 	  if( (KEY_PIN & ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4))) == Key_Value )
    008C9 B380      IN	R24,0x10
    008CA 7F80      ANDI	R24,0xF0
    008CB 1784      CP	R24,R20
    008CC F471      BNE	0x08DB
(0044) 		 {
(0045) 		  Key_Value=KEY_PIN & ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4));
    008CD B340      IN	R20,0x10
    008CE 7F40      ANDI	R20,0xF0
(0046) 		  //NOP();
(0047) 	  	  while(( KEY_PIN & ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4)) )!= ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4)));
    008CF B380      IN	R24,0x10
    008D0 7F80      ANDI	R24,0xF0
    008D1 3F80      CPI	R24,0xF0
    008D2 F7E1      BNE	0x08CF
(0048) 		  delay_nms(1);
    008D3 E001      LDI	R16,1
    008D4 E010      LDI	R17,0
    008D5 940E 068E CALL	_delay_nms
(0049) 		  while(( KEY_PIN & ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4)) )!= ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4)));
    008D7 B380      IN	R24,0x10
    008D8 7F80      ANDI	R24,0xF0
    008D9 3F80      CPI	R24,0xF0
    008DA F7E1      BNE	0x08D7
(0050) 		 }
(0051) 	 }
(0052) 	 
(0053)  return Key_Value;
    008DB 2F04      MOV	R16,R20
    008DC 9149      LD	R20,Y+
    008DD 9508      RET
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\sio.c
(0001) /************************************************
(0002) 文件：sio.c
(0003) 用途：结构化串口通信程序
(0004) 注意：
(0005) 创建：2008.1.26
(0006) 修改：2008.1.26
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) 
(0011) #if USEUART0
(0012) siocirqueue RTbuf_UART0;
(0013) #endif
(0014) #if USEUART1
(0015) siocirqueue RTbuf_UART1;
(0016) #endif
(0017) 
(0018) #if (CPU_TYPE == M32)||(CPU_TYPE == M16)||(CPU_TYPE == M8)
(0019) #define USEUART0  TRUE
(0020) #define USEUART1  FALSE
(0021) #define iv_USART0_RXC   iv_USART_RXC
(0022) #define iv_USART0_TXC   iv_USART_TXC
(0023) #define UDR0  	  UDR
(0024) #define UCSR0A    UCSRA
(0025) #define UCSR0B    UCSRB
(0026) #define UCSR0C	  UCSRC
(0027) #define UBRR0H	  UBRRH
(0028) #define UBRR0L	  UBRRL
(0029) #define RXCIE0	  RXCIE
(0030) #define TXCIE0	  TXCIE
(0031) #endif
(0032) 
(0033) 
(0034) /*********************************************************************************************************
(0035) ** 函数名称: Com_init
(0036) ** 功能描述: 初始化串行口
(0037) ** 输　入:
(0038) ** 全局变量: 无
(0039) ** 调用模块: Com_baudrate
(0040) ** 说明：
(0041) ** 注意：
(0042) ********************************************************************************************************/
(0043) void Com_init (void) {
(0044) //WDR(); //喂狗
(0045) //CLI();                     // 关中断
(0046) #if USEUART0
(0047)     Tbuf_init(&RTbuf_UART0);              //初始化接收缓冲
_Com_init:
    008DE E908      LDI	R16,0x98
    008DF E012      LDI	R17,2
    008E0 D0E2      RCALL	_Tbuf_init
(0048)     Rbuf_init(&RTbuf_UART0);
    008E1 E908      LDI	R16,0x98
    008E2 E012      LDI	R17,2
    008E3 D0D8      RCALL	_Rbuf_init
(0049)     UCSR0B = 0x00; //disable while setting baud rate
    008E4 2422      CLR	R2
    008E5 B82A      OUT	0x0A,R2
(0050)     UCSR0A=0x00;
    008E6 B82B      OUT	0x0B,R2
(0051) 
(0052) #if CPU_TYPE <= M32
(0053)     UCSRC = (1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0);
(0054)     UCSR0B = (1<<RXCIE)|(1<<TXCIE)|(1<<RXEN)|(1<<TXEN);  // RXCIE=1;TXCIE=1;UDREIE=0;RXEN=1;TXEN=1
(0055) #else
(0056)     UCSR0C=0x06;  //8 DATA ,1 STOP, NO PARITY
    008E7 E086      LDI	R24,6
    008E8 9380 0095 STS	0x95,R24
(0057) //    UCSR0B = (1<<RXCIE0)|(1<<TXCIE0)|(1<<RXEN0)|(1<<TXEN0);  // RXCIE=1;TXCIE=1;UDREIE=0;RXEN=1;TXEN=1
(0058) 	
(0059)     UCSR0B |= (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0);  //允许发送和接收,接收中断使能
    008EA B18A      IN	R24,0x0A
    008EB 6988      ORI	R24,0x98
    008EC B98A      OUT	0x0A,R24
(0060) 	
(0061) #endif
(0062) 
(0063) #endif
(0064) 
(0065) 
(0066) #if USEUART1
(0067)     Tbuf_init(&RTbuf_B);              //初始化接收缓冲
(0068)     Rbuf_init(&RTbuf_B);
(0069)     UCSR1B = 0x00; //disable while setting baud rate
(0070)     UCSR1A = 0x00;
(0071)     UCSR1C = 0x06;
(0072)     UCSR1B = 0xD8;
(0073) #endif
(0074)     Com_baudrate (9600);		 //
    008ED E800      LDI	R16,0x80
    008EE E215      LDI	R17,0x25
    008EF C000      RJMP	_Com_baudrate
_Com_baudrate:
  tmp                  --> R10
  baudrate             --> R10
    008F0 940E 0D71 CALL	push_xgsetF00C
    008F2 0158      MOVW	R10,R16
(0075) 
(0076) //SEI();                     // 开中断
(0077) }
(0078) /*********************************************************************************************************
(0079) ** 函数名称: Com_baudrate
(0080) ** 功能描述: 利用定时器T1产生由参数baudrate指定的波特率
(0081) ** 输　入: baudrate指定的波特率
(0082) ** 全局变量: 无
(0083) ** 调用模块: 无
(0084) ** 说明：
(0085) ** 注意：
(0086) ********************************************************************************************************/
(0087) void Com_baudrate (unsigned int baudrate) {
(0088)     unsigned int tmp;
(0089)     tmp= F_CPU/baudrate/16-1;
    008F3 0115      MOVW	R2,R10
    008F4 2444      CLR	R4
    008F5 2455      CLR	R5
    008F6 E040      LDI	R20,0
    008F7 E152      LDI	R21,0x12
    008F8 E76A      LDI	R22,0x7A
    008F9 E070      LDI	R23,0
    008FA 925A      ST	-Y,R5
    008FB 924A      ST	-Y,R4
    008FC 923A      ST	-Y,R3
    008FD 922A      ST	-Y,R2
    008FE 018A      MOVW	R16,R20
    008FF 019B      MOVW	R18,R22
    00900 940E 0C92 CALL	div32s
    00902 E140      LDI	R20,0x10
    00903 E050      LDI	R21,0
    00904 E060      LDI	R22,0
    00905 E070      LDI	R23,0
    00906 937A      ST	-Y,R23
    00907 936A      ST	-Y,R22
    00908 935A      ST	-Y,R21
    00909 934A      ST	-Y,R20
    0090A 940E 0C92 CALL	div32s
    0090C 0118      MOVW	R2,R16
    0090D 0129      MOVW	R4,R18
    0090E E041      LDI	R20,1
    0090F E050      LDI	R21,0
    00910 E060      LDI	R22,0
    00911 E070      LDI	R23,0
    00912 1A24      SUB	R2,R20
    00913 0A35      SBC	R3,R21
    00914 0A46      SBC	R4,R22
    00915 0A57      SBC	R5,R23
    00916 0151      MOVW	R10,R2
(0090) #if USEUART0
(0091)     UBRR0H=(unsigned char)(tmp>>8);
    00917 2C23      MOV	R2,R3
    00918 2433      CLR	R3
    00919 9220 0090 STS	0x90,R2
(0092)     UBRR0L=(unsigned char)tmp;
    0091B B8A9      OUT	0x09,R10
    0091C 940C 0D78 JMP	pop_xgsetF00C
_Com_putchar:
  RTbuf                --> R12
  c                    --> R10
    0091E 940E 0D58 CALL	push_xgset003C
    00920 0169      MOVW	R12,R18
    00921 2EA0      MOV	R10,R16
(0093) #endif
(0094) #if USEUART1
(0095)     UBRR1H=(unsigned char)(tmp>>8);
(0096)     UBRR1L=(unsigned char)tmp;
(0097) #endif
(0098) }
(0099) /*********************************************************************************************************
(0100) ** 函数名称: Com_putchar
(0101) ** 功能描述: 从串行口输出一个字符c
(0102) ** 输　入: c:输出字符
(0103) ** 输出	 : 0:失败 1:成功
(0104) ** 全局变量: 无
(0105) ** 调用模块:
(0106) ** 说明：
(0107) ** 注意：
(0108) ********************************************************************************************************/
(0109) unsigned char Com_putchar (unsigned char c,siocirqueue *RTbuf) {
(0110) //WDR(); //喂狗
(0111)     if (Tbuf_full(RTbuf))
    00922 0186      MOVW	R16,R12
    00923 D0C4      RCALL	_Tbuf_full
    00924 2300      TST	R16
    00925 F011      BEQ	0x0928
(0112)         return(0);
    00926 2700      CLR	R16
    00927 C004      RJMP	0x092C
(0113)     else {
(0114)         Tbuf_putchar(c,RTbuf);				// 将数据加入到发送缓冲区并开中断
    00928 0196      MOVW	R18,R12
    00929 2D0A      MOV	R16,R10
    0092A D0CE      RCALL	_Tbuf_putchar
(0115)         return(1);
    0092B E001      LDI	R16,1
    0092C 940C 0D32 JMP	pop_xgset003C
_Com_putstring:
  i                    --> R14
  RTbuf                --> R12
  len                  --> R20
  p                    --> R10
    0092E 940E 0D54 CALL	push_xgset30FC
    00930 2F42      MOV	R20,R18
    00931 0158      MOVW	R10,R16
    00932 84C8      LDD	R12,Y+8
    00933 84D9      LDD	R13,Y+9
(0116)     }
(0117) }
(0118) /*********************************************************************************************************
(0119) ** 函数名称: Com_putstring
(0120) ** 功能描述: 从串行口输出一个字符串
(0121) ** 输　入: p:指向输出字符串 len:输出长度
(0122) ** 输出	 :
(0123) ** 全局变量: 无
(0124) ** 调用模块:
(0125) ** 说明：
(0126) ** 注意：
(0127) ********************************************************************************************************/
(0128) void Com_putstring (unsigned char *p,unsigned char len,siocirqueue *RTbuf) {
(0129)     unsigned char i;
(0130) //WDR(); //喂狗
(0131)     if (len!=0 ) {
    00934 2344      TST	R20
    00935 F079      BEQ	0x0945
(0132)         for(i=0; i<len; i++)
    00936 24EE      CLR	R14
    00937 C00A      RJMP	0x0942
(0133)             while(Com_putchar(p[i],RTbuf)==0);//WDR(); //喂狗;
    00938 0196      MOVW	R18,R12
    00939 2DEE      MOV	R30,R14
    0093A 27FF      CLR	R31
    0093B 0DEA      ADD	R30,R10
    0093C 1DFB      ADC	R31,R11
    0093D 8100      LD	R16,Z
    0093E DFDF      RCALL	_Com_putchar
    0093F 2300      TST	R16
    00940 F3B9      BEQ	0x0938
    00941 94E3      INC	R14
    00942 16E4      CP	R14,R20
    00943 F3A0      BCS	0x0938
(0134)     } else {
    00944 C00B      RJMP	0x0950
(0135)         do {
(0136)             while(Com_putchar(*p,RTbuf)==0);//WDR(); //喂狗;
    00945 0196      MOVW	R18,R12
    00946 01F5      MOVW	R30,R10
    00947 8100      LD	R16,Z
    00948 DFD5      RCALL	_Com_putchar
    00949 2300      TST	R16
    0094A F3D1      BEQ	0x0945
(0137)         } while(*p++!='\n');
    0094B 01F5      MOVW	R30,R10
    0094C 9181      LD	R24,Z+
    0094D 015F      MOVW	R10,R30
    0094E 308A      CPI	R24,0xA
    0094F F7A9      BNE	0x0945
(0138)     }
    00950 940C 0D3E JMP	pop_xgset30FC
_Com_getchar:
  ts                   --> R20
  RTbuf                --> R10
  mode                 --> Y,+6
    00952 940E 0C6B CALL	push_arg4
    00954 940E 0D5D CALL	push_xgset300C
    00956 0159      MOVW	R10,R18
    00957 9722      SBIW	R28,2
(0139) 
(0140) }
(0141) /*********************************************************************************************************
(0142) ** 函数名称: Com_getchar
(0143) ** 功能描述: 从串行口输入一个字符
(0144) ** 输　入: mode：0不需等待，在调用函数前检测Com_R_count的值
(0145) **              1 等待数据到来
(0146) ** 输出	 : 读入的字符
(0147) ** 全局变量: 无
(0148) ** 调用模块:
(0149) ** 说明：
(0150) ** 注意：
(0151) ********************************************************************************************************/
(0152) 
(0153) unsigned char Com_getchar (unsigned char mode,siocirqueue *RTbuf) {
(0154) //WDR(); //喂狗
(0155) //    Delay(Delay_Comget,MaxLimit_Comget_Delay);
(0156) //	if (mode>0) while(Com_R_count(RTbuf)==0 && !DelayOvf(Delay_Comget))//WDR(); //喂狗;
(0157) //	if (DelayOvf(Delay_Comget))
(0158) //	    return 0;    //时间超时
(0159) //	else
(0160) 	unsigned char *ts="??!\n";
    00958 E34F      LDI	R20,0x3F
    00959 E052      LDI	R21,2
(0161) 	Com_putstring (ts,4,&RTbuf_UART0);
    0095A E988      LDI	R24,0x98
    0095B E092      LDI	R25,2
    0095C 8399      STD	Y+1,R25
    0095D 8388      ST	Y,R24
    0095E E024      LDI	R18,4
    0095F 018A      MOVW	R16,R20
    00960 DFCD      RCALL	_Com_putstring
(0162)     while(!Com_R_count(RTbuf));
    00961 0185      MOVW	R16,R10
    00962 D056      RCALL	_Com_R_count
    00963 2300      TST	R16
    00964 F3E1      BEQ	0x0961
(0163) 	Com_putstring (ts,4,&RTbuf_UART0);
    00965 E988      LDI	R24,0x98
    00966 E092      LDI	R25,2
    00967 8399      STD	Y+1,R25
    00968 8388      ST	Y,R24
    00969 E024      LDI	R18,4
    0096A 018A      MOVW	R16,R20
    0096B DFC2      RCALL	_Com_putstring
(0164) 	
(0165)     return (Rbuf_getchar(RTbuf));// 串行口输入正确，返回输入的字符
    0096C 0185      MOVW	R16,R10
    0096D D0C2      RCALL	_Rbuf_getchar
    0096E 9622      ADIW	R28,2
    0096F 940E 0D62 CALL	pop_xgset300C
    00971 9624      ADIW	R28,4
    00972 9508      RET
_Com_Rbuf_Clear:
  RTbuf                --> R10
    00973 92AA      ST	-Y,R10
    00974 92BA      ST	-Y,R11
    00975 0158      MOVW	R10,R16
(0166) }
(0167) 
(0168) 
(0169) 
(0170) void Com_Rbuf_Clear(siocirqueue *RTbuf) {
(0171)     Rbuf_init(RTbuf);
    00976 0185      MOVW	R16,R10
    00977 D044      RCALL	_Rbuf_init
    00978 90B9      LD	R11,Y+
    00979 90A9      LD	R10,Y+
    0097A 9508      RET
_Com_getstring:
  ts                   --> R22
  i                    --> R10
  RTbuf                --> R12
  len                  --> R14
  p                    --> R20
    0097B 940E 0D52 CALL	push_xgsetF0FC
    0097D 2EE2      MOV	R14,R18
    0097E 01A8      MOVW	R20,R16
    0097F 9722      SBIW	R28,2
    00980 84CC      LDD	R12,Y+12
    00981 84DD      LDD	R13,Y+13
(0172) }
(0173) 
(0174) 
(0175) 
(0176) unsigned char Com_getstring (unsigned char *p,unsigned char len,siocirqueue *RTbuf) {
(0177) 
(0178)     unsigned char i=0;
    00982 24AA      CLR	R10
(0179) 	unsigned char *ts="???\n";
    00983 E36A      LDI	R22,0x3A
    00984 E072      LDI	R23,2
(0180)     //WDR(); //喂狗
(0181)     if (len>0 ) {
    00985 E080      LDI	R24,0
    00986 158E      CP	R24,R14
    00987 F508      BCC	0x09A9
(0182)         for(i=0; i<len; i++) {
    00988 C01C      RJMP	0x09A5
(0183)             //WDR(); //喂狗
(0184) 			
(0185) 			//debug_start
(0186) 			Com_putstring (ts,4,&RTbuf_UART0);
    00989 E988      LDI	R24,0x98
    0098A E092      LDI	R25,2
    0098B 8399      STD	Y+1,R25
    0098C 8388      ST	Y,R24
    0098D E024      LDI	R18,4
    0098E 018B      MOVW	R16,R22
    0098F DF9E      RCALL	_Com_putstring
(0187) 			Com_putstring (ts,4,&RTbuf_UART0);
    00990 E988      LDI	R24,0x98
    00991 E092      LDI	R25,2
    00992 8399      STD	Y+1,R25
    00993 8388      ST	Y,R24
    00994 E024      LDI	R18,4
    00995 018B      MOVW	R16,R22
    00996 DF97      RCALL	_Com_putstring
(0188)             *p++=Com_getchar(1,RTbuf);
    00997 0196      MOVW	R18,R12
    00998 E001      LDI	R16,1
    00999 DFB8      RCALL	_Com_getchar
    0099A 01FA      MOVW	R30,R20
    0099B 9301      ST	Z+,R16
    0099C 01AF      MOVW	R20,R30
(0189) 			Com_putstring (ts,4,&RTbuf_UART0);
    0099D E988      LDI	R24,0x98
    0099E E092      LDI	R25,2
    0099F 8399      STD	Y+1,R25
    009A0 8388      ST	Y,R24
    009A1 E024      LDI	R18,4
    009A2 018B      MOVW	R16,R22
    009A3 DF8A      RCALL	_Com_putstring
    009A4 94A3      INC	R10
    009A5 14AE      CP	R10,R14
    009A6 F310      BCS	0x0989
(0190) 			
(0191) 			
(0192) 			//debug_start
(0193)         }
(0194)         return(len);
    009A7 2D0E      MOV	R16,R14
    009A8 C00D      RJMP	0x09B6
(0195)     } else {
(0196) 
(0197)         do {
(0198)             *p++=Com_getchar(1,RTbuf);
    009A9 0196      MOVW	R18,R12
    009AA E001      LDI	R16,1
    009AB DFA6      RCALL	_Com_getchar
    009AC 01FA      MOVW	R30,R20
    009AD 9301      ST	Z+,R16
    009AE 01AF      MOVW	R20,R30
(0199)             i++;
    009AF 94A3      INC	R10
(0200)             //WDR(); //喂狗
(0201)         } while(*(p-1)!='\n');
    009B0 01FA      MOVW	R30,R20
    009B1 9731      SBIW	R30,1
    009B2 8180      LD	R24,Z
    009B3 308A      CPI	R24,0xA
    009B4 F7A1      BNE	0x09A9
(0202) //			*p++=Com_getchar(1,RTbuf);
(0203) //			*(p)=0;
(0204)         return(i);
    009B5 2D0A      MOV	R16,R10
    009B6 9622      ADIW	R28,2
    009B7 940C 0D47 JMP	pop_xgsetF0FC
(0205)     }
(0206) 
(0207) }
(0208) 
(0209) 
(0210) /*********************************************************************************************************
(0211) ** 函数名称: Com_R_count
(0212) ** 功能描述: 返回接收缓冲区字符个数函数
(0213) ** 输　入:
(0214) ** 输出	 : 字符个数
(0215) ** 全局变量: 无
(0216) ** 调用模块:
(0217) ** 说明：
(0218) ** 注意：
(0219) ********************************************************************************************************/
(0220) unsigned char Com_R_count(siocirqueue *RTbuf) {
(0221)     return RTbuf->R_count;
_Com_R_count:
  RTbuf                --> R16
    009B9 01F8      MOVW	R30,R16
    009BA 8102      LDD	R16,Z+2
    009BB 9508      RET
(0222) }
(0223) /*********************************************************************************************************
(0224) ** 函数名称: Rbuf_init
(0225) ** 功能描述: 接收缓冲区初始化
(0226) ** 输　入:
(0227) ** 输出	 :
(0228) ** 全局变量: 无
(0229) ** 调用模块:
(0230) ** 说明：
(0231) ** 注意：
(0232) ********************************************************************************************************/
(0233) void Rbuf_init(siocirqueue *RTbuf) {
(0234)     RTbuf->R_front=0;
_Rbuf_init:
  RTbuf                --> R16
    009BC 2422      CLR	R2
    009BD 01F8      MOVW	R30,R16
    009BE 8220      ST	Z,R2
(0235)     RTbuf->R_rear=0;
    009BF 8221      STD	Z+1,R2
(0236)     RTbuf->R_count=0;
    009C0 8222      STD	Z+2,R2
(0237)     RTbuf->R_overflow=0;
    009C1 8223      STD	Z+3,R2
    009C2 9508      RET
(0238) }
(0239) /*********************************************************************************************************
(0240) ** 函数名称: Tbuf_init
(0241) ** 功能描述: 发送缓冲区初始化
(0242) ** 输　入:
(0243) ** 输出	 :
(0244) ** 全局变量: 无
(0245) ** 调用模块:
(0246) ** 说明：
(0247) ** 注意：
(0248) ********************************************************************************************************/
(0249) void Tbuf_init(siocirqueue *RTbuf) {
(0250)     RTbuf->T_front=0;
_Tbuf_init:
  RTbuf                --> R16
    009C3 2422      CLR	R2
    009C4 01F8      MOVW	R30,R16
    009C5 59E8      SUBI	R30,0x98
    009C6 4FFF      SBCI	R31,0xFF
    009C7 8220      ST	Z,R2
    009C8 56E8      SUBI	R30,0x68
    009C9 40F0      SBCI	R31,0
(0251)     RTbuf->T_rear=0;
    009CA 59E7      SUBI	R30,0x97
    009CB 4FFF      SBCI	R31,0xFF
    009CC 8220      ST	Z,R2
    009CD 56E9      SUBI	R30,0x69
    009CE 40F0      SBCI	R31,0
(0252)     RTbuf->T_count=0;
    009CF 59E6      SUBI	R30,0x96
    009D0 4FFF      SBCI	R31,0xFF
    009D1 8220      ST	Z,R2
    009D2 56EA      SUBI	R30,0x6A
    009D3 40F0      SBCI	R31,0
(0253)     RTbuf->T_disabled=1;
    009D4 E081      LDI	R24,1
    009D5 53E1      SUBI	R30,0x31
    009D6 4FFF      SBCI	R31,0xFF
    009D7 8380      ST	Z,R24
    009D8 9508      RET
_Rbuf_empty:
  RTbuf                --> R16
    009D9 934A      ST	-Y,R20
    009DA 935A      ST	-Y,R21
(0254) }
(0255) /*********************************************************************************************************
(0256) ** 函数名称: Rbuf_empty
(0257) ** 功能描述: 接收缓冲区判空
(0258) ** 输　入:
(0259) ** 输出	 :  TRUE 空 FALSE 非空
(0260) ** 全局变量: 无
(0261) ** 调用模块:
(0262) ** 说明：
(0263) ** 注意：
(0264) ********************************************************************************************************/
(0265) unsigned char Rbuf_empty(siocirqueue *RTbuf) {
(0266)     return RTbuf->R_count==0;
    009DB 01F8      MOVW	R30,R16
    009DC 8022      LDD	R2,Z+2
    009DD 2022      TST	R2
    009DE F419      BNE	0x09E2
    009DF E041      LDI	R20,1
    009E0 E050      LDI	R21,0
    009E1 C002      RJMP	0x09E4
    009E2 2744      CLR	R20
    009E3 2755      CLR	R21
    009E4 2F04      MOV	R16,R20
    009E5 9159      LD	R21,Y+
    009E6 9149      LD	R20,Y+
    009E7 9508      RET
_Tbuf_full:
  RTbuf                --> R16
    009E8 934A      ST	-Y,R20
    009E9 935A      ST	-Y,R21
(0267) }
(0268) /*********************************************************************************************************
(0269) ** 函数名称: Tbuf_empty
(0270) ** 功能描述: 发送缓冲区判空
(0271) ** 输　入:
(0272) ** 输出	 :  TRUE 空 FALSE 非空
(0273) ** 全局变量: 无
(0274) ** 调用模块:
(0275) ** 说明：
(0276) ** 注意：
(0277) ********************************************************************************************************
(0278) unsigned char Tbuf_empty(void){
(0279) 	return RTbuf->T_count==0;
(0280) 	}
(0281) /*********************************************************************************************************
(0282) ** 函数名称: Rbuf_full
(0283) ** 功能描述: 接收缓冲区判满
(0284) ** 输　入:
(0285) ** 输出	 :  TRUE 满 FALSE 非满
(0286) ** 全局变量: 无
(0287) ** 调用模块:
(0288) ** 说明：
(0289) ** 注意：
(0290) ********************************************************************************************************
(0291) unsigned char Rbuf_full (void){
(0292) 	return RTbuf->R_count==RBUF_SIZE;
(0293) 	}
(0294) /*********************************************************************************************************
(0295) ** 函数名称: Tbuf_full
(0296) ** 功能描述: 发送缓冲区判满
(0297) ** 输　入:
(0298) ** 输出	 :  TRUE 满 FALSE 非满
(0299) ** 全局变量: 无
(0300) ** 调用模块:
(0301) ** 说明：
(0302) ** 注意：
(0303) ********************************************************************************************************/
(0304) unsigned char Tbuf_full(siocirqueue *RTbuf) {
(0305)     return RTbuf->T_count==TBUF_SIZE;
    009EA 01F8      MOVW	R30,R16
    009EB 59E6      SUBI	R30,0x96
    009EC 4FFF      SBCI	R31,0xFF
    009ED 8180      LD	R24,Z
    009EE 3684      CPI	R24,0x64
    009EF F419      BNE	0x09F3
    009F0 E041      LDI	R20,1
    009F1 E050      LDI	R21,0
    009F2 C002      RJMP	0x09F5
    009F3 2744      CLR	R20
    009F4 2755      CLR	R21
    009F5 2F04      MOV	R16,R20
    009F6 9159      LD	R21,Y+
    009F7 9149      LD	R20,Y+
    009F8 9508      RET
_Tbuf_putchar:
  RTbuf                --> R20
  x                    --> R10
    009F9 940E 0D5D CALL	push_xgset300C
    009FB 01A9      MOVW	R20,R18
    009FC 2EA0      MOV	R10,R16
(0306) }
(0307) /*********************************************************************************************************
(0308) ** 函数名称: Rbuf_putchar
(0309) ** 功能描述: 把一个字符放入接收缓冲区
(0310) ** 输　入:
(0311) ** 输出	 :
(0312) ** 全局变量: 无
(0313) ** 调用模块:
(0314) ** 说明：
(0315) ** 注意：
(0316) ********************************************************************************************************
(0317) void  Rbuf_putchar (unsigned char x){
(0318) 	if(!Rbuf_full()){
(0319) 		REV_DIS();
(0320) 		RTbuf->R_count++;
(0321) 		RTbuf->R_buf[RTbuf->R_rear]=x;
(0322) 		RTbuf->R_rear=(RTbuf->R_rear+1) % RBUF_SIZE;
(0323) 		REV_EN();
(0324) 	}
(0325) }
(0326) /*********************************************************************************************************
(0327) ** 函数名称: Tbuf_putchar
(0328) ** 功能描述: 把一个字符放入发送缓冲区
(0329) ** 输　入:
(0330) ** 输出	 :
(0331) ** 全局变量: 无
(0332) ** 调用模块:
(0333) ** 说明：
(0334) ** 注意：
(0335) ********************************************************************************************************/
(0336) void Tbuf_putchar(unsigned char x,siocirqueue *RTbuf) {
(0337)     if(!Tbuf_full(RTbuf)) {
    009FD 018A      MOVW	R16,R20
    009FE DFE9      RCALL	_Tbuf_full
    009FF 2300      TST	R16
    00A00 F009      BEQ	0x0A02
    00A01 C02C      RJMP	0x0A2E
(0338)         TXC_DIS();
    00A02 9856      CBI	0x0A,6
(0339)         if (RTbuf->T_disabled) {
    00A03 01FA      MOVW	R30,R20
    00A04 53E1      SUBI	R30,0x31
    00A05 4FFF      SBCI	R31,0xFF
    00A06 8020      LD	R2,Z
    00A07 5CEF      SUBI	R30,0xCF
    00A08 40F0      SBCI	R31,0
    00A09 2022      TST	R2
    00A0A F031      BEQ	0x0A11
(0340)             UDR0=x;
    00A0B B8AC      OUT	0x0C,R10
(0341)             RTbuf->T_disabled=0;
    00A0C 2422      CLR	R2
    00A0D 53E1      SUBI	R30,0x31
    00A0E 4FFF      SBCI	R31,0xFF
    00A0F 8220      ST	Z,R2
(0342)         } else {
    00A10 C01C      RJMP	0x0A2D
(0343)             RTbuf->T_count++;
    00A11 01CA      MOVW	R24,R20
    00A12 5986      SUBI	R24,0x96
    00A13 4F9F      SBCI	R25,0xFF
    00A14 01FC      MOVW	R30,R24
    00A15 8180      LD	R24,Z
    00A16 5F8F      SUBI	R24,0xFF
    00A17 8380      ST	Z,R24
(0344)             RTbuf->T_buf[RTbuf->T_rear]=x;
    00A18 01CA      MOVW	R24,R20
    00A19 5985      SUBI	R24,0x95
    00A1A 4F9F      SBCI	R25,0xFF
    00A1B 01FA      MOVW	R30,R20
    00A1C 59E7      SUBI	R30,0x97
    00A1D 4FFF      SBCI	R31,0xFF
    00A1E 81E0      LD	R30,Z
    00A1F 27FF      CLR	R31
    00A20 0FE8      ADD	R30,R24
    00A21 1FF9      ADC	R31,R25
    00A22 82A0      ST	Z,R10
(0345)             RTbuf->T_rear=(RTbuf->T_rear+1) % TBUF_SIZE;
    00A23 5947      SUBI	R20,0x97
    00A24 4F5F      SBCI	R21,0xFF
    00A25 E614      LDI	R17,0x64
    00A26 01FA      MOVW	R30,R20
    00A27 8100      LD	R16,Z
    00A28 5F0F      SUBI	R16,0xFF
    00A29 940E 0CF6 CALL	mod8u
    00A2B 01FA      MOVW	R30,R20
    00A2C 8300      ST	Z,R16
(0346)         }
(0347)         TXC_EN();
    00A2D 9A56      SBI	0x0A,6
(0348)     }
    00A2E 940C 0D62 JMP	pop_xgset300C
_Rbuf_getchar:
  Btemp                --> R10
  RTbuf                --> R20
    00A30 940E 0D5D CALL	push_xgset300C
    00A32 01A8      MOVW	R20,R16
(0349) }
(0350) /*********************************************************************************************************
(0351) ** 函数名称: Rbuf_getstring
(0352) ** 功能描述: 从接收缓冲区返回当前子串指针
(0353) ** 输　入:
(0354) ** 输出	 :  当前子串指针
(0355) ** 全局变量: 无
(0356) ** 调用模块:
(0357) ** 说明：
(0358) ** 注意：
(0359) ********************************************************************************************************
(0360) unsigned char * Rbuf_getstring(void){
(0361) 	return (RTbuf->R_buf[RTbuf->R_front]);
(0362) }
(0363) /*********************************************************************************************************
(0364) ** 函数名称: Tbuf_getstring
(0365) ** 功能描述: 从发送缓冲区返回当前子串指针
(0366) ** 输　入:
(0367) ** 输出	 :  当前子串指针
(0368) ** 全局变量: 无
(0369) ** 调用模块:
(0370) ** 说明：
(0371) ** 注意：
(0372) ********************************************************************************************************
(0373) unsigned char * Tbuf_getstring(void){
(0374) 	return (RTbuf->T_buf[RTbuf->T_front]);
(0375) }
(0376) /*********************************************************************************************************
(0377) ** 函数名称: Rbuf_putchar
(0378) ** 功能描述: 从接收缓冲区读一个字符
(0379) ** 输　入:
(0380) ** 输出	 :  读字符
(0381) ** 全局变量: 无
(0382) ** 调用模块:
(0383) ** 说明：
(0384) ** 注意：
(0385) ********************************************************************************************************/
(0386) unsigned char Rbuf_getchar(siocirqueue *RTbuf) {
(0387)     unsigned char Btemp=0;
    00A33 24AA      CLR	R10
(0388)     if (!Rbuf_empty(RTbuf)) {
    00A34 018A      MOVW	R16,R20
    00A35 DFA3      RCALL	_Rbuf_empty
    00A36 2300      TST	R16
    00A37 F4C1      BNE	0x0A50
(0389)         Btemp=RTbuf->R_buf[RTbuf->R_front];
    00A38 01CA      MOVW	R24,R20
    00A39 9604      ADIW	R24,4
    00A3A 01FA      MOVW	R30,R20
    00A3B 81E0      LD	R30,Z
    00A3C 27FF      CLR	R31
    00A3D 0FE8      ADD	R30,R24
    00A3E 1FF9      ADC	R31,R25
    00A3F 80A0      LD	R10,Z
(0390)         REV_DIS();
    00A40 9857      CBI	0x0A,7
(0391)         RTbuf->R_count--;
    00A41 01CA      MOVW	R24,R20
    00A42 9602      ADIW	R24,2
    00A43 01FC      MOVW	R30,R24
    00A44 8180      LD	R24,Z
    00A45 5081      SUBI	R24,1
    00A46 8380      ST	Z,R24
(0392)         RTbuf->R_front=(RTbuf->R_front+1) % RBUF_SIZE;
    00A47 E614      LDI	R17,0x64
    00A48 01FA      MOVW	R30,R20
    00A49 8100      LD	R16,Z
    00A4A 5F0F      SUBI	R16,0xFF
    00A4B 940E 0CF6 CALL	mod8u
    00A4D 01FA      MOVW	R30,R20
    00A4E 8300      ST	Z,R16
(0393)         REV_EN();
    00A4F 9A57      SBI	0x0A,7
(0394)     }
(0395)     return (Btemp);
    00A50 2D0A      MOV	R16,R10
    00A51 940C 0D62 JMP	pop_xgset300C
_uart0_rx_isr:
  data                 --> R10
  status               --> R22
  RTbuf                --> R20
    00A53 922A      ST	-Y,R2
    00A54 923A      ST	-Y,R3
    00A55 930A      ST	-Y,R16
    00A56 931A      ST	-Y,R17
    00A57 938A      ST	-Y,R24
    00A58 939A      ST	-Y,R25
    00A59 93EA      ST	-Y,R30
    00A5A 93FA      ST	-Y,R31
    00A5B B62F      IN	R2,0x3F
    00A5C 922A      ST	-Y,R2
    00A5D 940E 0D71 CALL	push_xgsetF00C
(0396) 
(0397) }
(0398) /*********************************************************************************************************
(0399) ** 函数名称: Tbuf_getchar
(0400) ** 功能描述: 从发送缓冲区读一个字符
(0401) ** 输　入:
(0402) ** 输出	 :  读字符
(0403) ** 全局变量: 无
(0404) ** 调用模块:
(0405) ** 说明：
(0406) ** 注意：
(0407) ********************************************************************************************************
(0408) unsigned char Tbuf_getchar(void){
(0409) 	unsigned char Btemp;
(0410) 	if (!Tbuf_empty()){
(0411) 		Btemp=RTbuf->T_buf[RTbuf->T_front];
(0412) 		TXC_DIS();
(0413) 		RTbuf->T_count--;
(0414) 		RTbuf->T_front=(RTbuf->T_front+1) % TBUF_SIZE;
(0415) 		TXC_EN();
(0416) 		return (Btemp);
(0417) 	}
(0418) }
(0419) */
(0420) 
(0421) /******************************* 中断处理函数 ***************************
(0422) * 功能：完成数据得的接收和发送
(0423) ***********************************************************************/
(0424) #if USEUART0
(0425) #pragma interrupt_handler uart0_rx_isr:iv_USART0_RXC
(0426) void uart0_rx_isr(void) {
(0427)     unsigned char status,data;
(0428)     siocirqueue *RTbuf;
(0429)     RTbuf=&RTbuf_UART0;
    00A5F E948      LDI	R20,0x98
    00A60 E052      LDI	R21,2
(0430) // CLI();
(0431)     status=UCSR0A;
    00A61 B16B      IN	R22,0x0B
(0432)     data=UDR0;
    00A62 B0AC      IN	R10,0x0C
(0433) //WDR(); //喂狗
(0434)     if((status & (FRAMING_ERROR | DATA_OVERRUN))==0) {
    00A63 2F86      MOV	R24,R22
    00A64 7188      ANDI	R24,0x18
    00A65 F009      BEQ	0x0A67
    00A66 C022      RJMP	0x0A89
(0435)         if(RTbuf->R_count<RBUF_SIZE) {
    00A67 01FA      MOVW	R30,R20
    00A68 8182      LDD	R24,Z+2
    00A69 3684      CPI	R24,0x64
    00A6A F008      BCS	0x0A6C
    00A6B C01A      RJMP	0x0A86
(0436)             RTbuf->R_count++;
    00A6C 01CF      MOVW	R24,R30
    00A6D 9602      ADIW	R24,2
    00A6E 01FC      MOVW	R30,R24
    00A6F 8180      LD	R24,Z
    00A70 5F8F      SUBI	R24,0xFF
    00A71 8380      ST	Z,R24
(0437)             RTbuf->R_buf[RTbuf->R_rear]=data;
    00A72 01CA      MOVW	R24,R20
    00A73 9604      ADIW	R24,4
    00A74 01FA      MOVW	R30,R20
    00A75 81E1      LDD	R30,Z+1
    00A76 27FF      CLR	R31
    00A77 0FE8      ADD	R30,R24
    00A78 1FF9      ADC	R31,R25
    00A79 82A0      ST	Z,R10
(0438)             RTbuf->R_rear=(RTbuf->R_rear+1) % RBUF_SIZE;
    00A7A 01CA      MOVW	R24,R20
    00A7B 9601      ADIW	R24,1
    00A7C 011C      MOVW	R2,R24
    00A7D E614      LDI	R17,0x64
    00A7E 01FC      MOVW	R30,R24
    00A7F 8100      LD	R16,Z
    00A80 5F0F      SUBI	R16,0xFF
    00A81 940E 0CF6 CALL	mod8u
    00A83 01F1      MOVW	R30,R2
    00A84 8300      ST	Z,R16
(0439)         } else {
    00A85 C003      RJMP	0x0A89
(0440)             RTbuf->R_overflow=1;
    00A86 E081      LDI	R24,1
    00A87 01FA      MOVW	R30,R20
    00A88 8383      STD	Z+3,R24
(0441)         }
(0442)     }
    00A89 940E 0D78 CALL	pop_xgsetF00C
    00A8B 9029      LD	R2,Y+
    00A8C BE2F      OUT	0x3F,R2
    00A8D 91F9      LD	R31,Y+
    00A8E 91E9      LD	R30,Y+
    00A8F 9199      LD	R25,Y+
    00A90 9189      LD	R24,Y+
    00A91 9119      LD	R17,Y+
    00A92 9109      LD	R16,Y+
    00A93 9039      LD	R3,Y+
    00A94 9029      LD	R2,Y+
    00A95 9518      RETI
_getstr:
  data                 --> R10
  status               --> R22
  RTbuf                --> R20
    00A96 940E 0D71 CALL	push_xgsetF00C
(0443) //SEI();
(0444) }
(0445) 
(0446) 
(0447) 
(0448) 
(0449) 
(0450) void getstr(void) {
(0451)     unsigned char status,data;
(0452)     siocirqueue *RTbuf;
(0453)     RTbuf=&RTbuf_UART0;
    00A98 E948      LDI	R20,0x98
    00A99 E052      LDI	R21,2
(0454) // CLI();
(0455)     status=UCSR0A;
    00A9A B16B      IN	R22,0x0B
(0456)     data=UDR0;
    00A9B B0AC      IN	R10,0x0C
(0457) //WDR(); //喂狗
(0458)     if((status & (FRAMING_ERROR | DATA_OVERRUN))==0) {
    00A9C 2F86      MOV	R24,R22
    00A9D 7188      ANDI	R24,0x18
    00A9E F009      BEQ	0x0AA0
    00A9F C022      RJMP	0x0AC2
(0459)         if(RTbuf->R_count<RBUF_SIZE) {
    00AA0 01FA      MOVW	R30,R20
    00AA1 8182      LDD	R24,Z+2
    00AA2 3684      CPI	R24,0x64
    00AA3 F008      BCS	0x0AA5
    00AA4 C01A      RJMP	0x0ABF
(0460)             RTbuf->R_count++;
    00AA5 01CF      MOVW	R24,R30
    00AA6 9602      ADIW	R24,2
    00AA7 01FC      MOVW	R30,R24
    00AA8 8180      LD	R24,Z
    00AA9 5F8F      SUBI	R24,0xFF
    00AAA 8380      ST	Z,R24
(0461)             RTbuf->R_buf[RTbuf->R_rear]=data;
    00AAB 01CA      MOVW	R24,R20
    00AAC 9604      ADIW	R24,4
    00AAD 01FA      MOVW	R30,R20
    00AAE 81E1      LDD	R30,Z+1
    00AAF 27FF      CLR	R31
    00AB0 0FE8      ADD	R30,R24
    00AB1 1FF9      ADC	R31,R25
    00AB2 82A0      ST	Z,R10
(0462)             RTbuf->R_rear=(RTbuf->R_rear+1) % RBUF_SIZE;
    00AB3 01CA      MOVW	R24,R20
    00AB4 9601      ADIW	R24,1
    00AB5 011C      MOVW	R2,R24
    00AB6 E614      LDI	R17,0x64
    00AB7 01FC      MOVW	R30,R24
    00AB8 8100      LD	R16,Z
    00AB9 5F0F      SUBI	R16,0xFF
    00ABA 940E 0CF6 CALL	mod8u
    00ABC 01F1      MOVW	R30,R2
    00ABD 8300      ST	Z,R16
(0463)         } else {
    00ABE C003      RJMP	0x0AC2
(0464)             RTbuf->R_overflow=1;
    00ABF E081      LDI	R24,1
    00AC0 01FA      MOVW	R30,R20
    00AC1 8383      STD	Z+3,R24
(0465)         }
(0466)     }
    00AC2 940C 0D78 JMP	pop_xgsetF00C
_uart0_tx_isr:
  RTbuf                --> R20
    00AC4 922A      ST	-Y,R2
    00AC5 923A      ST	-Y,R3
    00AC6 930A      ST	-Y,R16
    00AC7 931A      ST	-Y,R17
    00AC8 938A      ST	-Y,R24
    00AC9 939A      ST	-Y,R25
    00ACA 93EA      ST	-Y,R30
    00ACB 93FA      ST	-Y,R31
    00ACC B62F      IN	R2,0x3F
    00ACD 922A      ST	-Y,R2
    00ACE 934A      ST	-Y,R20
    00ACF 935A      ST	-Y,R21
(0467) //SEI();
(0468) }
(0469) 
(0470) 
(0471) 
(0472) 
(0473) 
(0474) 
(0475) #pragma interrupt_handler uart0_tx_isr: iv_USART0_TXC
(0476) void uart0_tx_isr(void) {
(0477) //CLI();
(0478)     siocirqueue *RTbuf;
(0479) //WDR(); //喂狗
(0480)     RTbuf=&RTbuf_UART0;
    00AD0 E948      LDI	R20,0x98
    00AD1 E052      LDI	R21,2
(0481)     if (RTbuf->T_count>0) {
    00AD2 E080      LDI	R24,0
    00AD3 01FA      MOVW	R30,R20
    00AD4 59E6      SUBI	R30,0x96
    00AD5 4FFF      SBCI	R31,0xFF
    00AD6 8020      LD	R2,Z
    00AD7 56EA      SUBI	R30,0x6A
    00AD8 40F0      SBCI	R31,0
    00AD9 1582      CP	R24,R2
    00ADA F008      BCS	0x0ADC
    00ADB C01F      RJMP	0x0AFB
(0482)         UDR0=RTbuf->T_buf[RTbuf->T_front];
    00ADC 01CF      MOVW	R24,R30
    00ADD 5985      SUBI	R24,0x95
    00ADE 4F9F      SBCI	R25,0xFF
    00ADF 59E8      SUBI	R30,0x98
    00AE0 4FFF      SBCI	R31,0xFF
    00AE1 81E0      LD	R30,Z
    00AE2 27FF      CLR	R31
    00AE3 0FE8      ADD	R30,R24
    00AE4 1FF9      ADC	R31,R25
    00AE5 8020      LD	R2,Z
    00AE6 B82C      OUT	0x0C,R2
(0483)         RTbuf->T_count--;
    00AE7 01CA      MOVW	R24,R20
    00AE8 5986      SUBI	R24,0x96
    00AE9 4F9F      SBCI	R25,0xFF
    00AEA 01FC      MOVW	R30,R24
    00AEB 8180      LD	R24,Z
    00AEC 5081      SUBI	R24,1
    00AED 8380      ST	Z,R24
(0484)         RTbuf->T_front=(RTbuf->T_front+1) % TBUF_SIZE;
    00AEE 01CA      MOVW	R24,R20
    00AEF 5988      SUBI	R24,0x98
    00AF0 4F9F      SBCI	R25,0xFF
    00AF1 011C      MOVW	R2,R24
    00AF2 E614      LDI	R17,0x64
    00AF3 01FC      MOVW	R30,R24
    00AF4 8100      LD	R16,Z
    00AF5 5F0F      SUBI	R16,0xFF
    00AF6 940E 0CF6 CALL	mod8u
    00AF8 01F1      MOVW	R30,R2
    00AF9 8300      ST	Z,R16
(0485)     } else
    00AFA C005      RJMP	0x0B00
(0486)         RTbuf->T_disabled=1;
    00AFB E081      LDI	R24,1
    00AFC 01FA      MOVW	R30,R20
    00AFD 53E1      SUBI	R30,0x31
    00AFE 4FFF      SBCI	R31,0xFF
    00AFF 8380      ST	Z,R24
    00B00 9159      LD	R21,Y+
    00B01 9149      LD	R20,Y+
    00B02 9029      LD	R2,Y+
    00B03 BE2F      OUT	0x3F,R2
    00B04 91F9      LD	R31,Y+
    00B05 91E9      LD	R30,Y+
    00B06 9199      LD	R25,Y+
    00B07 9189      LD	R24,Y+
    00B08 9119      LD	R17,Y+
    00B09 9109      LD	R16,Y+
    00B0A 9039      LD	R3,Y+
    00B0B 9029      LD	R2,Y+
    00B0C 9518      RETI
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\TWI.c
(0001) /************************************************
(0002) 文件：TWI.c
(0003) 用途：TWI操作函数
(0004) 注意：
(0005) 创建：2008.1.26
(0006) 修改：2008.1.26
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) /*************************************************************************
(0011) ** 函数名称: twi_init(void)
(0012) ** 功能描述: i2c通信初始化
(0013) ** 输　入: 
(0014) ** 输出	 : 
(0015) ** 全局变量: 无
(0016) ** 调用模块: 
(0017) ** 说明：
(0018) ** 注意：
(0019) **************************************************************************/
(0020) void twi_init(void)
(0021) {
(0022)  TWCR= 0x00; //disable twi
_twi_init:
    00B0D 2422      CLR	R2
    00B0E 9220 0074 STS	0x74,R2
(0023)  TWBR= (1<<6) | (1<<5) | (1<<2); //set bit rate
    00B10 E684      LDI	R24,0x64
    00B11 9380 0070 STS	0x70,R24
(0024)  TWSR= 0x00; //set prescale
    00B13 9220 0071 STS	0x71,R2
(0025)  TWAR= 0x00; //set slave address
    00B15 9220 0072 STS	0x72,R2
(0026)  TWCR= (1<<TWEN); //enable twi
    00B17 E084      LDI	R24,4
    00B18 9380 0074 STS	0x74,R24
    00B1A 9508      RET
(0027) }
(0028) /*************************************************************************
(0029) ** 函数名称: i2cstart(void)
(0030) ** 功能描述: i2c通信开始
(0031) ** 输　入: 
(0032) ** 输出	 : 
(0033) ** 全局变量: 无
(0034) ** 调用模块: 
(0035) ** 说明：
(0036) ** 注意：
(0037) **************************************************************************/
(0038) void i2cstart(void)
(0039) { 
(0040) 	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN); 
_i2cstart:
    00B1B EA84      LDI	R24,0xA4
    00B1C 9380 0074 STS	0x74,R24
(0041)    	while (!(TWCR & (1<<TWINT)));
    00B1E 9020 0074 LDS	R2,0x74
    00B20 FE27      SBRS	R2,7
    00B21 CFFC      RJMP	0x0B1E
    00B22 9508      RET
(0042) }
(0043) /*************************************************************************
(0044) ** 函数名称: unsigned char i2cwt(unsigned char data)
(0045) ** 功能描述: i2c写数据,返回TWI状态
(0046) ** 输　入: 
(0047) ** 输  出: TWI状态
(0048) ** 全局变量: 无
(0049) ** 调用模块: 
(0050) ** 说明：
(0051) ** 注意：
(0052) **************************************************************************/
(0053) unsigned char i2cwt(unsigned char data)
(0054) { 
(0055) 	TWDR = data;
_i2cwt:
  data                 --> R16
    00B23 9300 0073 STS	0x73,R16
(0056)    	TWCR = (1<<TWINT) | (1<<TWEN);
    00B25 E884      LDI	R24,0x84
    00B26 9380 0074 STS	0x74,R24
(0057)    	while (!(TWCR & (1<<TWINT)));
    00B28 9020 0074 LDS	R2,0x74
    00B2A FE27      SBRS	R2,7
    00B2B CFFC      RJMP	0x0B28
(0058)    	_NOP();
    00B2C 0000      NOP
(0059)    	return(TWSR&0b11111000);
    00B2D 9100 0071 LDS	R16,0x71
    00B2F 7F08      ANDI	R16,0xF8
    00B30 9508      RET
(0060) }
(0061) /*************************************************************************
(0062) ** 函数名称: unsigned char i2crd(void)
(0063) ** 功能描述: i2c读数据
(0064) ** 输　入: 
(0065) ** 输出	 : 读取的数据
(0066) ** 全局变量: 无
(0067) ** 调用模块: 
(0068) ** 说明：
(0069) ** 注意：
(0070) **************************************************************************/
(0071) unsigned char i2crd(void)
(0072) {
(0073)    	TWCR= (1<<TWINT) | (1<<TWEA) | (1<<TWEN);
_i2crd:
    00B31 EC84      LDI	R24,0xC4
    00B32 9380 0074 STS	0x74,R24
(0074)    	while (!(TWCR & (1<<TWINT)));
    00B34 9020 0074 LDS	R2,0x74
    00B36 FE27      SBRS	R2,7
    00B37 CFFC      RJMP	0x0B34
(0075)    	return(TWDR);
    00B38 9100 0073 LDS	R16,0x73
    00B3A 9508      RET
(0076) }
(0077) /*************************************************************************
(0078) ** 函数名称: i2cstop(void)
(0079) ** 功能描述: i2c停止
(0080) ** 输　入: 
(0081) ** 输出	 : 
(0082) ** 全局变量: 无
(0083) ** 调用模块: 
(0084) ** 说明：
(0085) ** 注意：
(0086) **************************************************************************/
(0087) void i2cstop(void)
(0088) { 
(0089)    TWCR = (1<<TWINT) | (1<<TWSTO) | (1<<TWEN);
_i2cstop:
    00B3B E984      LDI	R24,0x94
    00B3C 9380 0074 STS	0x74,R24
    00B3E 9508      RET
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\spi.c
(0001) /************************************************
(0002) 文件：spi.c
(0003) 用途：SPI驱动
(0004) 注意：
(0005) 创建：2008.1.25
(0006) 修改：2008.1.25
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) /*************************************************************************
(0011) ** 函数名称: spi_init(void)
(0012) ** 功能描述: SPI初始化
(0013) ** 输　入: 
(0014) ** 输出	 : 
(0015) ** 全局变量: 无
(0016) ** 调用模块: 
(0017) ** 说明：
(0018) ** 注意：
(0019) **************************************************************************/
(0020) void spi_init(void)
(0021) {
(0022)  	 DDRB |= (1<<MOSI)|(1<<SCK)|(1<<SS);//设置MOSI，SCK输出
_spi_init:
    00B3F B387      IN	R24,0x17
    00B40 6087      ORI	R24,7
    00B41 BB87      OUT	0x17,R24
(0023)  	 SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<SPR1);//使能SPI，主机模式
    00B42 E583      LDI	R24,0x53
    00B43 B98D      OUT	0x0D,R24
    00B44 9508      RET
(0024) }
(0025) /*************************************************************************
(0026) ** 函数名称: SPI_MasterTransmit(char Data)
(0027) ** 功能描述: SPI主机发送数据
(0028) ** 输　入: Data 需要通过SPI传输的数据
(0029) ** 输出	 : 
(0030) ** 全局变量: 无
(0031) ** 调用模块: 
(0032) ** 说明：
(0033) ** 注意：
(0034) **************************************************************************/
(0035) void SPI_MasterTransmit(char Data)
(0036) {
(0037)  	 /* 启动数据传输 */
(0038)  	 SPDR = Data;
_SPI_MasterTransmit:
  Data                 --> R16
    00B45 B90F      OUT	0x0F,R16
(0039)  	 /* 等待传输结束 */
(0040)  	 while(!(SPSR & (1<<SPIF)))
    00B46 9B77      SBIS	0x0E,7
    00B47 CFFE      RJMP	0x0B46
    00B48 9508      RET
_init_ds18b20:
  status               --> R20
    00B49 934A      ST	-Y,R20
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\DS18B20.c
(0001) #include "..\config.h"
(0002) 
(0003) char current_temp_display_buffer[]={"Temp:         "};
(0004) unsigned char currentT=0;
(0005) const unsigned char df_table[]={0,1,1,2,2,3,4,4,5,6,6,7,7,8,9,9};
(0006) unsigned char ds18b20_error=0;
(0007) unsigned char temp_value[]={0x00,0x00};
(0008) unsigned char display_digit[]={0,0,0,0};
(0009) 
(0010) 
(0011) 
(0012) 
(0013) //初始化DS18B20
(0014) unsigned char init_ds18b20(void)
(0015) {
(0016)  unsigned char status;
(0017)  DQ_DDR_1();
    00B4A 9180 0061 LDS	R24,0x61
    00B4C 6084      ORI	R24,4
    00B4D 9380 0061 STS	0x61,R24
(0018)  DQ_0();
    00B4F 9180 0062 LDS	R24,0x62
    00B51 7F8B      ANDI	R24,0xFB
    00B52 9380 0062 STS	0x62,R24
(0019)  delay_nus(540); //主机拉低总线，占总线
    00B54 E10C      LDI	R16,0x1C
    00B55 E012      LDI	R17,2
    00B56 940E 0676 CALL	_delay_nus
(0020)  
(0021)  DQ_DDR_0();
    00B58 9180 0061 LDS	R24,0x61
    00B5A 7F8B      ANDI	R24,0xFB
    00B5B 9380 0061 STS	0x61,R24
(0022)  delay_nus(65); //PA4设为输入
    00B5D E401      LDI	R16,0x41
    00B5E E010      LDI	R17,0
    00B5F 940E 0676 CALL	_delay_nus
(0023)  
(0024)  status=RD_DQ_VAL(); //读总线，为0时器件在线
    00B61 B140      IN	R20,0x00
    00B62 7044      ANDI	R20,4
(0025)  delay_nus(500);
    00B63 EF04      LDI	R16,0xF4
    00B64 E011      LDI	R17,1
    00B65 940E 0676 CALL	_delay_nus
(0026)  DQ_1();        //释放总线
    00B67 9180 0062 LDS	R24,0x62
    00B69 6084      ORI	R24,4
    00B6A 9380 0062 STS	0x62,R24
(0027)  return status;
    00B6C 2F04      MOV	R16,R20
    00B6D 9149      LD	R20,Y+
    00B6E 9508      RET
_readonebyte:
  dat                  --> R10
  i                    --> R20
    00B6F 92AA      ST	-Y,R10
    00B70 934A      ST	-Y,R20
(0028)  
(0029) }
(0030) 
(0031) unsigned char readonebyte(void) //读一字节
(0032) {
(0033)   unsigned char i=0,dat=0;
    00B71 24AA      CLR	R10
(0034)    for(i=0;i<8;i++)
    00B72 2744      CLR	R20
    00B73 C01F      RJMP	0x0B93
(0035)    {  
(0036)      
(0037)       DQ_DDR_1();
    00B74 9180 0061 LDS	R24,0x61
    00B76 6084      ORI	R24,4
    00B77 9380 0061 STS	0x61,R24
(0038)       DQ_0();      //拉低总线
    00B79 9180 0062 LDS	R24,0x62
    00B7B 7F8B      ANDI	R24,0xFB
    00B7C 9380 0062 STS	0x62,R24
(0039) 	  delay_nus(2);
    00B7E E002      LDI	R16,2
    00B7F E010      LDI	R17,0
    00B80 940E 0676 CALL	_delay_nus
(0040)       DQ_DDR_0();  //读PA4引脚
    00B82 9180 0061 LDS	R24,0x61
    00B84 7F8B      ANDI	R24,0xFB
    00B85 9380 0061 STS	0x61,R24
(0041) 	  if(RD_DQ_VAL())
    00B87 9B02      SBIS	0x00,2
    00B88 C005      RJMP	0x0B8E
(0042) 	  dat|=(1<<i); //数据存放在dat中
    00B89 E001      LDI	R16,1
    00B8A 2F14      MOV	R17,R20
    00B8B 940E 0DA6 CALL	lsl8
    00B8D 2AA0      OR	R10,R16
(0043) 	  delay_nus(80);
    00B8E E500      LDI	R16,0x50
    00B8F E010      LDI	R17,0
    00B90 940E 0676 CALL	_delay_nus
    00B92 9543      INC	R20
    00B93 3048      CPI	R20,0x8
    00B94 F2F8      BCS	0x0B74
(0044)    }
(0045)    return dat;
    00B95 2D0A      MOV	R16,R10
    00B96 9149      LD	R20,Y+
    00B97 90A9      LD	R10,Y+
    00B98 9508      RET
_writeonebyte:
  i                    --> R20
  dat                  --> R10
    00B99 92AA      ST	-Y,R10
    00B9A 934A      ST	-Y,R20
    00B9B 2EA0      MOV	R10,R16
(0046) }
(0047) 
(0048) 
(0049) 
(0050) void writeonebyte(unsigned char dat) //写一字节
(0051) {
(0052)    unsigned char i=0x01;
(0053)    for(i=0x01;i!=0x00;i<<=1)
    00B9C E041      LDI	R20,1
    00B9D C022      RJMP	0x0BC0
(0054)    {
(0055)       DQ_DDR_1();
    00B9E 9180 0061 LDS	R24,0x61
    00BA0 6084      ORI	R24,4
    00BA1 9380 0061 STS	0x61,R24
(0056)       DQ_0();      //拉低,占总线
    00BA3 9180 0062 LDS	R24,0x62
    00BA5 7F8B      ANDI	R24,0xFB
    00BA6 9380 0062 STS	0x62,R24
(0057) 	  if(dat&i)
    00BA8 2C2A      MOV	R2,R10
    00BA9 2224      AND	R2,R20
    00BAA F031      BEQ	0x0BB1
(0058) 	    DQ_1(); 
    00BAB 9180 0062 LDS	R24,0x62
    00BAD 6084      ORI	R24,4
    00BAE 9380 0062 STS	0x62,R24
    00BB0 C005      RJMP	0x0BB6
(0059) 	  else
(0060) 	    DQ_0(); 
    00BB1 9180 0062 LDS	R24,0x62
    00BB3 7F8B      ANDI	R24,0xFB
    00BB4 9380 0062 STS	0x62,R24
(0061) 	  delay_nus(80);
    00BB6 E500      LDI	R16,0x50
    00BB7 E010      LDI	R17,0
    00BB8 940E 0676 CALL	_delay_nus
(0062) 	  DQ_1(); 
    00BBA 9180 0062 LDS	R24,0x62
    00BBC 6084      ORI	R24,4
    00BBD 9380 0062 STS	0x62,R24
    00BBF 0F44      LSL	R20
    00BC0 2344      TST	R20
    00BC1 F6E1      BNE	0x0B9E
    00BC2 9149      LD	R20,Y+
    00BC3 90A9      LD	R10,Y+
    00BC4 9508      RET
_read_temperature:
  temp                 --> R10
    00BC5 92AA      ST	-Y,R10
(0063)    }
(0064) }
(0065) 
(0066) 
(0067) unsigned char read_temperature(void)
(0068) {
(0069)   unsigned char temp;
(0070)   if(init_ds18b20()!=0x00)
    00BC6 DF82      RCALL	_init_ds18b20
    00BC7 2300      TST	R16
    00BC8 F021      BEQ	0x0BCD
(0071)      ds18b20_error=1;            //DS18B20发生故障
    00BC9 E081      LDI	R24,1
    00BCA 9380 0264 STS	ds18b20_error,R24
    00BCC C013      RJMP	0x0BE0
(0072)  else
(0073)  {
(0074) 
(0075)    writeonebyte(0xCC);           //跳过序列号匹配
    00BCD EC0C      LDI	R16,0xCC
    00BCE DFCA      RCALL	_writeonebyte
(0076)    writeonebyte(0x44);           //启动测温
    00BCF E404      LDI	R16,0x44
    00BD0 DFC8      RCALL	_writeonebyte
(0077)    init_ds18b20();
    00BD1 DF77      RCALL	_init_ds18b20
(0078)    writeonebyte(0xCC);
    00BD2 EC0C      LDI	R16,0xCC
    00BD3 DFC5      RCALL	_writeonebyte
(0079)    writeonebyte(0xBE);           //读取温度寄存器
    00BD4 EB0E      LDI	R16,0xBE
    00BD5 DFC3      RCALL	_writeonebyte
(0080)    temp_value[0]=readonebyte();  //温度低8位
    00BD6 DF98      RCALL	_readonebyte
    00BD7 9300 0265 STS	temp_value,R16
(0081)    temp_value[1]=readonebyte();  //温度高8位
    00BD9 DF95      RCALL	_readonebyte
    00BDA 2EA0      MOV	R10,R16
    00BDB 92A0 0266 STS	temp_value+1,R10
(0082)    ds18b20_error=0;
    00BDD 2422      CLR	R2
    00BDE 9220 0264 STS	ds18b20_error,R2
(0083)    
(0084)  }
(0085)  temp=temp_value[1];
    00BE0 90A0 0266 LDS	R10,temp_value+1
(0086)  return temp;
    00BE2 2D0A      MOV	R16,R10
    00BE3 90A9      LD	R10,Y+
    00BE4 9508      RET
_convert_temp_data:
  ng                   --> R20
    00BE5 934A      ST	-Y,R20
(0087) }
(0088) 
(0089) //温度转换
(0090) void convert_temp_data(void)
(0091) {
(0092)    unsigned char ng=0;
    00BE6 2744      CLR	R20
(0093)           
(0094)   if((temp_value[1]&0xF8)==0xF8) //判断温度的正负
    00BE7 9180 0266 LDS	R24,temp_value+1
    00BE9 7F88      ANDI	R24,0xF8
    00BEA 3F88      CPI	R24,0xF8
    00BEB F491      BNE	0x0BFE
(0095)   {
(0096)     temp_value[1]=~temp_value[1];
    00BEC 9020 0266 LDS	R2,temp_value+1
    00BEE 9420      COM	R2
    00BEF 9220 0266 STS	temp_value+1,R2
(0097) 	temp_value[0]=~temp_value[0]+1;
    00BF1 9180 0265 LDS	R24,temp_value
    00BF3 9580      COM	R24
    00BF4 5F8F      SUBI	R24,0xFF
    00BF5 9380 0265 STS	temp_value,R24
(0098) 	if(temp_value[0]==0x00) temp_value[1]++;
    00BF7 2388      TST	R24
    00BF8 F421      BNE	0x0BFD
    00BF9 2D82      MOV	R24,R2
    00BFA 5F8F      SUBI	R24,0xFF
    00BFB 9380 0266 STS	temp_value+1,R24
(0099) 	ng=1;                        //负数标志
    00BFD E041      LDI	R20,1
(0100)   }
(0101)   
(0102)   display_digit[0]=df_table[temp_value[0]&0x0F];    //温度小数部分
    00BFE E584      LDI	R24,0x54
    00BFF E092      LDI	R25,2
    00C00 91E0 0265 LDS	R30,temp_value
    00C02 27FF      CLR	R31
    00C03 70EF      ANDI	R30,0xF
    00C04 70F0      ANDI	R31,0
    00C05 0FE8      ADD	R30,R24
    00C06 1FF9      ADC	R31,R25
    00C07 8020      LD	R2,Z
    00C08 9220 0267 STS	display_digit,R2
(0103)   currentT=(temp_value[0]>>4)|(temp_value[1]<<4); //温度数值
    00C0A 9180 0266 LDS	R24,temp_value+1
    00C0C 708F      ANDI	R24,0xF
    00C0D 9582      SWAP	R24
    00C0E 9190 0265 LDS	R25,temp_value
    00C10 9592      SWAP	R25
    00C11 709F      ANDI	R25,0xF
    00C12 2B98      OR	R25,R24
    00C13 9390 0253 STS	currentT,R25
(0104)   
(0105)   display_digit[3]=currentT/100;                    //温度百位
    00C15 E614      LDI	R17,0x64
    00C16 2F09      MOV	R16,R25
    00C17 940E 0CF8 CALL	div8u
    00C19 9300 026A STS	display_digit+3,R16
(0106)   display_digit[2]=currentT%100/10;                 //温度十位
    00C1B E614      LDI	R17,0x64
    00C1C 9100 0253 LDS	R16,currentT
    00C1E 940E 0CF6 CALL	mod8u
    00C20 E01A      LDI	R17,0xA
    00C21 940E 0CF8 CALL	div8u
    00C23 9300 0269 STS	display_digit+2,R16
(0107)   display_digit[1]=currentT%10;                     //温度个位
    00C25 E01A      LDI	R17,0xA
    00C26 9100 0253 LDS	R16,currentT
    00C28 940E 0CF6 CALL	mod8u
    00C2A 9300 0268 STS	display_digit+1,R16
(0108)   
(0109)   //温度显示预操作
(0110)   current_temp_display_buffer[11]=display_digit[0]+'0';
    00C2C 9180 0267 LDS	R24,display_digit
    00C2E 5D80      SUBI	R24,0xD0
    00C2F 9380 024F STS	current_temp_display_buffer+11,R24
(0111)   current_temp_display_buffer[10]='.';
    00C31 E28E      LDI	R24,0x2E
    00C32 9380 024E STS	current_temp_display_buffer+10,R24
(0112)   current_temp_display_buffer[9]=display_digit[1]+'0';
    00C34 2F80      MOV	R24,R16
    00C35 5D80      SUBI	R24,0xD0
    00C36 9380 024D STS	current_temp_display_buffer+9,R24
(0113)   current_temp_display_buffer[8]=display_digit[2]+'0';
    00C38 9180 0269 LDS	R24,display_digit+2
    00C3A 5D80      SUBI	R24,0xD0
    00C3B 9380 024C STS	current_temp_display_buffer+8,R24
(0114)   if(display_digit[3]!=0)
    00C3D 9020 026A LDS	R2,display_digit+3
    00C3F 2022      TST	R2
    00C40 F029      BEQ	0x0C46
(0115)   current_temp_display_buffer[7]=display_digit[3]+'0';
    00C41 2D82      MOV	R24,R2
    00C42 5D80      SUBI	R24,0xD0
    00C43 9380 024B STS	current_temp_display_buffer+7,R24
    00C45 C003      RJMP	0x0C49
(0116)   else
(0117)   current_temp_display_buffer[7]=' ';
    00C46 E280      LDI	R24,0x20
    00C47 9380 024B STS	current_temp_display_buffer+7,R24
(0118)   if(display_digit[2]==0 && display_digit[1]==0)
    00C49 9020 0269 LDS	R2,display_digit+2
    00C4B 2022      TST	R2
    00C4C F439      BNE	0x0C54
    00C4D 9020 0268 LDS	R2,display_digit+1
    00C4F 2022      TST	R2
    00C50 F419      BNE	0x0C54
(0119)   current_temp_display_buffer[8]=' ';
    00C51 E280      LDI	R24,0x20
    00C52 9380 024C STS	current_temp_display_buffer+8,R24
(0120)   if(ng)                                       //温度为负
    00C54 2344      TST	R20
    00C55 F099      BEQ	0x0C69
(0121)   {
(0122)     if(current_temp_display_buffer[8]==' ')
    00C56 9180 024C LDS	R24,current_temp_display_buffer+8
    00C58 3280      CPI	R24,0x20
    00C59 F421      BNE	0x0C5E
(0123) 	   current_temp_display_buffer[8]='-';
    00C5A E28D      LDI	R24,0x2D
    00C5B 9380 024C STS	current_temp_display_buffer+8,R24
    00C5D C00B      RJMP	0x0C69
(0124) 	else  
(0125)     if(current_temp_display_buffer[7]==' ')
    00C5E 9180 024B LDS	R24,current_temp_display_buffer+7
    00C60 3280      CPI	R24,0x20
    00C61 F421      BNE	0x0C66
(0126) 	   current_temp_display_buffer[7]='-';
    00C62 E28D      LDI	R24,0x2D
    00C63 9380 024B STS	current_temp_display_buffer+7,R24
    00C65 C003      RJMP	0x0C69
(0127) 	else  
(0128) 	   current_temp_display_buffer[6]='-';
    00C66 E28D      LDI	R24,0x2D
    00C67 9380 024A STS	current_temp_display_buffer+6,R24
(0129)   }
FILE: <library>
    00C69 9149      LD	R20,Y+
    00C6A 9508      RET
push_arg4:
    00C6B 933A      ST	-Y,R19
    00C6C 932A      ST	-Y,R18
push_arg2:
    00C6D 931A      ST	-Y,R17
    00C6E 930A      ST	-Y,R16
    00C6F 9508      RET
mod16u:
    00C70 9468      BSET	6
    00C71 C001      RJMP	xdiv16u
div16u:
    00C72 94E8      BCLR	6
xdiv16u:
    00C73 92EA      ST	-Y,R14
    00C74 92FA      ST	-Y,R15
    00C75 938A      ST	-Y,R24
    00C76 24EE      CLR	R14
    00C77 24FF      CLR	R15
    00C78 E180      LDI	R24,0x10
    00C79 0F00      LSL	R16
    00C7A 1F11      ROL	R17
    00C7B 1CEE      ROL	R14
    00C7C 1CFF      ROL	R15
    00C7D 16E2      CP	R14,R18
    00C7E 06F3      CPC	R15,R19
    00C7F F018      BCS	0x0C83
    00C80 1AE2      SUB	R14,R18
    00C81 0AF3      SBC	R15,R19
    00C82 9503      INC	R16
    00C83 958A      DEC	R24
    00C84 F7A1      BNE	0x0C79
    00C85 F416      BRTC	0x0C88
    00C86 2D0E      MOV	R16,R14
    00C87 2D1F      MOV	R17,R15
    00C88 9189      LD	R24,Y+
    00C89 90F9      LD	R15,Y+
    00C8A 90E9      LD	R14,Y+
    00C8B 9508      RET
div32u:
    00C8C 94E8      BCLR	6
    00C8D C001      RJMP	0x0C8F
mod32u:
    00C8E 9468      BSET	6
    00C8F D030      RCALL	long_div_prolog
    00C90 24CC      CLR	R12
    00C91 C009      RJMP	0x0C9B
div32s:
    00C92 94E8      BCLR	6
    00C93 C001      RJMP	0x0C95
mod32s:
    00C94 9468      BSET	6
    00C95 D02A      RCALL	long_div_prolog
    00C96 FD37      SBRC	R19,7
    00C97 940E 0D91 CALL	neg32
    00C99 FDB7      SBRC	R27,7
    00C9A D052      RCALL	neg_R24_R27
    00C9B 2477      CLR	R7
    00C9C 2488      CLR	R8
    00C9D 2499      CLR	R9
    00C9E 24AA      CLR	R10
    00C9F 24BB      CLR	R11
    00CA0 D042      RCALL	tst_R16_R19
    00CA1 F0C1      BEQ	0x0CBA
    00CA2 D045      RCALL	tst_R24_R27
    00CA3 F0B1      BEQ	0x0CBA
    00CA4 E2E8      LDI	R30,0x28
    00CA5 0F00      LSL	R16
    00CA6 1F11      ROL	R17
    00CA7 1F22      ROL	R18
    00CA8 1F33      ROL	R19
    00CA9 1C77      ROL	R7
    00CAA 1C88      ROL	R8
    00CAB 1C99      ROL	R9
    00CAC 1CAA      ROL	R10
    00CAD 1CBB      ROL	R11
    00CAE 1688      CP	R8,R24
    00CAF 0699      CPC	R9,R25
    00CB0 06AA      CPC	R10,R26
    00CB1 06BB      CPC	R11,R27
    00CB2 F028      BCS	0x0CB8
    00CB3 1A88      SUB	R8,R24
    00CB4 0A99      SBC	R9,R25
    00CB5 0AAA      SBC	R10,R26
    00CB6 0ABB      SBC	R11,R27
    00CB7 9503      INC	R16
    00CB8 95EA      DEC	R30
    00CB9 F759      BNE	0x0CA5
    00CBA F426      BRTC	0x0CBF
    00CBB 2D08      MOV	R16,R8
    00CBC 2D19      MOV	R17,R9
    00CBD 2D2A      MOV	R18,R10
    00CBE 2D3B      MOV	R19,R11
    00CBF C013      RJMP	long_div_epilog
long_div_prolog:
    00CC0 927A      ST	-Y,R7
    00CC1 928A      ST	-Y,R8
    00CC2 929A      ST	-Y,R9
    00CC3 92AA      ST	-Y,R10
    00CC4 92BA      ST	-Y,R11
    00CC5 92CA      ST	-Y,R12
    00CC6 93EA      ST	-Y,R30
    00CC7 938A      ST	-Y,R24
    00CC8 939A      ST	-Y,R25
    00CC9 93AA      ST	-Y,R26
    00CCA 93BA      ST	-Y,R27
    00CCB 858B      LDD	R24,Y+11
    00CCC 859C      LDD	R25,Y+12
    00CCD 85AD      LDD	R26,Y+13
    00CCE 85BE      LDD	R27,Y+14
    00CCF 2EC3      MOV	R12,R19
    00CD0 F00E      BRTS	0x0CD2
    00CD1 26CB      EOR	R12,R27
    00CD2 9508      RET
long_div_epilog:
    00CD3 FCC7      SBRC	R12,7
    00CD4 940E 0D91 CALL	neg32
    00CD6 91B9      LD	R27,Y+
    00CD7 91A9      LD	R26,Y+
    00CD8 9199      LD	R25,Y+
    00CD9 9189      LD	R24,Y+
    00CDA 91E9      LD	R30,Y+
    00CDB 90C9      LD	R12,Y+
    00CDC 90B9      LD	R11,Y+
    00CDD 90A9      LD	R10,Y+
    00CDE 9099      LD	R9,Y+
    00CDF 9089      LD	R8,Y+
    00CE0 9079      LD	R7,Y+
    00CE1 9624      ADIW	R28,4
    00CE2 9508      RET
tst_R16_R19:
    00CE3 2FE0      MOV	R30,R16
    00CE4 2BE1      OR	R30,R17
    00CE5 2BE2      OR	R30,R18
    00CE6 2BE3      OR	R30,R19
    00CE7 9508      RET
tst_R24_R27:
    00CE8 2FE8      MOV	R30,R24
    00CE9 2BE9      OR	R30,R25
    00CEA 2BEA      OR	R30,R26
    00CEB 2BEB      OR	R30,R27
    00CEC 9508      RET
neg_R24_R27:
    00CED 9580      COM	R24
    00CEE 9590      COM	R25
    00CEF 95A0      COM	R26
    00CF0 95B0      COM	R27
    00CF1 5F8F      SUBI	R24,0xFF
    00CF2 4F9F      SBCI	R25,0xFF
    00CF3 4FAF      SBCI	R26,0xFF
    00CF4 4FBF      SBCI	R27,0xFF
    00CF5 9508      RET
mod8u:
    00CF6 9468      BSET	6
    00CF7 C001      RJMP	xdiv8u
div8u:
    00CF8 94E8      BCLR	6
xdiv8u:
    00CF9 932A      ST	-Y,R18
    00CFA 92FA      ST	-Y,R15
    00CFB 92EA      ST	-Y,R14
    00CFC 24FF      CLR	R15
    00CFD 24EE      CLR	R14
    00CFE E120      LDI	R18,0x10
    00CFF 0F00      LSL	R16
    00D00 1CFF      ROL	R15
    00D01 1CEE      ROL	R14
    00D02 16E1      CP	R14,R17
    00D03 F010      BCS	0x0D06
    00D04 1AE1      SUB	R14,R17
    00D05 9503      INC	R16
    00D06 952A      DEC	R18
    00D07 F7B9      BNE	0x0CFF
    00D08 F40E      BRTC	0x0D0A
    00D09 2D0E      MOV	R16,R14
    00D0A 90E9      LD	R14,Y+
    00D0B 90F9      LD	R15,Y+
    00D0C 9129      LD	R18,Y+
    00D0D 9508      RET
elpm32:
    00D0E 93EA      ST	-Y,R30
    00D0F 93FA      ST	-Y,R31
    00D10 920A      ST	-Y,R0
    00D11 2FE0      MOV	R30,R16
    00D12 2FF1      MOV	R31,R17
    00D13 95D8      ELPM
    00D14 2D00      MOV	R16,R0
    00D15 9631      ADIW	R30,1
    00D16 95D8      ELPM
    00D17 2D10      MOV	R17,R0
    00D18 9631      ADIW	R30,1
    00D19 95D8      ELPM
    00D1A 2D20      MOV	R18,R0
    00D1B 9631      ADIW	R30,1
    00D1C 95D8      ELPM
    00D1D 2D30      MOV	R19,R0
    00D1E 9009      LD	R0,Y+
    00D1F 91F9      LD	R31,Y+
    00D20 91E9      LD	R30,Y+
    00D21 9508      RET
empy16s:
    00D22 920A      ST	-Y,R0
    00D23 921A      ST	-Y,R1
    00D24 938A      ST	-Y,R24
    00D25 939A      ST	-Y,R25
    00D26 9F02      MUL	R16,R18
    00D27 01C0      MOVW	R24,R0
    00D28 9F12      MUL	R17,R18
    00D29 0D90      ADD	R25,R0
    00D2A 9F03      MUL	R16,R19
    00D2B 0D90      ADD	R25,R0
    00D2C 018C      MOVW	R16,R24
    00D2D 9199      LD	R25,Y+
    00D2E 9189      LD	R24,Y+
    00D2F 9019      LD	R1,Y+
    00D30 9009      LD	R0,Y+
    00D31 9508      RET
pop_xgset003C:
    00D32 90A9      LD	R10,Y+
    00D33 90B9      LD	R11,Y+
    00D34 90C9      LD	R12,Y+
    00D35 90D9      LD	R13,Y+
    00D36 9508      RET
pop_xgset00FC:
    00D37 90A9      LD	R10,Y+
    00D38 90B9      LD	R11,Y+
    00D39 90C9      LD	R12,Y+
    00D3A 90D9      LD	R13,Y+
    00D3B 90E9      LD	R14,Y+
    00D3C 90F9      LD	R15,Y+
    00D3D 9508      RET
pop_xgset30FC:
    00D3E 90A9      LD	R10,Y+
    00D3F 90B9      LD	R11,Y+
    00D40 90C9      LD	R12,Y+
    00D41 90D9      LD	R13,Y+
    00D42 90E9      LD	R14,Y+
    00D43 90F9      LD	R15,Y+
    00D44 9149      LD	R20,Y+
    00D45 9159      LD	R21,Y+
    00D46 9508      RET
pop_xgsetF0FC:
    00D47 90A9      LD	R10,Y+
    00D48 90B9      LD	R11,Y+
    00D49 90C9      LD	R12,Y+
    00D4A 90D9      LD	R13,Y+
    00D4B 90E9      LD	R14,Y+
    00D4C 90F9      LD	R15,Y+
    00D4D 9149      LD	R20,Y+
    00D4E 9159      LD	R21,Y+
    00D4F 9169      LD	R22,Y+
    00D50 9179      LD	R23,Y+
    00D51 9508      RET
push_xgsetF0FC:
    00D52 937A      ST	-Y,R23
    00D53 936A      ST	-Y,R22
push_xgset30FC:
    00D54 935A      ST	-Y,R21
    00D55 934A      ST	-Y,R20
push_xgset00FC:
    00D56 92FA      ST	-Y,R15
    00D57 92EA      ST	-Y,R14
push_xgset003C:
    00D58 92DA      ST	-Y,R13
    00D59 92CA      ST	-Y,R12
    00D5A 92BA      ST	-Y,R11
    00D5B 92AA      ST	-Y,R10
    00D5C 9508      RET
push_xgset300C:
    00D5D 935A      ST	-Y,R21
    00D5E 934A      ST	-Y,R20
    00D5F 92BA      ST	-Y,R11
    00D60 92AA      ST	-Y,R10
    00D61 9508      RET
pop_xgset300C:
    00D62 90A9      LD	R10,Y+
    00D63 90B9      LD	R11,Y+
    00D64 9149      LD	R20,Y+
    00D65 9159      LD	R21,Y+
    00D66 9508      RET
push_xgsetF000:
    00D67 937A      ST	-Y,R23
    00D68 936A      ST	-Y,R22
    00D69 935A      ST	-Y,R21
    00D6A 934A      ST	-Y,R20
    00D6B 9508      RET
pop_xgsetF000:
    00D6C 9149      LD	R20,Y+
    00D6D 9159      LD	R21,Y+
    00D6E 9169      LD	R22,Y+
    00D6F 9179      LD	R23,Y+
    00D70 9508      RET
push_xgsetF00C:
    00D71 937A      ST	-Y,R23
    00D72 936A      ST	-Y,R22
    00D73 935A      ST	-Y,R21
    00D74 934A      ST	-Y,R20
    00D75 92BA      ST	-Y,R11
    00D76 92AA      ST	-Y,R10
    00D77 9508      RET
pop_xgsetF00C:
    00D78 90A9      LD	R10,Y+
    00D79 90B9      LD	R11,Y+
    00D7A 9149      LD	R20,Y+
    00D7B 9159      LD	R21,Y+
    00D7C 9169      LD	R22,Y+
    00D7D 9179      LD	R23,Y+
    00D7E 9508      RET
push_xgsetF03C:
    00D7F 937A      ST	-Y,R23
    00D80 936A      ST	-Y,R22
    00D81 935A      ST	-Y,R21
    00D82 934A      ST	-Y,R20
    00D83 92DA      ST	-Y,R13
    00D84 92CA      ST	-Y,R12
    00D85 92BA      ST	-Y,R11
    00D86 92AA      ST	-Y,R10
    00D87 9508      RET
pop_xgsetF03C:
    00D88 90A9      LD	R10,Y+
    00D89 90B9      LD	R11,Y+
    00D8A 90C9      LD	R12,Y+
    00D8B 90D9      LD	R13,Y+
    00D8C 9149      LD	R20,Y+
    00D8D 9159      LD	R21,Y+
    00D8E 9169      LD	R22,Y+
    00D8F 9179      LD	R23,Y+
    00D90 9508      RET
neg32:
    00D91 9500      COM	R16
    00D92 9510      COM	R17
    00D93 9520      COM	R18
    00D94 9530      COM	R19
    00D95 5F0F      SUBI	R16,0xFF
    00D96 4F1F      SBCI	R17,0xFF
    00D97 4F2F      SBCI	R18,0xFF
    00D98 4F3F      SBCI	R19,0xFF
    00D99 9508      RET
lsl32:
    00D9A 920F      PUSH	R0
    00D9B 9009      LD	R0,Y+
    00D9C 2000      TST	R0
    00D9D F031      BEQ	0x0DA4
    00D9E 0F00      LSL	R16
    00D9F 1F11      ROL	R17
    00DA0 1F22      ROL	R18
    00DA1 1F33      ROL	R19
    00DA2 940A      DEC	R0
    00DA3 CFF8      RJMP	0x0D9C
    00DA4 900F      POP	R0
    00DA5 9508      RET
lsl8:
    00DA6 2311      TST	R17
    00DA7 F019      BEQ	0x0DAB
    00DA8 0F00      LSL	R16
    00DA9 951A      DEC	R17
    00DAA CFFB      RJMP	lsl8
    00DAB 9508      RET
fpsub:
    00DAC 9468      BSET	6
    00DAD C001      RJMP	fpadd_alt
fpadd:
    00DAE 94E8      BCLR	6
fpadd_alt:
    00DAF 940E 0EC1 CALL	saveFPRegs
    00DB1 940E 0E53 CALL	unpacks
    00DB3 F409      BNE	0x0DB5
    00DB4 C048      RJMP	0x0DFD
    00DB5 2CE6      MOV	R14,R6
    00DB6 2CD5      MOV	R13,R5
    00DB7 2CC4      MOV	R12,R4
    00DB8 2EB3      MOV	R11,R19
    00DB9 2EA2      MOV	R10,R18
    00DBA 2E91      MOV	R9,R17
    00DBB 2E80      MOV	R8,R16
    00DBC 8100      LD	R16,Z
    00DBD 8111      LDD	R17,Z+1
    00DBE 8122      LDD	R18,Z+2
    00DBF 8133      LDD	R19,Z+3
    00DC0 940E 0E53 CALL	unpacks
    00DC2 F409      BNE	0x0DC4
    00DC3 C044      RJMP	0x0E08
    00DC4 2D84      MOV	R24,R4
    00DC5 2D95      MOV	R25,R5
    00DC6 198C      SUB	R24,R12
    00DC7 099D      SBC	R25,R13
    00DC8 F0B9      BEQ	0x0DE0
    00DC9 F472      BPL	0x0DD8
    00DCA 9590      COM	R25
    00DCB 9580      COM	R24
    00DCC 9601      ADIW	R24,1
    00DCD 2C4C      MOV	R4,R12
    00DCE 2C5D      MOV	R5,R13
    00DCF 3188      CPI	R24,0x18
    00DD0 F5B8      BCC	0x0E08
    00DD1 9535      ASR	R19
    00DD2 9527      ROR	R18
    00DD3 9517      ROR	R17
    00DD4 9507      ROR	R16
    00DD5 9701      SBIW	R24,1
    00DD6 F7D1      BNE	0x0DD1
    00DD7 C008      RJMP	0x0DE0
    00DD8 3188      CPI	R24,0x18
    00DD9 F518      BCC	0x0DFD
    00DDA 94B5      ASR	R11
    00DDB 94A7      ROR	R10
    00DDC 9497      ROR	R9
    00DDD 9487      ROR	R8
    00DDE 9701      SBIW	R24,1
    00DDF F7D1      BNE	0x0DDA
    00DE0 2466      CLR	R6
    00DE1 F02E      BRTS	0x0DE7
    00DE2 0D08      ADD	R16,R8
    00DE3 1D19      ADC	R17,R9
    00DE4 1D2A      ADC	R18,R10
    00DE5 1D3B      ADC	R19,R11
    00DE6 C009      RJMP	0x0DF0
    00DE7 1A80      SUB	R8,R16
    00DE8 0A91      SBC	R9,R17
    00DE9 0AA2      SBC	R10,R18
    00DEA 0AB3      SBC	R11,R19
    00DEB 2D08      MOV	R16,R8
    00DEC 2D19      MOV	R17,R9
    00DED 2D2A      MOV	R18,R10
    00DEE 2D3B      MOV	R19,R11
    00DEF 2333      TST	R19
    00DF0 F422      BPL	0x0DF5
    00DF1 940E 0D91 CALL	neg32
    00DF3 E880      LDI	R24,0x80
    00DF4 2E68      MOV	R6,R24
    00DF5 940E 0E7C CALL	normalize_and_pack
    00DF7 C002      RJMP	0x0DFA
    00DF8 940E 0EB1 CALL	pack
    00DFA 940E 0ED0 CALL	restoreFPRegs
    00DFC 9508      RET
    00DFD 8100      LD	R16,Z
    00DFE 8111      LDD	R17,Z+1
    00DFF 8122      LDD	R18,Z+2
    00E00 8133      LDD	R19,Z+3
    00E01 F7C6      BRTC	0x0DFA
    00E02 940E 0E5B CALL	tstR16_R19
    00E04 F3A9      BEQ	0x0DFA
    00E05 E880      LDI	R24,0x80
    00E06 2738      EOR	R19,R24
    00E07 CFF2      RJMP	0x0DFA
    00E08 2D08      MOV	R16,R8
    00E09 2D19      MOV	R17,R9
    00E0A 2D2A      MOV	R18,R10
    00E0B 2D3B      MOV	R19,R11
    00E0C 2C4C      MOV	R4,R12
    00E0D 2C5D      MOV	R5,R13
    00E0E 2C6E      MOV	R6,R14
    00E0F 2333      TST	R19
    00E10 F73A      BPL	0x0DF8
    00E11 940E 0D91 CALL	neg32
    00E13 E880      LDI	R24,0x80
    00E14 2E68      MOV	R6,R24
    00E15 CFE2      RJMP	0x0DF8
fpadd2:
    00E16 93FA      ST	-Y,R31
    00E17 93EA      ST	-Y,R30
    00E18 2FEC      MOV	R30,R28
    00E19 2FFD      MOV	R31,R29
    00E1A 9632      ADIW	R30,2
    00E1B 940E 0DAE CALL	fpadd
    00E1D 91E9      LD	R30,Y+
    00E1E 91F9      LD	R31,Y+
    00E1F 9624      ADIW	R28,4
    00E20 9508      RET
fpint:
    00E21 924A      ST	-Y,R4
    00E22 925A      ST	-Y,R5
    00E23 926A      ST	-Y,R6
    00E24 938A      ST	-Y,R24
    00E25 940E 0E63 CALL	unpacku
    00E27 F111      BEQ	0x0E4A
    00E28 2055      TST	R5
    00E29 F0E2      BMI	0x0E46
    00E2A E18F      LDI	R24,0x1F
    00E2B 1648      CP	R4,R24
    00E2C F4C0      BCC	0x0E45
    00E2D E187      LDI	R24,0x17
    00E2E 1648      CP	R4,R24
    00E2F F0D1      BEQ	0x0E4A
    00E30 F458      BCC	0x0E3C
    00E31 9441      NEG	R4
    00E32 EE89      LDI	R24,0xE9
    00E33 1A48      SUB	R4,R24
    00E34 C005      RJMP	0x0E3A
    00E35 9535      ASR	R19
    00E36 9527      ROR	R18
    00E37 9517      ROR	R17
    00E38 9507      ROR	R16
    00E39 944A      DEC	R4
    00E3A F7D1      BNE	0x0E35
    00E3B C00E      RJMP	0x0E4A
    00E3C E187      LDI	R24,0x17
    00E3D 1A48      SUB	R4,R24
    00E3E 0F00      LSL	R16
    00E3F 1F11      ROL	R17
    00E40 1F22      ROL	R18
    00E41 1F33      ROL	R19
    00E42 944A      DEC	R4
    00E43 F7D1      BNE	0x0E3E
    00E44 C005      RJMP	0x0E4A
    00E45 E73F      LDI	R19,0x7F
    00E46 2F23      MOV	R18,R19
    00E47 2F13      MOV	R17,R19
    00E48 2F03      MOV	R16,R19
    00E49 C004      RJMP	0x0E4E
    00E4A 2066      TST	R6
    00E4B F011      BEQ	0x0E4E
    00E4C 940E 0D91 CALL	neg32
    00E4E 9189      LD	R24,Y+
    00E4F 9069      LD	R6,Y+
    00E50 9059      LD	R5,Y+
    00E51 9049      LD	R4,Y+
    00E52 9508      RET
unpacks:
    00E53 D00F      RCALL	unpacku
    00E54 F029      BEQ	0x0E5A
    00E55 2066      TST	R6
    00E56 F011      BEQ	0x0E59
    00E57 940E 0D91 CALL	neg32
    00E59 9498      BCLR	1
    00E5A 9508      RET
tstR16_R19:
    00E5B 2300      TST	R16
    00E5C F429      BNE	0x0E62
    00E5D 2311      TST	R17
    00E5E F419      BNE	0x0E62
    00E5F 2322      TST	R18
    00E60 F409      BNE	0x0E62
    00E61 2333      TST	R19
    00E62 9508      RET
unpacku:
    00E63 DFF7      RCALL	tstR16_R19
    00E64 F099      BEQ	0x0E78
    00E65 938A      ST	-Y,R24
    00E66 2E63      MOV	R6,R19
    00E67 E880      LDI	R24,0x80
    00E68 2268      AND	R6,R24
    00E69 0F22      LSL	R18
    00E6A 1F33      ROL	R19
    00E6B 2E43      MOV	R4,R19
    00E6C E78F      LDI	R24,0x7F
    00E6D 1A48      SUB	R4,R24
    00E6E 2455      CLR	R5
    00E6F 2788      CLR	R24
    00E70 0A58      SBC	R5,R24
    00E71 9526      LSR	R18
    00E72 E830      LDI	R19,0x80
    00E73 2B23      OR	R18,R19
    00E74 2733      CLR	R19
    00E75 9189      LD	R24,Y+
    00E76 9498      BCLR	1
    00E77 9508      RET
    00E78 2444      CLR	R4
    00E79 2455      CLR	R5
    00E7A 2466      CLR	R6
    00E7B 9508      RET
normalize_and_pack:
    00E7C DFDE      RCALL	tstR16_R19
    00E7D F409      BNE	0x0E7F
    00E7E 9508      RET
    00E7F 93AA      ST	-Y,R26
    00E80 93BA      ST	-Y,R27
    00E81 01D2      MOVW	R26,R4
    00E82 939A      ST	-Y,R25
    00E83 938A      ST	-Y,R24
    00E84 E78E      LDI	R24,0x7E
    00E85 E090      LDI	R25,0
    00E86 2333      TST	R19
    00E87 F049      BEQ	0x0E91
    00E88 9536      LSR	R19
    00E89 9527      ROR	R18
    00E8A 9517      ROR	R17
    00E8B 9507      ROR	R16
    00E8C 17A8      CP	R26,R24
    00E8D 07B9      CPC	R27,R25
    00E8E F4CC      BGE	0x0EA8
    00E8F 9611      ADIW	R26,1
    00E90 CFF5      RJMP	0x0E86
    00E91 9580      COM	R24
    00E92 9590      COM	R25
    00E93 9601      ADIW	R24,1
    00E94 2322      TST	R18
    00E95 F0BA      BMI	0x0EAD
    00E96 0F00      LSL	R16
    00E97 1F11      ROL	R17
    00E98 1F22      ROL	R18
    00E99 17A8      CP	R26,R24
    00E9A 07B9      CPC	R27,R25
    00E9B F014      BLT	0x0E9E
    00E9C 9711      SBIW	R26,1
    00E9D CFF6      RJMP	0x0E94
    00E9E 2700      CLR	R16
    00E9F 2711      CLR	R17
    00EA0 2722      CLR	R18
    00EA1 2733      CLR	R19
    00EA2 9189      LD	R24,Y+
    00EA3 9199      LD	R25,Y+
    00EA4 012D      MOVW	R4,R26
    00EA5 91B9      LD	R27,Y+
    00EA6 91A9      LD	R26,Y+
    00EA7 9508      RET
    00EA8 2733      CLR	R19
    00EA9 EF0F      LDI	R16,0xFF
    00EAA 2F10      MOV	R17,R16
    00EAB E72F      LDI	R18,0x7F
    00EAC 2F32      MOV	R19,R18
    00EAD 9189      LD	R24,Y+
    00EAE 9199      LD	R25,Y+
    00EAF 012D      MOVW	R4,R26
    00EB0 C002      RJMP	0x0EB3
pack:
    00EB1 93AA      ST	-Y,R26
    00EB2 93BA      ST	-Y,R27
    00EB3 DFA7      RCALL	tstR16_R19
    00EB4 F049      BEQ	0x0EBE
    00EB5 01D2      MOVW	R26,R4
    00EB6 58A1      SUBI	R26,0x81
    00EB7 4FBF      SBCI	R27,0xFF
    00EB8 012D      MOVW	R4,R26
    00EB9 2D34      MOV	R19,R4
    00EBA 0F22      LSL	R18
    00EBB 9536      LSR	R19
    00EBC 9527      ROR	R18
    00EBD 2936      OR	R19,R6
    00EBE 91B9      LD	R27,Y+
    00EBF 91A9      LD	R26,Y+
    00EC0 9508      RET
saveFPRegs:
    00EC1 924A      ST	-Y,R4
    00EC2 925A      ST	-Y,R5
    00EC3 926A      ST	-Y,R6
    00EC4 927A      ST	-Y,R7
    00EC5 928A      ST	-Y,R8
    00EC6 929A      ST	-Y,R9
    00EC7 92AA      ST	-Y,R10
    00EC8 92BA      ST	-Y,R11
    00EC9 92CA      ST	-Y,R12
    00ECA 92DA      ST	-Y,R13
    00ECB 92EA      ST	-Y,R14
    00ECC 92FA      ST	-Y,R15
    00ECD 938A      ST	-Y,R24
    00ECE 939A      ST	-Y,R25
    00ECF 9508      RET
restoreFPRegs:
    00ED0 9199      LD	R25,Y+
    00ED1 9189      LD	R24,Y+
    00ED2 90F9      LD	R15,Y+
    00ED3 90E9      LD	R14,Y+
    00ED4 90D9      LD	R13,Y+
    00ED5 90C9      LD	R12,Y+
    00ED6 90B9      LD	R11,Y+
    00ED7 90A9      LD	R10,Y+
    00ED8 9099      LD	R9,Y+
    00ED9 9089      LD	R8,Y+
    00EDA 9079      LD	R7,Y+
    00EDB 9069      LD	R6,Y+
    00EDC 9059      LD	R5,Y+
    00EDD 9049      LD	R4,Y+
    00EDE 9508      RET
fpmule:
    00EDF 940E 0EC1 CALL	saveFPRegs
    00EE1 93AA      ST	-Y,R26
    00EE2 93BA      ST	-Y,R27
    00EE3 940E 0E63 CALL	unpacku
    00EE5 F1E1      BEQ	0x0F22
    00EE6 2CE6      MOV	R14,R6
    00EE7 2CD5      MOV	R13,R5
    00EE8 2CC4      MOV	R12,R4
    00EE9 2EB3      MOV	R11,R19
    00EEA 2EA2      MOV	R10,R18
    00EEB 2E91      MOV	R9,R17
    00EEC 2E80      MOV	R8,R16
    00EED 8100      LD	R16,Z
    00EEE 8111      LDD	R17,Z+1
    00EEF 8122      LDD	R18,Z+2
    00EF0 8133      LDD	R19,Z+3
    00EF1 940E 0E63 CALL	unpacku
    00EF3 F171      BEQ	0x0F22
    00EF4 246E      EOR	R6,R14
    00EF5 0C4C      ADD	R4,R12
    00EF6 1C5D      ADC	R5,R13
    00EF7 E880      LDI	R24,0x80
    00EF8 1648      CP	R4,R24
    00EF9 0653      CPC	R5,R19
    00EFA F564      BGE	0x0F27
    00EFB E881      LDI	R24,0x81
    00EFC 1648      CP	R4,R24
    00EFD EF8F      LDI	R24,0xFF
    00EFE 0658      CPC	R5,R24
    00EFF F16C      BLT	0x0F2D
    00F00 9EA2      MUL	R10,R18
    00F01 2DB1      MOV	R27,R1
    00F02 2DA0      MOV	R26,R0
    00F03 9E91      MUL	R9,R17
    00F04 2D91      MOV	R25,R1
    00F05 2D80      MOV	R24,R0
    00F06 9EA0      MUL	R10,R16
    00F07 0D80      ADD	R24,R0
    00F08 1D91      ADC	R25,R1
    00F09 1FA3      ADC	R26,R19
    00F0A 1FB3      ADC	R27,R19
    00F0B 9E82      MUL	R8,R18
    00F0C 0D80      ADD	R24,R0
    00F0D 1D91      ADC	R25,R1
    00F0E 1FA3      ADC	R26,R19
    00F0F 1FB3      ADC	R27,R19
    00F10 9E92      MUL	R9,R18
    00F11 0D90      ADD	R25,R0
    00F12 1DA1      ADC	R26,R1
    00F13 1FB3      ADC	R27,R19
    00F14 9EA1      MUL	R10,R17
    00F15 0D90      ADD	R25,R0
    00F16 1DA1      ADC	R26,R1
    00F17 1FB3      ADC	R27,R19
    00F18 2F2B      MOV	R18,R27
    00F19 2F1A      MOV	R17,R26
    00F1A 2F09      MOV	R16,R25
    00F1B 0F88      LSL	R24
    00F1C 1F00      ROL	R16
    00F1D 1F11      ROL	R17
    00F1E 1F22      ROL	R18
    00F1F 1F33      ROL	R19
    00F20 940E 0E7C CALL	normalize_and_pack
    00F22 91B9      LD	R27,Y+
    00F23 91A9      LD	R26,Y+
    00F24 940E 0ED0 CALL	restoreFPRegs
    00F26 9508      RET
    00F27 EF0F      LDI	R16,0xFF
    00F28 2F10      MOV	R17,R16
    00F29 E72F      LDI	R18,0x7F
    00F2A E78F      LDI	R24,0x7F
    00F2B 2E48      MOV	R4,R24
    00F2C CFF5      RJMP	0x0F22
    00F2D 2700      CLR	R16
    00F2E 2F10      MOV	R17,R16
    00F2F 2F20      MOV	R18,R16
    00F30 2F30      MOV	R19,R16
    00F31 CFF0      RJMP	0x0F22
fpmule1:
    00F32 93FA      ST	-Y,R31
    00F33 93EA      ST	-Y,R30
    00F34 81EA      LDD	R30,Y+2
    00F35 81FB      LDD	R31,Y+3
    00F36 940E 0EDF CALL	fpmule
    00F38 91E9      LD	R30,Y+
    00F39 91F9      LD	R31,Y+
    00F3A 9622      ADIW	R28,2
    00F3B 9508      RET
fpcmp:
    00F3C 940E 0DAC CALL	fpsub
    00F3E 2333      TST	R19
    00F3F F03A      BMI	0x0F47
    00F40 940E 0E5B CALL	tstR16_R19
    00F42 F011      BEQ	0x0F45
    00F43 E001      LDI	R16,1
    00F44 9508      RET
    00F45 2700      CLR	R16
    00F46 9508      RET
    00F47 EF0F      LDI	R16,0xFF
    00F48 9508      RET
fpcmp1:
    00F49 93FA      ST	-Y,R31
    00F4A 93EA      ST	-Y,R30
    00F4B 81EA      LDD	R30,Y+2
    00F4C 81FB      LDD	R31,Y+3
    00F4D 940E 0F3C CALL	fpcmp
    00F4F 91E9      LD	R30,Y+
    00F50 91F9      LD	R31,Y+
    00F51 9622      ADIW	R28,2
    00F52 2300      TST	R16
    00F53 9508      RET
