Interrupt Vectors
    00000 940C 00EB JMP	__start|__text_start
    00024 940C 0926 JMP	_uart0_rx_isr
    00028 940C 0997 JMP	_uart0_tx_isr

Program Code (text area)
__start|__text_start:
    000EB EFCF      LDI	R28,0xFF
    000EC E2D1      LDI	R29,0x21
    000ED BFCD      OUT	0x3D,R28
    000EE BFDE      OUT	0x3E,R29
    000EF 51CE      SUBI	R28,0x1E
    000F0 40D0      SBCI	R29,0
    000F1 EA0A      LDI	R16,0xAA
    000F2 8308      ST	Y,R16
    000F3 2400      CLR	R0
    000F4 EDE5      LDI	R30,0xD5
    000F5 E0F2      LDI	R31,2
    000F6 E013      LDI	R17,3
    000F7 3DE2      CPI	R30,0xD2
    000F8 07F1      CPC	R31,R17
    000F9 F011      BEQ	0x00FC
    000FA 9201      ST	Z+,R0
    000FB CFFB      RJMP	0x00F7
    000FC 8300      ST	Z,R16
    000FD E0E0      LDI	R30,0
    000FE E0F1      LDI	R31,1
    000FF E0A0      LDI	R26,0
    00100 E0B2      LDI	R27,2
    00101 E011      LDI	R17,1
    00102 E000      LDI	R16,0
    00103 BF0B      OUT	0x3B,R16
    00104 3DE5      CPI	R30,0xD5
    00105 07F1      CPC	R31,R17
    00106 F021      BEQ	0x010B
    00107 95C8      LPM
    00108 9631      ADIW	R30,1
    00109 920D      ST	X+,R0
    0010A CFF9      RJMP	0x0104
    0010B 940E 02CE CALL	_main
_exit:
    0010D CFFF      RJMP	_exit
_val_pc_to_msc:
  i                    --> R20
  t                    --> R16
    0010E 940E 0B0E CALL	push_xgset300C
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\main.c
(0001) /************************************************
(0002) 文件：main.c
(0003) 用途：
(0004) 注意：内部8M晶振
(0005) 创建：2008.4.1
(0006) 修改：2008.4.1
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) 
(0010) #include "config.h"
(0011) #include<time.h>
(0012) 
(0013) unsigned char tem[20];
(0014) unsigned char tem2[20];
(0015) unsigned char read_buf[20]="201110123000";
(0016) unsigned char out_buf[50]="201110095000";
(0017) unsigned char ind=0;
(0018) #define uint8 unsigned char
(0019) 
(0020) void val_pc_to_msc(unsigned char *t){/// string to bcd
(0021) 	 unsigned char i=0;
    00110 2744      CLR	R20
(0022) 	 for(ind=0;ind<6;++ind){  
    00111 2422      CLR	R2
    00112 9220 0246 STS	ind,R2
    00114 C02E      RJMP	0x0143
(0023) 	 	tem[ind]=(0xf0)&((t[2*ind]-'0'))<<4;
    00115 9020 0246 LDS	R2,ind
    00117 2DE2      MOV	R30,R2
    00118 27FF      CLR	R31
    00119 0FEE      LSL	R30
    0011A 1FFF      ROL	R31
    0011B 0FE0      ADD	R30,R16
    0011C 1FF1      ADC	R31,R17
    0011D 8180      LD	R24,Z
    0011E 5380      SUBI	R24,0x30
    0011F 708F      ANDI	R24,0xF
    00120 9582      SWAP	R24
    00121 7F80      ANDI	R24,0xF0
    00122 EEE9      LDI	R30,0xE9
    00123 E0F2      LDI	R31,2
    00124 2DA2      MOV	R26,R2
    00125 27BB      CLR	R27
    00126 0FAE      ADD	R26,R30
    00127 1FBF      ADC	R27,R31
    00128 938C      ST	X,R24
(0024) 		tem[ind]|=(0x0f)&(t[2*ind+1]-'0');
    00129 9020 0246 LDS	R2,ind
    0012B EE89      LDI	R24,0xE9
    0012C E092      LDI	R25,2
    0012D 2CA2      MOV	R10,R2
    0012E 24BB      CLR	R11
    0012F 0EA8      ADD	R10,R24
    00130 1EB9      ADC	R11,R25
    00131 2DE2      MOV	R30,R2
    00132 27FF      CLR	R31
    00133 0FEE      LSL	R30
    00134 1FFF      ROL	R31
    00135 0FE0      ADD	R30,R16
    00136 1FF1      ADC	R31,R17
    00137 8181      LDD	R24,Z+1
    00138 5380      SUBI	R24,0x30
    00139 708F      ANDI	R24,0xF
    0013A 01F5      MOVW	R30,R10
    0013B 8020      LD	R2,Z
    0013C 2A28      OR	R2,R24
    0013D 8220      ST	Z,R2
    0013E 9180 0246 LDS	R24,ind
    00140 5F8F      SUBI	R24,0xFF
    00141 9380 0246 STS	ind,R24
    00143 9180 0246 LDS	R24,ind
    00145 3086      CPI	R24,6
    00146 F408      BCC	0x0148
    00147 CFCD      RJMP	0x0115
(0025) 	 }
(0026) 	 for(i=0;i<6;++i){
    00148 2744      CLR	R20
    00149 C011      RJMP	0x015B
(0027) 	 	t[i]=tem[5-i];
    0014A 2E24      MOV	R2,R20
    0014B 2433      CLR	R3
    0014C E0E5      LDI	R30,5
    0014D E0F0      LDI	R31,0
    0014E 19E2      SUB	R30,R2
    0014F 09F3      SBC	R31,R3
    00150 EE89      LDI	R24,0xE9
    00151 E092      LDI	R25,2
    00152 0FE8      ADD	R30,R24
    00153 1FF9      ADC	R31,R25
    00154 8020      LD	R2,Z
    00155 2FE4      MOV	R30,R20
    00156 27FF      CLR	R31
    00157 0FE0      ADD	R30,R16
    00158 1FF1      ADC	R31,R17
    00159 8220      ST	Z,R2
    0015A 9543      INC	R20
    0015B 3046      CPI	R20,6
    0015C F368      BCS	0x014A
    0015D 940C 0B13 JMP	pop_xgset300C
_time_init:
  s                    --> R20
    0015F 934A      ST	-Y,R20
    00160 935A      ST	-Y,R21
    00161 01A8      MOVW	R20,R16
(0028) 	 }
(0029) }
(0030) 
(0031) 
(0032) 
(0033) 
(0034) void time_init(uint8 *s)// s is a string 
(0035) {
(0036) 
(0037)      	val_pc_to_msc(s);
    00162 018A      MOVW	R16,R20
    00163 DFAA      RCALL	_val_pc_to_msc
(0038)          pcf_set_byte(0x02,s[0]);         //秒
    00164 01FA      MOVW	R30,R20
    00165 8120      LD	R18,Z
    00166 2733      CLR	R19
    00167 E002      LDI	R16,2
    00168 940E 03F9 CALL	_pcf_set_byte
(0039)          pcf_set_byte(0x03,s[1]);         //分钟    
    0016A 01FA      MOVW	R30,R20
    0016B 8121      LDD	R18,Z+1
    0016C 2733      CLR	R19
    0016D E003      LDI	R16,3
    0016E 940E 03F9 CALL	_pcf_set_byte
(0040)          pcf_set_byte(0x04,s[2]);          //时             
    00170 01FA      MOVW	R30,R20
    00171 8122      LDD	R18,Z+2
    00172 2733      CLR	R19
    00173 E004      LDI	R16,4
    00174 940E 03F9 CALL	_pcf_set_byte
(0041)          pcf_set_byte(0x05,s[3]);          //日
    00176 01FA      MOVW	R30,R20
    00177 8123      LDD	R18,Z+3
    00178 2733      CLR	R19
    00179 E005      LDI	R16,5
    0017A 940E 03F9 CALL	_pcf_set_byte
(0042)          pcf_set_byte(0x06,0x00);          //星期
    0017C 2722      CLR	R18
    0017D 2733      CLR	R19
    0017E E006      LDI	R16,6
    0017F 940E 03F9 CALL	_pcf_set_byte
(0043)          pcf_set_byte(0x07,s[4]);          //月
    00181 01FA      MOVW	R30,R20
    00182 8124      LDD	R18,Z+4
    00183 2733      CLR	R19
    00184 E007      LDI	R16,7
    00185 940E 03F9 CALL	_pcf_set_byte
(0044)          pcf_set_byte(0x08,s[5]);          //年
    00187 01FA      MOVW	R30,R20
    00188 8125      LDD	R18,Z+5
    00189 2733      CLR	R19
    0018A E008      LDI	R16,0x8
    0018B 940E 03F9 CALL	_pcf_set_byte
(0045) 		 pcf_start();
    0018D 940E 0508 CALL	_pcf_start
    0018F 9159      LD	R21,Y+
    00190 9149      LD	R20,Y+
    00191 9508      RET
_pre_transfer:
  t                    --> R16
    00192 934A      ST	-Y,R20
    00193 935A      ST	-Y,R21
(0046) }
(0047) 
(0048) 
(0049) 
(0050) void pre_transfer(unsigned char *t){
(0051) 	 t[0]&=0x7f;	 t[1]&=0x7f;
    00194 01F8      MOVW	R30,R16
    00195 8180      LD	R24,Z
    00196 778F      ANDI	R24,0x7F
    00197 8380      ST	Z,R24
    00198 01CF      MOVW	R24,R30
    00199 9601      ADIW	R24,1
    0019A 01FC      MOVW	R30,R24
    0019B 8180      LD	R24,Z
    0019C 778F      ANDI	R24,0x7F
    0019D 8380      ST	Z,R24
(0052) 	 t[2]&=0x3f;	 t[3]&=0x3f;
    0019E 01C8      MOVW	R24,R16
    0019F 9602      ADIW	R24,2
    001A0 01FC      MOVW	R30,R24
    001A1 8180      LD	R24,Z
    001A2 738F      ANDI	R24,0x3F
    001A3 8380      ST	Z,R24
    001A4 01A8      MOVW	R20,R16
    001A5 5F4D      SUBI	R20,0xFD
    001A6 4F5F      SBCI	R21,0xFF
    001A7 01FA      MOVW	R30,R20
    001A8 8180      LD	R24,Z
    001A9 738F      ANDI	R24,0x3F
    001AA 8380      ST	Z,R24
(0053)  	 t[4]&=0x07;	 t[5]&=0x1f;
    001AB 01A8      MOVW	R20,R16
    001AC 5F4C      SUBI	R20,0xFC
    001AD 4F5F      SBCI	R21,0xFF
    001AE 01FA      MOVW	R30,R20
    001AF 8180      LD	R24,Z
    001B0 7087      ANDI	R24,7
    001B1 8380      ST	Z,R24
    001B2 01A8      MOVW	R20,R16
    001B3 5F4B      SUBI	R20,0xFB
    001B4 4F5F      SBCI	R21,0xFF
    001B5 01FA      MOVW	R30,R20
    001B6 8180      LD	R24,Z
    001B7 718F      ANDI	R24,0x1F
    001B8 8380      ST	Z,R24
    001B9 9159      LD	R21,Y+
    001BA 9149      LD	R20,Y+
    001BB 9508      RET
_val_msc_to_pc:
  i                    --> R20
  t                    --> R10
    001BC 940E 0B0E CALL	push_xgset300C
    001BE 0158      MOVW	R10,R16
(0054) }
(0055) 
(0056) 
(0057) ///use_to_display_val_to_com_string_ok
(0058) void val_msc_to_pc(unsigned char *t){
(0059) 	 unsigned char i=0;
(0060) 	 ind=0;
    001BF 2422      CLR	R2
    001C0 9220 0246 STS	ind,R2
(0061) 	 for(i=0;i<7;++i){  
    001C2 2744      CLR	R20
    001C3 C02F      RJMP	0x01F3
(0062) 	 	tem[ind++]='0'+(t[i]/16);
    001C4 9020 0246 LDS	R2,ind
    001C6 2433      CLR	R3
    001C7 2D82      MOV	R24,R2
    001C8 5F8F      SUBI	R24,0xFF
    001C9 9380 0246 STS	ind,R24
    001CB 2FE4      MOV	R30,R20
    001CC 27FF      CLR	R31
    001CD 0DEA      ADD	R30,R10
    001CE 1DFB      ADC	R31,R11
    001CF 8180      LD	R24,Z
    001D0 9582      SWAP	R24
    001D1 708F      ANDI	R24,0xF
    001D2 5D80      SUBI	R24,0xD0
    001D3 EEE9      LDI	R30,0xE9
    001D4 E0F2      LDI	R31,2
    001D5 2DA2      MOV	R26,R2
    001D6 27BB      CLR	R27
    001D7 0FAE      ADD	R26,R30
    001D8 1FBF      ADC	R27,R31
    001D9 938C      ST	X,R24
(0063) 		tem[ind++]='0'+(t[i]%16);
    001DA 9020 0246 LDS	R2,ind
    001DC 2433      CLR	R3
    001DD 2D82      MOV	R24,R2
    001DE 5F8F      SUBI	R24,0xFF
    001DF 9380 0246 STS	ind,R24
    001E1 2FE4      MOV	R30,R20
    001E2 27FF      CLR	R31
    001E3 0DEA      ADD	R30,R10
    001E4 1DFB      ADC	R31,R11
    001E5 8100      LD	R16,Z
    001E6 E110      LDI	R17,0x10
    001E7 940E 0AA7 CALL	mod8u
    001E9 2F80      MOV	R24,R16
    001EA 5D80      SUBI	R24,0xD0
    001EB EEE9      LDI	R30,0xE9
    001EC E0F2      LDI	R31,2
    001ED 2DA2      MOV	R26,R2
    001EE 27BB      CLR	R27
    001EF 0FAE      ADD	R26,R30
    001F0 1FBF      ADC	R27,R31
    001F1 938C      ST	X,R24
    001F2 9543      INC	R20
    001F3 3047      CPI	R20,7
    001F4 F408      BCC	0x01F6
    001F5 CFCE      RJMP	0x01C4
(0064) 	 }
(0065) 	 tem[ind]='\0';
    001F6 EE89      LDI	R24,0xE9
    001F7 E092      LDI	R25,2
    001F8 91E0 0246 LDS	R30,ind
    001FA 27FF      CLR	R31
    001FB 0FE8      ADD	R30,R24
    001FC 1FF9      ADC	R31,R25
    001FD 2422      CLR	R2
    001FE 8220      ST	Z,R2
(0066) 	 for(i=0;tem[i];++i){
    001FF 2744      CLR	R20
    00200 C00D      RJMP	0x020E
(0067) 	 	t[i]=tem[i];
    00201 EE89      LDI	R24,0xE9
    00202 E092      LDI	R25,2
    00203 2FE4      MOV	R30,R20
    00204 27FF      CLR	R31
    00205 0FE8      ADD	R30,R24
    00206 1FF9      ADC	R31,R25
    00207 8020      LD	R2,Z
    00208 2FE4      MOV	R30,R20
    00209 27FF      CLR	R31
    0020A 0DEA      ADD	R30,R10
    0020B 1DFB      ADC	R31,R11
    0020C 8220      ST	Z,R2
    0020D 9543      INC	R20
    0020E EE89      LDI	R24,0xE9
    0020F E092      LDI	R25,2
    00210 2FE4      MOV	R30,R20
    00211 27FF      CLR	R31
    00212 0FE8      ADD	R30,R24
    00213 1FF9      ADC	R31,R25
    00214 8020      LD	R2,Z
    00215 2022      TST	R2
    00216 F751      BNE	0x0201
(0068) 	 }
(0069) 	 t[i]='\0';
    00217 2FE4      MOV	R30,R20
    00218 27FF      CLR	R31
    00219 0DEA      ADD	R30,R10
    0021A 1DFB      ADC	R31,R11
    0021B 2422      CLR	R2
    0021C 8220      ST	Z,R2
    0021D 940C 0B13 JMP	pop_xgset300C
_len:
  cnt                  --> R10
  i                    --> R12
  s                    --> R16
    0021F 92AA      ST	-Y,R10
    00220 92CA      ST	-Y,R12
(0070) 	 
(0071) }
(0072) 
(0073) #define uint8 unsigned char
(0074) unsigned char len(unsigned char *s){
(0075) 		 uint8 i=0,cnt=0;
    00221 24CC      CLR	R12
    00222 24AA      CLR	R10
(0076) 		 for(;s[i];++i){
    00223 C002      RJMP	0x0226
(0077) 		 	++cnt;
    00224 94A3      INC	R10
    00225 94C3      INC	R12
    00226 2DEC      MOV	R30,R12
    00227 27FF      CLR	R31
    00228 0FE0      ADD	R30,R16
    00229 1FF1      ADC	R31,R17
    0022A 8020      LD	R2,Z
    0022B 2022      TST	R2
    0022C F7B9      BNE	0x0224
(0078) 		 }
(0079) 		 return cnt;
    0022D 2D0A      MOV	R16,R10
    0022E 90C9      LD	R12,Y+
    0022F 90A9      LD	R10,Y+
    00230 9508      RET
_msc_to_pc:
  s                    --> R10
    00231 92AA      ST	-Y,R10
    00232 92BA      ST	-Y,R11
    00233 0158      MOVW	R10,R16
    00234 9722      SBIW	R28,2
(0080) }
(0081) 
(0082) 
(0083) /// com_packet
(0084) void msc_to_pc(unsigned char *s){
(0085) 	 Com_putstring (s,len(s),&RTbuf_UART0);
    00235 0185      MOVW	R16,R10
    00236 DFE8      RCALL	_len
    00237 E082      LDI	R24,2
    00238 E093      LDI	R25,3
    00239 8399      STD	Y+1,R25
    0023A 8388      ST	Y,R24
    0023B 2F20      MOV	R18,R16
    0023C 0185      MOVW	R16,R10
    0023D 940E 0801 CALL	_Com_putstring
    0023F 9622      ADIW	R28,2
    00240 90B9      LD	R11,Y+
    00241 90A9      LD	R10,Y+
    00242 9508      RET
_pc_to_msc:
  len                  --> R12
  p                    --> R10
    00243 940E 0B09 CALL	push_xgset003C
    00245 2EC2      MOV	R12,R18
    00246 0158      MOVW	R10,R16
    00247 9722      SBIW	R28,2
(0086) }
(0087) void pc_to_msc(unsigned char *p,uint8 len){
(0088) 	 Com_getstring (p,len,&RTbuf_UART0);
    00248 E082      LDI	R24,2
    00249 E093      LDI	R25,3
    0024A 8399      STD	Y+1,R25
    0024B 8388      ST	Y,R24
    0024C 2D2C      MOV	R18,R12
    0024D 0185      MOVW	R16,R10
    0024E 940E 084E CALL	_Com_getstring
    00250 9622      ADIW	R28,2
    00251 940C 0AE3 JMP	pop_xgset003C
_out_to_user:
  i                    --> R20
  s                    --> R16
    00253 940E 0B18 CALL	push_xgsetF000
(0089) }/// com_packet_end
(0090) 
(0091) void out_to_user(uint8 *s){
(0092)      uint8      i=12;
    00255 E04C      LDI	R20,0xC
(0093)      ind=0;
    00256 2422      CLR	R2
    00257 9220 0246 STS	ind,R2
(0094) 
(0095)      out_buf[ind++]='2';
    00259 2433      CLR	R3
    0025A 2D82      MOV	R24,R2
    0025B 5F8F      SUBI	R24,0xFF
    0025C 9380 0246 STS	ind,R24
    0025E E184      LDI	R24,0x14
    0025F E092      LDI	R25,2
    00260 2DE2      MOV	R30,R2
    00261 27FF      CLR	R31
    00262 0FE8      ADD	R30,R24
    00263 1FF9      ADC	R31,R25
    00264 E382      LDI	R24,0x32
    00265 8380      ST	Z,R24
(0096)      out_buf[ind++]='0';
    00266 9020 0246 LDS	R2,ind
    00268 2433      CLR	R3
    00269 2D82      MOV	R24,R2
    0026A 5F8F      SUBI	R24,0xFF
    0026B 9380 0246 STS	ind,R24
    0026D E184      LDI	R24,0x14
    0026E E092      LDI	R25,2
    0026F 2DE2      MOV	R30,R2
    00270 27FF      CLR	R31
    00271 0FE8      ADD	R30,R24
    00272 1FF9      ADC	R31,R25
    00273 E380      LDI	R24,0x30
    00274 8380      ST	Z,R24
(0097)      for(;i>=0;--i){
    00275 C03A      RJMP	0x02B0
(0098)         out_buf[ind++]=s[2*i];
    00276 9160 0246 LDS	R22,ind
    00278 2777      CLR	R23
    00279 2F86      MOV	R24,R22
    0027A 5F8F      SUBI	R24,0xFF
    0027B 9380 0246 STS	ind,R24
    0027D 2FE4      MOV	R30,R20
    0027E 27FF      CLR	R31
    0027F 0FEE      LSL	R30
    00280 1FFF      ROL	R31
    00281 0FE0      ADD	R30,R16
    00282 1FF1      ADC	R31,R17
    00283 8020      LD	R2,Z
    00284 E184      LDI	R24,0x14
    00285 E092      LDI	R25,2
    00286 2FE6      MOV	R30,R22
    00287 27FF      CLR	R31
    00288 0FE8      ADD	R30,R24
    00289 1FF9      ADC	R31,R25
    0028A 8220      ST	Z,R2
(0099)         out_buf[ind++]=s[2*i+1];
    0028B 9160 0246 LDS	R22,ind
    0028D 2777      CLR	R23
    0028E 2F86      MOV	R24,R22
    0028F 5F8F      SUBI	R24,0xFF
    00290 9380 0246 STS	ind,R24
    00292 2FE4      MOV	R30,R20
    00293 27FF      CLR	R31
    00294 0FEE      LSL	R30
    00295 1FFF      ROL	R31
    00296 0FE0      ADD	R30,R16
    00297 1FF1      ADC	R31,R17
    00298 8021      LDD	R2,Z+1
    00299 E184      LDI	R24,0x14
    0029A E092      LDI	R25,2
    0029B 2FE6      MOV	R30,R22
    0029C 27FF      CLR	R31
    0029D 0FE8      ADD	R30,R24
    0029E 1FF9      ADC	R31,R25
    0029F 8220      ST	Z,R2
(0100)         out_buf[ind++]='-';
    002A0 9160 0246 LDS	R22,ind
    002A2 2777      CLR	R23
    002A3 2F86      MOV	R24,R22
    002A4 5F8F      SUBI	R24,0xFF
    002A5 9380 0246 STS	ind,R24
    002A7 E184      LDI	R24,0x14
    002A8 E092      LDI	R25,2
    002A9 2FE6      MOV	R30,R22
    002AA 27FF      CLR	R31
    002AB 0FE8      ADD	R30,R24
    002AC 1FF9      ADC	R31,R25
    002AD E28D      LDI	R24,0x2D
    002AE 8380      ST	Z,R24
    002AF 954A      DEC	R20
    002B0 3040      CPI	R20,0
    002B1 F008      BCS	0x02B3
    002B2 CFC3      RJMP	0x0276
(0101)      }
(0102)      out_buf[ind-1]='\n';
    002B3 E183      LDI	R24,0x13
    002B4 E092      LDI	R25,2
    002B5 91E0 0246 LDS	R30,ind
    002B7 27FF      CLR	R31
    002B8 0FE8      ADD	R30,R24
    002B9 1FF9      ADC	R31,R25
    002BA E08A      LDI	R24,0xA
    002BB 8380      ST	Z,R24
(0103)      out_buf[ind++]='\0';
    002BC 9140 0246 LDS	R20,ind
    002BE 2755      CLR	R21
    002BF 2F84      MOV	R24,R20
    002C0 5F8F      SUBI	R24,0xFF
    002C1 9380 0246 STS	ind,R24
    002C3 E184      LDI	R24,0x14
    002C4 E092      LDI	R25,2
    002C5 2FE4      MOV	R30,R20
    002C6 27FF      CLR	R31
    002C7 0FE8      ADD	R30,R24
    002C8 1FF9      ADC	R31,R25
    002C9 2422      CLR	R2
    002CA 8220      ST	Z,R2
(0104)      return ;                        
    002CB C000      RJMP	0x02CC
    002CC 940C 0B1D JMP	pop_xgsetF000
_main:
  W_Buff               --> R20
  R_Buff               --> R20
  key_brk              --> R22
  Key                  --> R10
  i                    --> R22
  j                    --> R10
    002CE 9722      SBIW	R28,2
(0105)      
(0106) 	 ind=0;
(0107) 	 out_buf[ind++]=s[0];
(0108) 	 out_buf[ind++]=s[1];
(0109) 	 out_buf[ind++]='S';out_buf[ind++]='E';out_buf[ind++]='C';
(0110)  	 out_buf[ind++]=' ';
(0111) 	 out_buf[ind++]=s[2];
(0112) 	 out_buf[ind++]=s[3];
(0113) 	 out_buf[ind++]='M';out_buf[ind++]='I';out_buf[ind++]='N';
(0114)   	 out_buf[ind++]=' ';
(0115)      out_buf[ind++]=s[4];
(0116) 	 out_buf[ind++]=s[5];
(0117) 	 out_buf[ind++]='H';
(0118)      out_buf[ind++]=s[6];
(0119) 	 out_buf[ind++]=s[7];
(0120) 	 out_buf[ind++]='D';	 out_buf[ind++]='A';	 out_buf[ind++]='Y';
(0121)      out_buf[ind++]=s[8];
(0122) 	 out_buf[ind++]=s[9];
(0123)      
(0124) 	 out_buf[ind++]='D';	 out_buf[ind++]='A';	 out_buf[ind++]='Y';
(0125) 
(0126)      
(0127) 	 out_buf[ind++]='\n';
(0128) 	 out_buf[ind]='\0';
(0129) 	 msc_to_pc(out_buf);	 
(0130) }
(0131) 
(0132) void main(void)
(0133) {
(0134)      unsigned char *W_Buff="www.avrvi.com",*R_Buff="\0",i=0,j=0,Key,key_brk;
    002CF EA48      LDI	R20,0xA8
    002D0 E052      LDI	R21,2
    002D1 24AA      CLR	R10
(0135) 	 
(0136) 	 //// init_process
(0137) 	 CLI();
    002D2 94F8      BCLR	7
(0138) 	 Com_init();
    002D3 940E 07B1 CALL	_Com_init
(0139) 	 twi_init();
    002D5 940E 09E0 CALL	_twi_init
(0140) 	 SEI();
    002D7 9478      BSET	7
(0141)  	 //// init_process_end
(0142) 	 
(0143) 	 //pcf 
(0144) //	 msc_to_pc("Plead write the time to the msc now!\n\n");
(0145) // msc_to_pc("24C01 Write: www.avrvi.com\n\n");
(0146) //	 time_init(read_buf);
(0147) //	 pcf_start();
(0148) 	//pcf_init_end	
(0149) //	 delay_nms(5000);	 
(0150) 
(0151) //////////////////////////////////////////////exp_process
(0152) 
(0153) /////////////////////////led_test
(0154) 
(0155)  PORTE = 0xFF;
    002D8 EF8F      LDI	R24,0xFF
    002D9 B983      OUT	0x03,R24
(0156)  DDRE  = 0xFF;
    002DA B982      OUT	0x02,R24
(0157) 
(0158)  	   for(i=0;i<3;i++)
    002DB 2766      CLR	R22
    002DC C00D      RJMP	0x02EA
(0159) 	 	 {
(0160) 		  PORTE = 0;
    002DD 2422      CLR	R2
    002DE B823      OUT	0x03,R2
(0161) 		  delay_nms(300);
    002DF E20C      LDI	R16,0x2C
    002E0 E011      LDI	R17,1
    002E1 940E 056F CALL	_delay_nms
(0162) 		  PORTE = 0xff;
    002E3 EF8F      LDI	R24,0xFF
    002E4 B983      OUT	0x03,R24
(0163) 		  delay_nms(300);
    002E5 E20C      LDI	R16,0x2C
    002E6 E011      LDI	R17,1
    002E7 940E 056F CALL	_delay_nms
    002E9 9563      INC	R22
    002EA 3063      CPI	R22,3
    002EB F388      BCS	0x02DD
(0164) 		 }
(0165) 
(0166) //.///////////////////////led_test_end
(0167) 
(0168) 
(0169) 
(0170) /////////////////////////seg7
(0171) 		HC_595_init();
    002EC 940E 057D CALL	_HC_595_init
(0172) 		//  Seg7_Led_display(111*i)
(0173) 		 for(i=0;i<10;i++)
    002EE 2766      CLR	R22
    002EF C013      RJMP	0x0303
(0174) 	 	 {
(0175) 		  for(j=0;j<200;++j){
    002F0 24AA      CLR	R10
    002F1 C00D      RJMP	0x02FF
(0176) 		  	Seg7_Led_display(1111*i);
    002F2 2F26      MOV	R18,R22
    002F3 2733      CLR	R19
    002F4 E507      LDI	R16,0x57
    002F5 E014      LDI	R17,4
    002F6 940E 0AD3 CALL	empy16s
    002F8 940E 0613 CALL	_Seg7_Led_display
(0177)      		  delay_nms(1);
    002FA E001      LDI	R16,1
    002FB E010      LDI	R17,0
    002FC 940E 056F CALL	_delay_nms
    002FE 94A3      INC	R10
    002FF 2D8A      MOV	R24,R10
    00300 3C88      CPI	R24,0xC8
    00301 F380      BCS	0x02F2
    00302 9563      INC	R22
    00303 306A      CPI	R22,0xA
    00304 F358      BCS	0x02F0
(0178) 		  }  
(0179) //		  delay_nms(300);
(0180) 		 }
(0181) 
(0182) 
(0183) /////////////////////////seg7_test_end
(0184) 
(0185) 
(0186) 
(0187) /////////////////////////BUZZ_KEY_test_end
(0188) 
(0189)  DDRE = 0xFF;
    00305 EF8F      LDI	R24,0xFF
    00306 B982      OUT	0x02,R24
(0190)  PORTE = 0xFF;
    00307 B983      OUT	0x03,R24
(0191)     Key_init();
    00308 940E 078D CALL	_Key_init
(0192)     Buzz_init();
    0030A 940E 0534 CALL	_Buzz_init
(0193) 	key_brk=0;
    0030C 2766      CLR	R22
    0030D C06B      RJMP	0x0379
(0194) 	while(1) {
(0195) 		if(key_brk)break;
    0030E 2366      TST	R22
    0030F F009      BEQ	0x0311
    00310 C069      RJMP	0x037A
(0196)         Key=get_key();
    00311 940E 0792 CALL	_get_key
    00313 2EA0      MOV	R10,R16
(0197)         switch(Key) {
    00314 24BB      CLR	R11
    00315 01C5      MOVW	R24,R10
    00316 3B80      CPI	R24,0xB0
    00317 E0E0      LDI	R30,0
    00318 079E      CPC	R25,R30
    00319 F409      BNE	0x031B
    0031A C037      RJMP	0x0352
    0031B EB80      LDI	R24,0xB0
    0031C 158A      CP	R24,R10
    0031D 059B      CPC	R25,R11
    0031E F034      BLT	0x0325
    0031F 01C5      MOVW	R24,R10
    00320 3780      CPI	R24,0x70
    00321 E0E0      LDI	R30,0
    00322 079E      CPC	R25,R30
    00323 F099      BEQ	0x0337
    00324 C054      RJMP	0x0379
    00325 01C5      MOVW	R24,R10
    00326 3D80      CPI	R24,0xD0
    00327 E0E0      LDI	R30,0
    00328 079E      CPC	R25,R30
    00329 F409      BNE	0x032B
    0032A C03C      RJMP	0x0367
    0032B 3D80      CPI	R24,0xD0
    0032C E0E0      LDI	R30,0
    0032D 079E      CPC	R25,R30
    0032E F40C      BGE	0x0330
    0032F C049      RJMP	0x0379
    00330 01C5      MOVW	R24,R10
    00331 3E80      CPI	R24,0xE0
    00332 E0E0      LDI	R30,0
    00333 079E      CPC	R25,R30
    00334 F409      BNE	0x0336
    00335 C040      RJMP	0x0376
    00336 C042      RJMP	0x0379
(0198)             case ( ((1<<S4)^0xF0) ): {
(0199)                 PORTE =~ (1<<3);
    00337 EF87      LDI	R24,0xF7
    00338 B983      OUT	0x03,R24
(0200)                 Beep(100,50);
    00339 E322      LDI	R18,0x32
    0033A E030      LDI	R19,0
    0033B E604      LDI	R16,0x64
    0033C E010      LDI	R17,0
    0033D 940E 053F CALL	_Beep
(0201)                 Beep(100,50);
    0033F E322      LDI	R18,0x32
    00340 E030      LDI	R19,0
    00341 E604      LDI	R16,0x64
    00342 E010      LDI	R17,0
    00343 940E 053F CALL	_Beep
(0202)                 Beep(100,50);
    00345 E322      LDI	R18,0x32
    00346 E030      LDI	R19,0
    00347 E604      LDI	R16,0x64
    00348 E010      LDI	R17,0
    00349 940E 053F CALL	_Beep
(0203)                 Beep(100,50);
    0034B E322      LDI	R18,0x32
    0034C E030      LDI	R19,0
    0034D E604      LDI	R16,0x64
    0034E E010      LDI	R17,0
    0034F 940E 053F CALL	_Beep
(0204) 				break;
    00351 C027      RJMP	0x0379
(0205)             }
(0206)             case ( ((1<<S3)^0xF0) ): {
(0207)                 PORTE =~ (1<<2);
    00352 EF8B      LDI	R24,0xFB
    00353 B983      OUT	0x03,R24
(0208)                 Beep(100,50);
    00354 E322      LDI	R18,0x32
    00355 E030      LDI	R19,0
    00356 E604      LDI	R16,0x64
    00357 E010      LDI	R17,0
    00358 940E 053F CALL	_Beep
(0209)                 Beep(100,50);
    0035A E322      LDI	R18,0x32
    0035B E030      LDI	R19,0
    0035C E604      LDI	R16,0x64
    0035D E010      LDI	R17,0
    0035E 940E 053F CALL	_Beep
(0210)                 Beep(100,50);
    00360 E322      LDI	R18,0x32
    00361 E030      LDI	R19,0
    00362 E604      LDI	R16,0x64
    00363 E010      LDI	R17,0
    00364 940E 053F CALL	_Beep
(0211) 				break;
    00366 C012      RJMP	0x0379
(0212)             }
(0213)             case ( ((1<<S2)^0xF0) ): {
(0214)                 PORTE =~ (1<<1);
    00367 EF8D      LDI	R24,0xFD
    00368 B983      OUT	0x03,R24
(0215)                 Beep(100,50);
    00369 E322      LDI	R18,0x32
    0036A E030      LDI	R19,0
    0036B E604      LDI	R16,0x64
    0036C E010      LDI	R17,0
    0036D 940E 053F CALL	_Beep
(0216)                 Beep(100,50);
    0036F E322      LDI	R18,0x32
    00370 E030      LDI	R19,0
    00371 E604      LDI	R16,0x64
    00372 E010      LDI	R17,0
    00373 940E 053F CALL	_Beep
(0217) 				break;
    00375 C003      RJMP	0x0379
(0218)             }
(0219)             case ( ((1<<S1)^0xF0) ): {
(0220)                 PORTE =~ (1<<0);
    00376 EF8E      LDI	R24,0xFE
    00377 B983      OUT	0x03,R24
(0221)               //  Beep(100,50);
(0222) 				key_brk=1;
    00378 E061      LDI	R22,1
    00379 CF94      RJMP	0x030E
(0223)                 break;
(0224)             }
(0225)             default: {
(0226)                 break;
(0227)             }
(0228)         }
(0229) 
(0230)     }
(0231) 	
(0232) 	
(0233) 	
(0234) 
(0235) /////////////////////////BUZZ_KEY_test_end
(0236) // 1.read the pcf_init_data
(0237) 
(0238)    	 msc_to_pc("read the pcf_init_data\n");
    0037A E900      LDI	R16,0x90
    0037B E012      LDI	R17,2
    0037C DEB4      RCALL	_msc_to_pc
(0239) 	 pcfread(tem2,2,7);/// get the bcd_to_year
    0037D E087      LDI	R24,7
    0037E E090      LDI	R25,0
    0037F 8399      STD	Y+1,R25
    00380 8388      ST	Y,R24
    00381 E022      LDI	R18,2
    00382 E030      LDI	R19,0
    00383 ED05      LDI	R16,0xD5
    00384 E012      LDI	R17,2
    00385 940E 0525 CALL	_pcfread
(0240) 	 pre_transfer(tem2);///and op
    00387 ED05      LDI	R16,0xD5
    00388 E012      LDI	R17,2
    00389 DE08      RCALL	_pre_transfer
(0241)      val_msc_to_pc(tem2);/// bcd to string
    0038A ED05      LDI	R16,0xD5
    0038B E012      LDI	R17,2
    0038C DE2F      RCALL	_val_msc_to_pc
(0242) // 2.pcf_init_data_read to pc
(0243)    out_to_user(tem2);
    0038D ED05      LDI	R16,0xD5
    0038E E012      LDI	R17,2
    0038F DEC3      RCALL	_out_to_user
(0244) //3. update the pcf data_to now time
(0245)    	 msc_to_pc("update the pcf data_to now time\n");	 
    00390 E60F      LDI	R16,0x6F
    00391 E012      LDI	R17,2
    00392 DE9E      RCALL	_msc_to_pc
(0246)      time_init(read_buf);
    00393 E000      LDI	R16,0
    00394 E012      LDI	R17,2
    00395 DDC9      RCALL	_time_init
(0247) // 4.read the pcd_now_data
(0248)     pcfread(tem2,2,7);/// get the bcd_to_year
    00396 E087      LDI	R24,7
    00397 E090      LDI	R25,0
    00398 8399      STD	Y+1,R25
    00399 8388      ST	Y,R24
    0039A E022      LDI	R18,2
    0039B E030      LDI	R19,0
    0039C ED05      LDI	R16,0xD5
    0039D E012      LDI	R17,2
    0039E 940E 0525 CALL	_pcfread
(0249) 	pre_transfer(tem2);///and op
    003A0 ED05      LDI	R16,0xD5
    003A1 E012      LDI	R17,2
    003A2 DDEF      RCALL	_pre_transfer
(0250) 	val_msc_to_pc(tem2);/// bcd to string
    003A3 ED05      LDI	R16,0xD5
    003A4 E012      LDI	R17,2
    003A5 DE16      RCALL	_val_msc_to_pc
(0251) 	
(0252) // 5.pcf_now_data_read to pc
(0253) 	out_to_user(tem2);
    003A6 ED05      LDI	R16,0xD5
    003A7 E012      LDI	R17,2
    003A8 DEAA      RCALL	_out_to_user
(0254) // 6.write_to_at24c01
(0255)    	msc_to_pc("writea_to_at24c01_\"wocao\"\n");
    003A9 E504      LDI	R16,0x54
    003AA E012      LDI	R17,2
    003AB DE85      RCALL	_msc_to_pc
(0256) 	 //wt24c(W_Buff,0x00,13);
(0257) 	 wt24c("wocao",0x00,5);
    003AC E085      LDI	R24,5
    003AD E090      LDI	R25,0
    003AE 8399      STD	Y+1,R25
    003AF 8388      ST	Y,R24
    003B0 2722      CLR	R18
    003B1 2733      CLR	R19
    003B2 E40E      LDI	R16,0x4E
    003B3 E012      LDI	R17,2
    003B4 940E 0439 CALL	_wt24c
(0258) //6.at24c01_to_pc
(0259)    	msc_to_pc("to_pc\n");
    003B6 E407      LDI	R16,0x47
    003B7 E012      LDI	R17,2
    003B8 DE78      RCALL	_msc_to_pc
(0260) 	rd24c(R_Buff,0x00,5);
    003B9 E085      LDI	R24,5
    003BA E090      LDI	R25,0
    003BB 8399      STD	Y+1,R25
    003BC 8388      ST	Y,R24
    003BD 2722      CLR	R18
    003BE 2733      CLR	R19
    003BF 018A      MOVW	R16,R20
    003C0 940E 049D CALL	_rd24c
(0261) 	R_Buff[5]='\n';
    003C2 E08A      LDI	R24,0xA
    003C3 01FA      MOVW	R30,R20
    003C4 8385      STD	Z+5,R24
(0262) 	R_Buff[6]='\0';
    003C5 2422      CLR	R2
    003C6 8226      STD	Z+6,R2
(0263) 	msc_to_pc(R_Buff);
    003C7 018F      MOVW	R16,R30
    003C8 DE68      RCALL	_msc_to_pc
(0264) 	
(0265) while(1);
    003C9 CFFF      RJMP	0x03C9
(0266) ////////////////////////////////////////exp_process_end
(0267) 
(0268) 	 wt24c(W_Buff,0x00,13);
(0269) 	 delay_nms(500);
(0270) 	 //Com_putstring ("24C01 Read: ",12,&RTbuf_UART0);
(0271) 	 rd24c(R_Buff,0x00,13);Com_putstring (R_Buff,13,&RTbuf_UART0);
(0272) 	 //Com_putstring ("\n\n",2,&RTbuf_UART0);
(0273)      delay_nms(500);
(0274) 	 while(1)
    003CA CFFF      RJMP	0x03CA
    003CB 9622      ADIW	R28,2
    003CC 9508      RET
_wt24c_fc:
  t                    --> R22
  n                    --> R10
  ad                   --> R12
  p                    --> R20
    003CD 940E 0B30 CALL	push_xgsetF03C
    003CF 0169      MOVW	R12,R18
    003D0 01A8      MOVW	R20,R16
    003D1 84A8      LDD	R10,Y+8
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\AT24C01.c
(0001) /************************************************
(0002) 文件：AT24C01.c
(0003) 用途：AT24C01操作函数
(0004) 注意：
(0005) 创建：2008.1.26
(0006) 修改：2008.1.26
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) unsigned char syserr;
(0011) /*************************************************************************
(0012) ** 函数名称: unsigned char * wt24c_fc(unsigned char *p, unsigned int ad, unsigned char n)
(0013) ** 功能描述: 向24Cxx写入数据wt24c_h()所要调用的函数
(0014) ** 输　入: 
(0015) ** 输出	 : 返回写入n个字节后的主机内存指针
(0016) ** 全局变量: 无
(0017) ** 调用模块: 
(0018) ** 说明：
(0019) ** 注意：
(0020) **************************************************************************/
(0021) 
(0022) 
(0023) 
(0024) unsigned char * wt24c_fc(unsigned char *p, unsigned int ad, unsigned char n)
(0025) {
(0026) 	unsigned char t=0;
(0027) 
(0028) 	#if e2prom<32
(0029) 	t=ad>>8;
    003D2 01B6      MOVW	R22,R12
    003D3 2F67      MOV	R22,R23
    003D4 2777      CLR	R23
(0030) 	t<<=1;
    003D5 0F66      LSL	R22
(0031) 	#endif
(0032) 	
(0033) 	i2cstart();					//发送起始信号
    003D6 940E 09EE CALL	_i2cstart
(0034) 		
(0035) 	if(i2cwt(W_ADD_COM+t)==SLAW)//发送SLA_W, 写字节命令及器件地址
    003D8 2F06      MOV	R16,R22
    003D9 5600      SUBI	R16,0x60
    003DA 940E 09F6 CALL	_i2cwt
    003DC 3108      CPI	R16,0x18
    003DD F479      BNE	0x03ED
(0036) 	{	
(0037) 		#if e2prom>16
(0038) 		i2cwt(ad>>8);			//ad_dst的高位到器件
(0039) 		#endif
(0040) 		i2cwt(ad);				//ad_dst的低位到器件
    003DE 2D0C      MOV	R16,R12
    003DF 940E 09F6 CALL	_i2cwt
(0041) 			
(0042) 		for(;n>0;n--)			//发送要写入的数据
    003E1 C007      RJMP	0x03E9
(0043) 		{
(0044) 		    i2cwt(*p);
    003E2 01FA      MOVW	R30,R20
    003E3 8100      LD	R16,Z
    003E4 940E 09F6 CALL	_i2cwt
(0045) 			p++;
    003E6 5F4F      SUBI	R20,0xFF
    003E7 4F5F      SBCI	R21,0xFF
    003E8 94AA      DEC	R10
    003E9 E080      LDI	R24,0
    003EA 158A      CP	R24,R10
    003EB F3B0      BCS	0x03E2
(0046) 		}
(0047) 	}
    003EC C003      RJMP	0x03F0
(0048) 	else syserr=ERR_SLAW;		//写字节命令及器件地址错
    003ED E081      LDI	R24,1
    003EE 9380 02FD STS	syserr,R24
(0049) 	
(0050) 	i2cstop();
    003F0 940E 0A0E CALL	_i2cstop
(0051)     delay_nms(6);						//延时6ms
    003F2 E006      LDI	R16,6
    003F3 E010      LDI	R17,0
    003F4 940E 056F CALL	_delay_nms
(0052) 	
(0053) 	return(p);
    003F6 018A      MOVW	R16,R20
    003F7 940C 0B39 JMP	pop_xgsetF03C
_pcf_set_byte:
  startcode            --> Y,+2
  ad                   --> R12
  p                    --> R10
    003F9 92AA      ST	-Y,R10
    003FA 92CA      ST	-Y,R12
    003FB 0169      MOVW	R12,R18
    003FC 2EA0      MOV	R10,R16
    003FD 9723      SBIW	R28,3
(0054) }
(0055) 
(0056) void pcf_set_byte(unsigned char p, unsigned int ad){
(0057)  unsigned char startcode=ad;
    003FE 82CA      STD	Y+2,R12
(0058)   wt24c_fc_pcf(&startcode,p,1);
    003FF E081      LDI	R24,1
    00400 E090      LDI	R25,0
    00401 8399      STD	Y+1,R25
    00402 8388      ST	Y,R24
    00403 2D2A      MOV	R18,R10
    00404 2733      CLR	R19
    00405 018E      MOVW	R16,R28
    00406 5F0E      SUBI	R16,0xFE
    00407 4F1F      SBCI	R17,0xFF
    00408 D004      RCALL	_wt24c_fc_pcf
    00409 9623      ADIW	R28,3
    0040A 90C9      LD	R12,Y+
    0040B 90A9      LD	R10,Y+
    0040C 9508      RET
_wt24c_fc_pcf:
  t                    --> R22
  n                    --> R10
  ad                   --> R12
  p                    --> R20
    0040D 940E 0B30 CALL	push_xgsetF03C
    0040F 0169      MOVW	R12,R18
    00410 01A8      MOVW	R20,R16
    00411 84A8      LDD	R10,Y+8
(0059) }
(0060) 
(0061) 
(0062) 
(0063) unsigned char * wt24c_fc_pcf(unsigned char *p, unsigned int ad, unsigned char n)
(0064) {
(0065) 
(0066) 	unsigned char t=0;
(0067) 	#if e2prom<32
(0068) 	t=ad>>8;
    00412 01B6      MOVW	R22,R12
    00413 2F67      MOV	R22,R23
    00414 2777      CLR	R23
(0069) 	t<<=1;
    00415 0F66      LSL	R22
(0070) 	#endif
(0071) 	
(0072) 	i2cstart();					//发送起始信号
    00416 940E 09EE CALL	_i2cstart
(0073) 		
(0074) 	if(i2cwt(W_ADD_COM_PCF+t)==SLAW)//发送SLA_W, 写字节命令及器件地址
    00418 2F06      MOV	R16,R22
    00419 550E      SUBI	R16,0x5E
    0041A 940E 09F6 CALL	_i2cwt
    0041C 3108      CPI	R16,0x18
    0041D F479      BNE	0x042D
(0075) 	{	
(0076) 		#if e2prom>16
(0077) 		i2cwt(ad>>8);			//ad_dst的高位到器件
(0078) 		#endif
(0079) 		i2cwt(ad);				//ad_dst的低位到器件
    0041E 2D0C      MOV	R16,R12
    0041F 940E 09F6 CALL	_i2cwt
(0080) 			
(0081) 		for(;n>0;n--)			//发送要写入的数据
    00421 C007      RJMP	0x0429
(0082) 		{
(0083) 		    i2cwt(*p);
    00422 01FA      MOVW	R30,R20
    00423 8100      LD	R16,Z
    00424 940E 09F6 CALL	_i2cwt
(0084) 			p++;
    00426 5F4F      SUBI	R20,0xFF
    00427 4F5F      SBCI	R21,0xFF
    00428 94AA      DEC	R10
    00429 E080      LDI	R24,0
    0042A 158A      CP	R24,R10
    0042B F3B0      BCS	0x0422
(0085) 		}
(0086) 	}
    0042C C003      RJMP	0x0430
(0087) 	else syserr=ERR_SLAW;		//写字节命令及器件地址错
    0042D E081      LDI	R24,1
    0042E 9380 02FD STS	syserr,R24
(0088) 	
(0089) 	i2cstop();
    00430 940E 0A0E CALL	_i2cstop
(0090)     delay_nms(6);						//延时6ms
    00432 E006      LDI	R16,6
    00433 E010      LDI	R17,0
    00434 940E 056F CALL	_delay_nms
(0091) 	
(0092) 	return(p);
    00436 018A      MOVW	R16,R20
    00437 940C 0B39 JMP	pop_xgsetF03C
_wt24c:
  n                    --> R12
  num                  --> R22
  ad_dst               --> R20
  p_rsc                --> R10
    00439 940E 0B30 CALL	push_xgsetF03C
    0043B 01A9      MOVW	R20,R18
    0043C 0158      MOVW	R10,R16
    0043D 9721      SBIW	R28,1
    0043E 8569      LDD	R22,Y+9
    0043F 857A      LDD	R23,Y+10
(0093) }
(0094) 
(0095) 
(0096) /*************************************************************************
(0097) ** 函数名称: 
(0098) ** 功能描述: 向24Cxx写入数据
(0099) ** 输　入: *p_rsc要输出数据的主机内存地址指针; ad_dst要写入数据的i2c的地址(双字节); num数据个数
(0100) ** 输出	 : 
(0101) ** 全局变量: 无
(0102) ** 调用模块: 
(0103) ** 说明：ad_dst: ad_dst+(num-1)不能大于器件的最高地址; num必须>0;
(0104) ** 注意：
(0105) **************************************************************************/
(0106) void wt24c(unsigned char *p_rsc, unsigned int ad_dst, unsigned int num)
(0107) {
(0108)     unsigned int n;
(0109) 
(0110)     n=ad_dst/PAGE_SIZE;		//确定地址与块地址的差
    00440 016A      MOVW	R12,R20
    00441 94D6      LSR	R13
    00442 94C7      ROR	R12
    00443 94D6      LSR	R13
    00444 94C7      ROR	R12
    00445 94D6      LSR	R13
    00446 94C7      ROR	R12
(0111) 	if(n) n=(unsigned long)PAGE_SIZE*(n+1)-ad_dst;
    00447 20CC      TST	R12
    00448 F411      BNE	0x044B
    00449 20DD      TST	R13
    0044A F0A9      BEQ	0x0460
    0044B E083      LDI	R24,3
    0044C E090      LDI	R25,0
    0044D 0186      MOVW	R16,R12
    0044E 5F0F      SUBI	R16,0xFF
    0044F 4F1F      SBCI	R17,0xFF
    00450 2722      CLR	R18
    00451 2733      CLR	R19
    00452 938A      ST	-Y,R24
    00453 940E 0B4B CALL	lsl32
    00455 0118      MOVW	R2,R16
    00456 0129      MOVW	R4,R18
    00457 013A      MOVW	R6,R20
    00458 2488      CLR	R8
    00459 2499      CLR	R9
    0045A 1826      SUB	R2,R6
    0045B 0837      SBC	R3,R7
    0045C 0848      SBC	R4,R8
    0045D 0859      SBC	R5,R9
    0045E 0161      MOVW	R12,R2
    0045F C005      RJMP	0x0465
(0112) 	else n=PAGE_SIZE-ad_dst;
    00460 E088      LDI	R24,0x8
    00461 E090      LDI	R25,0
    00462 016C      MOVW	R12,R24
    00463 1AC4      SUB	R12,R20
    00464 0AD5      SBC	R13,R21
(0113) 	
(0114)     if(n>=num)		//如果ad_dst所在的数据块的末尾地址 >= ad_dst + num, 就直接写入num个数据
    00465 16C6      CP	R12,R22
    00466 06D7      CPC	R13,R23
    00467 F048      BCS	0x0471
(0115)     {
(0116) 	 	wt24c_fc(p_rsc, ad_dst, num);
    00468 8368      ST	Y,R22
    00469 019A      MOVW	R18,R20
    0046A 0185      MOVW	R16,R10
    0046B DF61      RCALL	_wt24c_fc
(0117)     	if(syserr!=0) return;
    0046C 9020 02FD LDS	R2,syserr
    0046E 2022      TST	R2
    0046F F151      BEQ	0x049A
    00470 C029      RJMP	0x049A
(0118)     }
(0119)     else			//如果ad_dst所在的数据块末尾地址 < ad_dst + num, 就先写入ad_dst所在的数据块末尾地址与 ad_dst 之差个数据
(0120)     {
(0121) 	    p_rsc=wt24c_fc(p_rsc, ad_dst, n);
    00471 82C8      ST	Y,R12
    00472 019A      MOVW	R18,R20
    00473 0185      MOVW	R16,R10
    00474 DF58      RCALL	_wt24c_fc
    00475 0158      MOVW	R10,R16
(0122)     	if(syserr!=0) return;
    00476 9020 02FD LDS	R2,syserr
    00478 2022      TST	R2
    00479 F009      BEQ	0x047B
    0047A C01F      RJMP	0x049A
(0123) 		
(0124) 		num-=n;     //更新剩下数据个数
    0047B 196C      SUB	R22,R12
    0047C 097D      SBC	R23,R13
(0125)         ad_dst+=n;	//更新剩下数据的起始地址
    0047D 0D4C      ADD	R20,R12
    0047E 1D5D      ADC	R21,R13
    0047F C00F      RJMP	0x048F
(0126) 
(0127)         //把剩下数据写入器件
(0128)         while(num>=PAGE_SIZE)	//先按PAGE_SIZE为长度一页一页的写入
(0129)         {
(0130) 		 	p_rsc=wt24c_fc(p_rsc, ad_dst, PAGE_SIZE);
    00480 E088      LDI	R24,0x8
    00481 8388      ST	Y,R24
    00482 019A      MOVW	R18,R20
    00483 0185      MOVW	R16,R10
    00484 DF48      RCALL	_wt24c_fc
    00485 0158      MOVW	R10,R16
(0131)         	if(syserr!=0) return;
    00486 9020 02FD LDS	R2,syserr
    00488 2022      TST	R2
    00489 F009      BEQ	0x048B
    0048A C00F      RJMP	0x049A
(0132)         	
(0133)             num-=PAGE_SIZE;		//更新剩余数据个数
    0048B 5068      SUBI	R22,0x8
    0048C 4070      SBCI	R23,0
(0134)         	ad_dst+=PAGE_SIZE;	//更新剩下数据的起始地址
    0048D 5F48      SUBI	R20,0xF8
    0048E 4F5F      SBCI	R21,0xFF
    0048F 3068      CPI	R22,0x8
    00490 E0E0      LDI	R30,0
    00491 077E      CPC	R23,R30
    00492 F768      BCC	0x0480
(0135) 		}
(0136)         
(0137) 		if(num)			//把最后剩下的小于一个PAGE_SIZE长度的数据写入器件
    00493 3060      CPI	R22,0
    00494 0767      CPC	R22,R23
    00495 F021      BEQ	0x049A
(0138) 			wt24c_fc(p_rsc, ad_dst, num);
    00496 8368      ST	Y,R22
    00497 019A      MOVW	R18,R20
    00498 0185      MOVW	R16,R10
    00499 DF33      RCALL	_wt24c_fc
(0139)     }
    0049A 9621      ADIW	R28,1
    0049B 940C 0B39 JMP	pop_xgsetF03C
_rd24c:
  t                    --> R10
  num                  --> R22
  ad_rsc               --> R12
  p_dst                --> R20
    0049D 940E 0B30 CALL	push_xgsetF03C
    0049F 0169      MOVW	R12,R18
    004A0 01A8      MOVW	R20,R16
    004A1 8568      LDD	R22,Y+8
    004A2 8579      LDD	R23,Y+9
(0140) }
(0141) /*************************************************************************
(0142) ** 函数名称: 
(0143) ** 功能描述: 从24cxx读出数据
(0144) ** 输　入: *p_dst要读入数据的主机内存地址指针; ad_rsc要输出数据的i2c的地址(整形); num数据个数(整形)
(0145) ** 输出	 : 
(0146) ** 全局变量: 无
(0147) ** 调用模块: 
(0148) ** 说明：ad_dst+(num-1)不能大于器件的最高地址; num必须>0;
(0149) ** 注意：
(0150) **************************************************************************/
(0151) void rd24c(unsigned char *p_dst, unsigned int ad_rsc, unsigned int num)
(0152) {
(0153) 
(0154) 
(0155)  	 
(0156)     unsigned char t=0;
(0157) 
(0158) 	#if e2prom<32
(0159) 	t=ad_rsc>>8;
    004A3 0156      MOVW	R10,R12
    004A4 2CAB      MOV	R10,R11
    004A5 24BB      CLR	R11
(0160) 	t<<=1;
    004A6 0CAA      LSL	R10
(0161) 	#endif
(0162) 	
(0163) 	i2cstart();					//发送起始信号
    004A7 940E 09EE CALL	_i2cstart
(0164) 		
(0165) 	if(i2cwt(W_ADD_COM+t)==SLAW)//发送SLA_W, 写字节命令及器件地址
    004A9 2D0A      MOV	R16,R10
    004AA 5600      SUBI	R16,0x60
    004AB 940E 09F6 CALL	_i2cwt
    004AD 3108      CPI	R16,0x18
    004AE F4B1      BNE	0x04C5
(0166) 	{	
(0167) 		#if e2prom>16
(0168) 		i2cwt(ad_rsc>>8);		//ad_rsc的高位,  发送要读出数据的地址
(0169) 		#endif
(0170) 		i2cwt(ad_rsc);			//ad_rsc的低位
    004AF 2D0C      MOV	R16,R12
    004B0 940E 09F6 CALL	_i2cwt
(0171) 				
(0172) 		i2cstart();				//再发送起始信号
    004B2 940E 09EE CALL	_i2cstart
(0173) 		i2cwt(R_ADD_COM+t);		//发送SLA_R, 读命令字节及器件地址
    004B4 2D0A      MOV	R16,R10
    004B5 550F      SUBI	R16,0x5F
    004B6 940E 09F6 CALL	_i2cwt
(0174) 				
(0175) 		for(;num>0;num--)
    004B8 C008      RJMP	0x04C1
(0176) 		{
(0177) 		    *p_dst=i2crd();		//从器件读出一个字节
    004B9 940E 0A04 CALL	_i2crd
    004BB 01FA      MOVW	R30,R20
    004BC 8300      ST	Z,R16
(0178) 			p_dst++;
    004BD 5F4F      SUBI	R20,0xFF
    004BE 4F5F      SBCI	R21,0xFF
    004BF 5061      SUBI	R22,1
    004C0 4070      SBCI	R23,0
    004C1 3060      CPI	R22,0
    004C2 0767      CPC	R22,R23
    004C3 F7A9      BNE	0x04B9
(0179) 		}
(0180) 	}
    004C4 C003      RJMP	0x04C8
(0181) 	else syserr=ERR_SLAW;		//写字节命令及器件地址错或对方无应答
    004C5 E081      LDI	R24,1
    004C6 9380 02FD STS	syserr,R24
(0182) 		
(0183) 	i2cstop();
    004C8 940E 0A0E CALL	_i2cstop
    004CA 940C 0B39 JMP	pop_xgsetF03C
_rd24c_pcf:
  t                    --> R10
  num                  --> R22
  ad_rsc               --> R12
  p_dst                --> R20
    004CC 940E 0B30 CALL	push_xgsetF03C
    004CE 0169      MOVW	R12,R18
    004CF 01A8      MOVW	R20,R16
    004D0 8568      LDD	R22,Y+8
    004D1 8579      LDD	R23,Y+9
(0184) 
(0185) }
(0186) 
(0187) 
(0188) 
(0189) 
(0190) 
(0191) 
(0192) 
(0193) void rd24c_pcf(unsigned char *p_dst, unsigned int ad_rsc, unsigned int num)
(0194) {
(0195) 
(0196)     unsigned char t=0;
(0197) 	#if e2prom<32
(0198) 	t=ad_rsc>>8;
    004D2 0156      MOVW	R10,R12
    004D3 2CAB      MOV	R10,R11
    004D4 24BB      CLR	R11
(0199) 	t<<=1;
    004D5 0CAA      LSL	R10
(0200) 	#endif
(0201) 	
(0202) 	i2cstart();					//发送起始信号
    004D6 940E 09EE CALL	_i2cstart
(0203) 		
(0204) 	if(i2cwt(W_ADD_COM_PCF+t)==SLAW)//发送SLA_W, 写字节命令及器件地址
    004D8 2D0A      MOV	R16,R10
    004D9 550E      SUBI	R16,0x5E
    004DA 940E 09F6 CALL	_i2cwt
    004DC 3108      CPI	R16,0x18
    004DD F4B1      BNE	0x04F4
(0205) 	{	
(0206) 		#if e2prom>16
(0207) 		i2cwt(ad_rsc>>8);		//ad_rsc的高位,  发送要读出数据的地址
(0208) 		#endif
(0209) 		i2cwt(ad_rsc);			//ad_rsc的低位
    004DE 2D0C      MOV	R16,R12
    004DF 940E 09F6 CALL	_i2cwt
(0210) 				
(0211) 		i2cstart();				//再发送起始信号
    004E1 940E 09EE CALL	_i2cstart
(0212) 		i2cwt(R_ADD_COM_PCF+t);		//发送SLA_R, 读命令字节及器件地址
    004E3 2D0A      MOV	R16,R10
    004E4 550D      SUBI	R16,0x5D
    004E5 940E 09F6 CALL	_i2cwt
(0213) 				
(0214) 		for(;num>0;num--)
    004E7 C008      RJMP	0x04F0
(0215) 		{
(0216) 		    *p_dst=i2crd();		//从器件读出一个字节
    004E8 940E 0A04 CALL	_i2crd
    004EA 01FA      MOVW	R30,R20
    004EB 8300      ST	Z,R16
(0217) 			p_dst++;
    004EC 5F4F      SUBI	R20,0xFF
    004ED 4F5F      SBCI	R21,0xFF
    004EE 5061      SUBI	R22,1
    004EF 4070      SBCI	R23,0
    004F0 3060      CPI	R22,0
    004F1 0767      CPC	R22,R23
    004F2 F7A9      BNE	0x04E8
(0218) 		}
(0219) 	}
    004F3 C003      RJMP	0x04F7
(0220) 	else syserr=ERR_SLAW;		//写字节命令及器件地址错或对方无应答
    004F4 E081      LDI	R24,1
    004F5 9380 02FD STS	syserr,R24
(0221) 		
(0222) 	i2cstop();
    004F7 940E 0A0E CALL	_i2cstop
    004F9 940C 0B39 JMP	pop_xgsetF03C
_pcf_stop:
  stopcode             --> Y,+1
    004FB 9722      SBIW	R28,2
(0223) 
(0224) }
(0225) 
(0226) 
(0227) 
(0228) void pcf_stop(void)
(0229) {
(0230)  unsigned char stopcode=0x20;
    004FC E280      LDI	R24,0x20
    004FD 8389      STD	Y+1,R24
(0231)  wt24c_fc_pcf(&stopcode,0,1);
    004FE E081      LDI	R24,1
    004FF 8388      ST	Y,R24
    00500 2722      CLR	R18
    00501 2733      CLR	R19
    00502 018E      MOVW	R16,R28
    00503 5F0F      SUBI	R16,0xFF
    00504 4F1F      SBCI	R17,0xFF
    00505 DF07      RCALL	_wt24c_fc_pcf
    00506 9622      ADIW	R28,2
    00507 9508      RET
_pcf_start:
  startcode            --> Y,+1
    00508 9722      SBIW	R28,2
(0232) }
(0233) void pcf_start(void)
(0234) {
(0235)  unsigned char startcode=0x00;
    00509 2422      CLR	R2
    0050A 8229      STD	Y+1,R2
(0236)   wt24c_fc_pcf(&startcode,0,1);
    0050B E081      LDI	R24,1
    0050C 8388      ST	Y,R24
    0050D 2722      CLR	R18
    0050E 2733      CLR	R19
    0050F 018E      MOVW	R16,R28
    00510 5F0F      SUBI	R16,0xFF
    00511 4F1F      SBCI	R17,0xFF
    00512 DEFA      RCALL	_wt24c_fc_pcf
    00513 9622      ADIW	R28,2
    00514 9508      RET
_pcfset:
  n                    --> R14
  ad                   --> R12
  p                    --> R10
    00515 940E 0B07 CALL	push_xgset00FC
    00517 0169      MOVW	R12,R18
    00518 0158      MOVW	R10,R16
    00519 9721      SBIW	R28,1
    0051A 80EF      LDD	R14,Y+7
(0237) }
(0238) 
(0239) unsigned char * pcfset(unsigned char *p, unsigned int ad, unsigned char n){
(0240) 		 pcf_stop();
    0051B DFDF      RCALL	_pcf_stop
(0241) 		 wt24c_fc_pcf(p,ad,n);
    0051C 82E8      ST	Y,R14
    0051D 0196      MOVW	R18,R12
    0051E 0185      MOVW	R16,R10
    0051F DEED      RCALL	_wt24c_fc_pcf
(0242) 		 pcf_start();
    00520 DFE7      RCALL	_pcf_start
(0243) 		 return(p);		 
    00521 0185      MOVW	R16,R10
    00522 9621      ADIW	R28,1
    00523 940C 0AE8 JMP	pop_xgset00FC
_pcfread:
  num                  --> R14
  ad_rsc               --> R12
  p_dst                --> R10
    00525 940E 0B07 CALL	push_xgset00FC
    00527 0169      MOVW	R12,R18
    00528 0158      MOVW	R10,R16
    00529 9722      SBIW	R28,2
    0052A 84E8      LDD	R14,Y+8
    0052B 84F9      LDD	R15,Y+9
(0244) }
(0245) 
(0246) void pcfread(unsigned char *p_dst, unsigned int ad_rsc, unsigned int num){	 
(0247) 	 rd24c_pcf(p_dst,ad_rsc,num);
    0052C 82F9      STD	Y+1,R15
    0052D 82E8      ST	Y,R14
    0052E 0196      MOVW	R18,R12
    0052F 0185      MOVW	R16,R10
    00530 DF9B      RCALL	_rd24c_pcf
    00531 9622      ADIW	R28,2
    00532 940C 0AE8 JMP	pop_xgset00FC
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\buzz.c
(0001) /************************************************
(0002) 文件：buzz.c
(0003) 用途：
(0004) 注意：内部8M晶振
(0005) 创建：2008.4.1
(0006) 修改：2008.4.1
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) /*************************************************************************
(0011) ** 函数名称:蜂鸣器初始化
(0012) ** 功能描述:
(0013) ** 输　入:
(0014) ** 输出	 :
(0015) ** 全局变量:
(0016) ** 调用模块:
(0017) ** 说明：
(0018) ** 注意：
(0019) **************************************************************************/
(0020) void Buzz_init(void)
(0021) {
(0022)  BUZZ_DDR |= (1<<SPK);
_Buzz_init:
    00534 9180 0064 LDS	R24,0x64
    00536 6180      ORI	R24,0x10
    00537 9380 0064 STS	0x64,R24
(0023)  BUZZ_PORT &=~ (1<<SPK);
    00539 9180 0065 LDS	R24,0x65
    0053B 7E8F      ANDI	R24,0xEF
    0053C 9380 0065 STS	0x65,R24
    0053E 9508      RET
_Beep:
  L_time               --> R10
  H_time               --> R12
    0053F 940E 0B09 CALL	push_xgset003C
    00541 0159      MOVW	R10,R18
    00542 0168      MOVW	R12,R16
(0024) }
(0025) /*************************************************************************
(0026) ** 函数名称:蜂鸣
(0027) ** 功能描述:
(0028) ** 输　入: H_time: 响的时间 L_time: 不响的时间
(0029) ** 输出	 :
(0030) ** 全局变量:
(0031) ** 调用模块:
(0032) ** 说明：
(0033) ** 注意：
(0034) **************************************************************************/
(0035) void Beep(unsigned int H_time,unsigned int L_time)
(0036) {
(0037)  BUZZ_PORT |= (1<<SPK);
    00543 9180 0065 LDS	R24,0x65
    00545 6180      ORI	R24,0x10
    00546 9380 0065 STS	0x65,R24
(0038)  delay_nms(H_time);
    00548 0186      MOVW	R16,R12
    00549 940E 056F CALL	_delay_nms
(0039)  BUZZ_PORT &=~ (1<<SPK);
    0054B 9180 0065 LDS	R24,0x65
    0054D 7E8F      ANDI	R24,0xEF
    0054E 9380 0065 STS	0x65,R24
(0040)  delay_nms(L_time);
    00550 0185      MOVW	R16,R10
    00551 940E 056F CALL	_delay_nms
    00553 940C 0AE3 JMP	pop_xgset003C
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\delay.c
(0001) /************************************************
(0002) 文件：delay.c
(0003) 用途：延时函数
(0004) 注意：系统时钟8M
(0005) 创建：2008.1.25
(0006) 修改：2008.1.25
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include <iom128v.h>
(0010) void delay_1us(void)                 //1us延时函数
(0011)   {
(0012)    asm("nop");
_delay_1us:
    00555 0000      NOP
    00556 9508      RET
_delay_nus:
  i                    --> R20
  n                    --> R10
    00557 940E 0B0E CALL	push_xgset300C
    00559 0158      MOVW	R10,R16
(0013)   }
(0014) 
(0015) void delay_nus(unsigned int n)       //N us延时函数
(0016)   {
(0017)    unsigned int i=0;
(0018)    for (i=0;i<n;i++)
    0055A 2744      CLR	R20
    0055B 2755      CLR	R21
    0055C C003      RJMP	0x0560
(0019)    delay_1us();
    0055D DFF7      RCALL	_delay_1us
    0055E 5F4F      SUBI	R20,0xFF
    0055F 4F5F      SBCI	R21,0xFF
    00560 154A      CP	R20,R10
    00561 055B      CPC	R21,R11
    00562 F3D0      BCS	0x055D
    00563 940C 0B13 JMP	pop_xgset300C
(0020)   }
(0021)   
(0022) void delay_1ms(void)                 //1ms延时函数
(0023)   {
(0024)    unsigned int i;
(0025)    for (i=0;i<1140;i++);
_delay_1ms:
  i                    --> R16
    00565 2700      CLR	R16
    00566 2711      CLR	R17
    00567 C002      RJMP	0x056A
    00568 5F0F      SUBI	R16,0xFF
    00569 4F1F      SBCI	R17,0xFF
    0056A 3704      CPI	R16,0x74
    0056B E0E4      LDI	R30,4
    0056C 071E      CPC	R17,R30
    0056D F3D0      BCS	0x0568
    0056E 9508      RET
_delay_nms:
  i                    --> R20
  n                    --> R10
    0056F 940E 0B0E CALL	push_xgset300C
    00571 0158      MOVW	R10,R16
(0026)   }
(0027)   
(0028) void delay_nms(unsigned int n)       //N ms延时函数
(0029)   {
(0030)    unsigned int i=0;
(0031)    for (i=0;i<n;i++)
    00572 2744      CLR	R20
    00573 2755      CLR	R21
    00574 C003      RJMP	0x0578
(0032)    delay_1ms();
    00575 DFEF      RCALL	_delay_1ms
    00576 5F4F      SUBI	R20,0xFF
    00577 4F5F      SBCI	R21,0xFF
    00578 154A      CP	R20,R10
    00579 055B      CPC	R21,R11
    0057A F3D0      BCS	0x0575
    0057B 940C 0B13 JMP	pop_xgset300C
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\hc595.c
(0001) /************************************************
(0002) 文件：hc595.c
(0003) 用途：
(0004) 注意：内部8M晶振
(0005) 创建：2008.4.1
(0006) 修改：2008.4.1
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) const unsigned char Seg7_Data[]={0x3F,0x06,0x5B,0x4F,0x66,             //0,1,2,3,4
(0011)                                  0x6D,0x7D,0x07,0x7F,0x6F,             //5,6,7,8,9
(0012) 						         0x77,0x7C,0x39,0x5E,0x79,0x71,0x00};  //a,b,c,d,e,f
(0013) volatile unsigned char Seg7_Led_Buf[4],point=0,point_pos=0;//point是小数点标志1代表有小数点point_pos表示小数点位置
(0014) /*************************************************************************
(0015) ** 函数名称:HC595初始化
(0016) ** 功能描述:
(0017) ** 输　入:
(0018) ** 输出	 :
(0019) ** 全局变量:
(0020) ** 调用模块:
(0021) ** 说明：
(0022) ** 注意：
(0023) **************************************************************************/
(0024) void HC_595_init(void)
(0025) {
(0026)  OE_DDR |= (1<<OE);
_HC_595_init:
    0057D 9AA7      SBI	0x14,7
(0027)  OE_PORT &= (1<<OE);
    0057E B385      IN	R24,0x15
    0057F 7880      ANDI	R24,0x80
    00580 BB85      OUT	0x15,R24
(0028)  PORTB = 0x0F;
    00581 E08F      LDI	R24,0xF
    00582 BB88      OUT	0x18,R24
(0029)  spi_init();
    00583 940E 0A12 CALL	_spi_init
(0030)  Seg7_Led_Buf[0]=16;
    00585 E180      LDI	R24,0x10
    00586 9380 02FE STS	Seg7_Led_Buf,R24
(0031)  Seg7_Led_Buf[1]=16;
    00588 9380 02FF STS	Seg7_Led_Buf+1,R24
(0032)  Seg7_Led_Buf[2]=16;
    0058A 9380 0300 STS	Seg7_Led_Buf+2,R24
(0033)  Seg7_Led_Buf[3]=16;
    0058C 9380 0301 STS	Seg7_Led_Buf+3,R24
    0058E 9508      RET
_HC_595_OUT:
  data                 --> R10
    0058F 92AA      ST	-Y,R10
    00590 2EA0      MOV	R10,R16
(0034) }
(0035) /*************************************************************************
(0036) ** 函数名称:HC595送数据
(0037) ** 功能描述:
(0038) ** 输　入:
(0039) ** 输出	 :
(0040) ** 全局变量:
(0041) ** 调用模块: 
(0042) ** 说明：
(0043) ** 注意：
(0044) **************************************************************************/
(0045) void HC_595_OUT(unsigned char data)
(0046) {
(0047)  	 SS_L();
    00591 98C0      CBI	0x18,0
(0048) 	 SPI_MasterTransmit(data);
    00592 2D0A      MOV	R16,R10
    00593 940E 0A18 CALL	_SPI_MasterTransmit
(0049)  	 SS_H();
    00595 9AC0      SBI	0x18,0
    00596 90A9      LD	R10,Y+
    00597 9508      RET
(0050) }
(0051) /*************************************************************************
(0052) ** 函数名称:HC595刷新显示
(0053) ** 功能描述:
(0054) ** 输　入:
(0055) ** 输出	 :
(0056) ** 全局变量:
(0057) ** 调用模块: 
(0058) ** 说明：
(0059) ** 注意：
(0060) **************************************************************************/
(0061) void Seg7_Led_Update(void)
(0062) {
(0063)  HC_595_OUT(Seg7_Data[Seg7_Led_Buf[0]]); 
_Seg7_Led_Update:
    00598 EB88      LDI	R24,0xB8
    00599 E092      LDI	R25,2
    0059A 91E0 02FE LDS	R30,Seg7_Led_Buf
    0059C 27FF      CLR	R31
    0059D 0FE8      ADD	R30,R24
    0059E 1FF9      ADC	R31,R25
    0059F 8100      LD	R16,Z
    005A0 DFEE      RCALL	_HC_595_OUT
(0064)  Seg7_Bit0_En(); 
    005A1 9ABC      SBI	0x17,4
    005A2 9AC4      SBI	0x18,4
(0065)  delay_nus(60); 
    005A3 E30C      LDI	R16,0x3C
    005A4 E010      LDI	R17,0
    005A5 940E 0557 CALL	_delay_nus
(0066)  Seg7_Bit0_Dis();
    005A7 9ABC      SBI	0x17,4
    005A8 98C4      CBI	0x18,4
(0067)  
(0068)  HC_595_OUT(Seg7_Data[Seg7_Led_Buf[1]]);
    005A9 EB88      LDI	R24,0xB8
    005AA E092      LDI	R25,2
    005AB 91E0 02FF LDS	R30,Seg7_Led_Buf+1
    005AD 27FF      CLR	R31
    005AE 0FE8      ADD	R30,R24
    005AF 1FF9      ADC	R31,R25
    005B0 8100      LD	R16,Z
    005B1 DFDD      RCALL	_HC_595_OUT
(0069)  if((point==1)&&(point_pos==1))
    005B2 9180 02C9 LDS	R24,point
    005B4 3081      CPI	R24,1
    005B5 F471      BNE	0x05C4
    005B6 9180 02CA LDS	R24,point_pos
    005B8 3081      CPI	R24,1
    005B9 F451      BNE	0x05C4
(0070)  HC_595_OUT((Seg7_Data[Seg7_Led_Buf[1]])|(1<<dp));
    005BA EB88      LDI	R24,0xB8
    005BB E092      LDI	R25,2
    005BC 91E0 02FF LDS	R30,Seg7_Led_Buf+1
    005BE 27FF      CLR	R31
    005BF 0FE8      ADD	R30,R24
    005C0 1FF9      ADC	R31,R25
    005C1 8100      LD	R16,Z
    005C2 6800      ORI	R16,0x80
    005C3 DFCB      RCALL	_HC_595_OUT
(0071)  Seg7_Bit1_En();
    005C4 9ABD      SBI	0x17,5
    005C5 9AC5      SBI	0x18,5
(0072)  delay_nus(60);
    005C6 E30C      LDI	R16,0x3C
    005C7 E010      LDI	R17,0
    005C8 940E 0557 CALL	_delay_nus
(0073)  Seg7_Bit1_Dis();
    005CA 9ABD      SBI	0x17,5
    005CB 98C5      CBI	0x18,5
(0074)  
(0075)  HC_595_OUT(Seg7_Data[Seg7_Led_Buf[2]]); 
    005CC EB88      LDI	R24,0xB8
    005CD E092      LDI	R25,2
    005CE 91E0 0300 LDS	R30,Seg7_Led_Buf+2
    005D0 27FF      CLR	R31
    005D1 0FE8      ADD	R30,R24
    005D2 1FF9      ADC	R31,R25
    005D3 8100      LD	R16,Z
    005D4 DFBA      RCALL	_HC_595_OUT
(0076)  if((point==1)&&(point_pos==2))
    005D5 9180 02C9 LDS	R24,point
    005D7 3081      CPI	R24,1
    005D8 F471      BNE	0x05E7
    005D9 9180 02CA LDS	R24,point_pos
    005DB 3082      CPI	R24,2
    005DC F451      BNE	0x05E7
(0077)  HC_595_OUT((Seg7_Data[Seg7_Led_Buf[2]])|(1<<dp));
    005DD EB88      LDI	R24,0xB8
    005DE E092      LDI	R25,2
    005DF 91E0 0300 LDS	R30,Seg7_Led_Buf+2
    005E1 27FF      CLR	R31
    005E2 0FE8      ADD	R30,R24
    005E3 1FF9      ADC	R31,R25
    005E4 8100      LD	R16,Z
    005E5 6800      ORI	R16,0x80
    005E6 DFA8      RCALL	_HC_595_OUT
(0078)  Seg7_Bit2_En();
    005E7 9ABE      SBI	0x17,6
    005E8 9AC6      SBI	0x18,6
(0079)  delay_nus(60);
    005E9 E30C      LDI	R16,0x3C
    005EA E010      LDI	R17,0
    005EB 940E 0557 CALL	_delay_nus
(0080)  Seg7_Bit2_Dis();
    005ED 9ABE      SBI	0x17,6
    005EE 98C6      CBI	0x18,6
(0081)  
(0082)  HC_595_OUT(Seg7_Data[Seg7_Led_Buf[3]]);
    005EF EB88      LDI	R24,0xB8
    005F0 E092      LDI	R25,2
    005F1 91E0 0301 LDS	R30,Seg7_Led_Buf+3
    005F3 27FF      CLR	R31
    005F4 0FE8      ADD	R30,R24
    005F5 1FF9      ADC	R31,R25
    005F6 8100      LD	R16,Z
    005F7 DF97      RCALL	_HC_595_OUT
(0083)  if((point==1)&&(point_pos==3))
    005F8 9180 02C9 LDS	R24,point
    005FA 3081      CPI	R24,1
    005FB F471      BNE	0x060A
    005FC 9180 02CA LDS	R24,point_pos
    005FE 3083      CPI	R24,3
    005FF F451      BNE	0x060A
(0084)  HC_595_OUT((Seg7_Data[Seg7_Led_Buf[3]])|(1<<dp));
    00600 EB88      LDI	R24,0xB8
    00601 E092      LDI	R25,2
    00602 91E0 0301 LDS	R30,Seg7_Led_Buf+3
    00604 27FF      CLR	R31
    00605 0FE8      ADD	R30,R24
    00606 1FF9      ADC	R31,R25
    00607 8100      LD	R16,Z
    00608 6800      ORI	R16,0x80
    00609 DF85      RCALL	_HC_595_OUT
(0085)  Seg7_Bit3_En();
    0060A 9ABF      SBI	0x17,7
    0060B 9AC7      SBI	0x18,7
(0086)  delay_nus(60);
    0060C E30C      LDI	R16,0x3C
    0060D E010      LDI	R17,0
    0060E 940E 0557 CALL	_delay_nus
(0087)  Seg7_Bit3_Dis();
    00610 9ABF      SBI	0x17,7
    00611 98C7      CBI	0x18,7
    00612 9508      RET
_Seg7_Led_display:
  data                 --> R10
    00613 92AA      ST	-Y,R10
    00614 92BA      ST	-Y,R11
    00615 0158      MOVW	R10,R16
(0088) }
(0089) /*************************************************************************
(0090) ** 函数名称:Hc595显示整形数据
(0091) ** 功能描述:
(0092) ** 输　入:0~9999
(0093) ** 输出	 :
(0094) ** 全局变量:
(0095) ** 调用模块: 
(0096) ** 说明：
(0097) ** 注意：
(0098) **************************************************************************/
(0099) void Seg7_Led_display(unsigned int data)
(0100) {
(0101)  if(data>9999) //错误处理,超出显示范围则全亮
    00616 E08F      LDI	R24,0xF
    00617 E297      LDI	R25,0x27
    00618 158A      CP	R24,R10
    00619 059B      CPC	R25,R11
    0061A F430      BCC	0x0621
(0102)  	{
(0103) 	 HC_595_OUT(0xFF);
    0061B EF0F      LDI	R16,0xFF
    0061C DF72      RCALL	_HC_595_OUT
(0104) 	 Seg7_Bitselect_PORT|=((1<<Seg7_Bit0)|(1<<Seg7_Bit1)|(1<<Seg7_Bit2)|(1<<Seg7_Bit3));
    0061D B388      IN	R24,0x18
    0061E 6F80      ORI	R24,0xF0
    0061F BB88      OUT	0x18,R24
(0105) 	}
    00620 C07F      RJMP	0x06A0
(0106)  else if(data>999)
    00621 EE87      LDI	R24,0xE7
    00622 E093      LDI	R25,3
    00623 158A      CP	R24,R10
    00624 059B      CPC	R25,R11
    00625 F530      BCC	0x064C
(0107)  	{
(0108) 	 Seg7_Led_Buf[3]=data/1000;
    00626 EE28      LDI	R18,0xE8
    00627 E033      LDI	R19,3
    00628 0185      MOVW	R16,R10
    00629 940E 0A23 CALL	div16u
    0062B 9300 0301 STS	Seg7_Led_Buf+3,R16
(0109)  	 Seg7_Led_Buf[2]=(data%1000)/100;
    0062D EE28      LDI	R18,0xE8
    0062E E033      LDI	R19,3
    0062F 0185      MOVW	R16,R10
    00630 940E 0A21 CALL	mod16u
    00632 E624      LDI	R18,0x64
    00633 E030      LDI	R19,0
    00634 940E 0A23 CALL	div16u
    00636 9300 0300 STS	Seg7_Led_Buf+2,R16
(0110)  	 Seg7_Led_Buf[1]=(data%100)/10;
    00638 E624      LDI	R18,0x64
    00639 E030      LDI	R19,0
    0063A 0185      MOVW	R16,R10
    0063B 940E 0A21 CALL	mod16u
    0063D E02A      LDI	R18,0xA
    0063E E030      LDI	R19,0
    0063F 940E 0A23 CALL	div16u
    00641 9300 02FF STS	Seg7_Led_Buf+1,R16
(0111)  	 Seg7_Led_Buf[0]=data%10;
    00643 E02A      LDI	R18,0xA
    00644 E030      LDI	R19,0
    00645 0185      MOVW	R16,R10
    00646 940E 0A21 CALL	mod16u
    00648 9300 02FE STS	Seg7_Led_Buf,R16
(0112) 	 Seg7_Led_Update();
    0064A DF4D      RCALL	_Seg7_Led_Update
(0113) 	}
    0064B C054      RJMP	0x06A0
(0114)  else if(data>99)
    0064C E683      LDI	R24,0x63
    0064D E090      LDI	R25,0
    0064E 158A      CP	R24,R10
    0064F 059B      CPC	R25,R11
    00650 F510      BCC	0x0673
(0115)  	{
(0116) 	 Seg7_Led_Buf[3]=16;
    00651 E180      LDI	R24,0x10
    00652 9380 0301 STS	Seg7_Led_Buf+3,R24
(0117)  	 Seg7_Led_Buf[2]=(data%1000)/100;
    00654 EE28      LDI	R18,0xE8
    00655 E033      LDI	R19,3
    00656 0185      MOVW	R16,R10
    00657 940E 0A21 CALL	mod16u
    00659 E624      LDI	R18,0x64
    0065A E030      LDI	R19,0
    0065B 940E 0A23 CALL	div16u
    0065D 9300 0300 STS	Seg7_Led_Buf+2,R16
(0118)  	 Seg7_Led_Buf[1]=(data%100)/10;
    0065F E624      LDI	R18,0x64
    00660 E030      LDI	R19,0
    00661 0185      MOVW	R16,R10
    00662 940E 0A21 CALL	mod16u
    00664 E02A      LDI	R18,0xA
    00665 E030      LDI	R19,0
    00666 940E 0A23 CALL	div16u
    00668 9300 02FF STS	Seg7_Led_Buf+1,R16
(0119)  	 Seg7_Led_Buf[0]=data%10;
    0066A E02A      LDI	R18,0xA
    0066B E030      LDI	R19,0
    0066C 0185      MOVW	R16,R10
    0066D 940E 0A21 CALL	mod16u
    0066F 9300 02FE STS	Seg7_Led_Buf,R16
(0120) 	 Seg7_Led_Update();
    00671 DF26      RCALL	_Seg7_Led_Update
(0121) 	}
    00672 C02D      RJMP	0x06A0
(0122)  else if(data>9)
    00673 E089      LDI	R24,0x9
    00674 E090      LDI	R25,0
    00675 158A      CP	R24,R10
    00676 059B      CPC	R25,R11
    00677 F4C8      BCC	0x0691
(0123)  	{
(0124) 	 Seg7_Led_Buf[3]=16;
    00678 E180      LDI	R24,0x10
    00679 9380 0301 STS	Seg7_Led_Buf+3,R24
(0125)  	 Seg7_Led_Buf[2]=16;
    0067B 9380 0300 STS	Seg7_Led_Buf+2,R24
(0126)  	 Seg7_Led_Buf[1]=(data%100)/10;
    0067D E624      LDI	R18,0x64
    0067E E030      LDI	R19,0
    0067F 0185      MOVW	R16,R10
    00680 940E 0A21 CALL	mod16u
    00682 E02A      LDI	R18,0xA
    00683 E030      LDI	R19,0
    00684 940E 0A23 CALL	div16u
    00686 9300 02FF STS	Seg7_Led_Buf+1,R16
(0127)  	 Seg7_Led_Buf[0]=data%10;
    00688 E02A      LDI	R18,0xA
    00689 E030      LDI	R19,0
    0068A 0185      MOVW	R16,R10
    0068B 940E 0A21 CALL	mod16u
    0068D 9300 02FE STS	Seg7_Led_Buf,R16
(0128) 	 Seg7_Led_Update();
    0068F DF08      RCALL	_Seg7_Led_Update
(0129) 	}
    00690 C00F      RJMP	0x06A0
(0130)  else
(0131)  	{
(0132) 	 Seg7_Led_Buf[3]=16;
    00691 E180      LDI	R24,0x10
    00692 9380 0301 STS	Seg7_Led_Buf+3,R24
(0133)  	 Seg7_Led_Buf[2]=16;
    00694 9380 0300 STS	Seg7_Led_Buf+2,R24
(0134)  	 Seg7_Led_Buf[1]=16;
    00696 9380 02FF STS	Seg7_Led_Buf+1,R24
(0135)  	 Seg7_Led_Buf[0]=data%10;
    00698 E02A      LDI	R18,0xA
    00699 E030      LDI	R19,0
    0069A 0185      MOVW	R16,R10
    0069B 940E 0A21 CALL	mod16u
    0069D 9300 02FE STS	Seg7_Led_Buf,R16
(0136) 	 Seg7_Led_Update();
    0069F DEF8      RCALL	_Seg7_Led_Update
(0137) 	}
    006A0 90B9      LD	R11,Y+
    006A1 90A9      LD	R10,Y+
    006A2 9508      RET
_Seg7_Led_float:
  temp                 --> R10
  data                 --> Y,+2
    006A3 940E 0A1C CALL	push_arg4
    006A5 92AA      ST	-Y,R10
    006A6 92BA      ST	-Y,R11
(0138) }
(0139) /*************************************************************************
(0140) ** 函数名称:HC595显示浮点数据
(0141) ** 功能描述:
(0142) ** 输　入:
(0143) ** 输出	 :
(0144) ** 全局变量:
(0145) ** 调用模块: 
(0146) ** 说明：
(0147) ** 注意：
(0148) **************************************************************************/
(0149) void Seg7_Led_float(float data)
(0150) {
(0151)  unsigned int temp;
(0152)  /*
(0153)  重要说明:data+=0.00001;其中0.00001为容错值
(0154)  解决float数据类型在计算机内部存储的误差问题，可以解决显示问题
(0155)  但是会引入新的计算误差，如果精度要求大于0.00001建议更改容错值或者将此处注释掉 
(0156)  */
(0157)  data+=0.00001;
    006A7 802A      LDD	R2,Y+2
    006A8 803B      LDD	R3,Y+3
    006A9 804C      LDD	R4,Y+4
    006AA 805D      LDD	R5,Y+5
    006AB EF0C      LDI	R16,0xFC
    006AC E010      LDI	R17,0
    006AD 940E 0ABF CALL	elpm32
    006AF 933A      ST	-Y,R19
    006B0 932A      ST	-Y,R18
    006B1 931A      ST	-Y,R17
    006B2 930A      ST	-Y,R16
    006B3 0181      MOVW	R16,R2
    006B4 0192      MOVW	R18,R4
    006B5 940E 0BC1 CALL	fpadd2
    006B7 830A      STD	Y+2,R16
    006B8 831B      STD	Y+3,R17
    006B9 832C      STD	Y+4,R18
    006BA 833D      STD	Y+5,R19
(0158)  point=1;
    006BB E081      LDI	R24,1
    006BC 9380 02C9 STS	point,R24
(0159)  if(data>999) //错误处理,超出显示范围则全亮
    006BE 01CE      MOVW	R24,R28
    006BF 9602      ADIW	R24,2
    006C0 011C      MOVW	R2,R24
    006C1 EF08      LDI	R16,0xF8
    006C2 E010      LDI	R17,0
    006C3 940E 0ABF CALL	elpm32
    006C5 923A      ST	-Y,R3
    006C6 922A      ST	-Y,R2
    006C7 940E 0CF4 CALL	fpcmp1
    006C9 F434      BGE	0x06D0
(0160)  	{
(0161) 	 HC_595_OUT(0xFF);
    006CA EF0F      LDI	R16,0xFF
    006CB DEC3      RCALL	_HC_595_OUT
(0162) 	 Seg7_Bitselect_PORT|=((1<<Seg7_Bit0)|(1<<Seg7_Bit1)|(1<<Seg7_Bit2)|(1<<Seg7_Bit3));
    006CC B388      IN	R24,0x18
    006CD 6F80      ORI	R24,0xF0
    006CE BB88      OUT	0x18,R24
(0163) 	}
    006CF C0B6      RJMP	0x0786
(0164)  else if(data>99)
    006D0 01CE      MOVW	R24,R28
    006D1 9602      ADIW	R24,2
    006D2 011C      MOVW	R2,R24
    006D3 EF04      LDI	R16,0xF4
    006D4 E010      LDI	R17,0
    006D5 940E 0ABF CALL	elpm32
    006D7 923A      ST	-Y,R3
    006D8 922A      ST	-Y,R2
    006D9 940E 0CF4 CALL	fpcmp1
    006DB F5AC      BGE	0x0711
(0165)  	{
(0166) 	 temp=data*10;
    006DC EF00      LDI	R16,0xF0
    006DD E010      LDI	R17,0
    006DE 940E 0ABF CALL	elpm32
    006E0 01CE      MOVW	R24,R28
    006E1 9602      ADIW	R24,2
    006E2 939A      ST	-Y,R25
    006E3 938A      ST	-Y,R24
    006E4 940E 0CDD CALL	fpmule1
    006E6 940E 0BCC CALL	fpint
    006E8 0158      MOVW	R10,R16
(0167) 	 point_pos=1;
    006E9 E081      LDI	R24,1
    006EA 9380 02CA STS	point_pos,R24
(0168) 	 Seg7_Led_Buf[3]=temp/1000;
    006EC EE28      LDI	R18,0xE8
    006ED E033      LDI	R19,3
    006EE 940E 0A23 CALL	div16u
    006F0 9300 0301 STS	Seg7_Led_Buf+3,R16
(0169)  	 Seg7_Led_Buf[2]=(temp%1000)/100;
    006F2 EE28      LDI	R18,0xE8
    006F3 E033      LDI	R19,3
    006F4 0185      MOVW	R16,R10
    006F5 940E 0A21 CALL	mod16u
    006F7 E624      LDI	R18,0x64
    006F8 E030      LDI	R19,0
    006F9 940E 0A23 CALL	div16u
    006FB 9300 0300 STS	Seg7_Led_Buf+2,R16
(0170)  	 Seg7_Led_Buf[1]=(temp%100)/10;
    006FD E624      LDI	R18,0x64
    006FE E030      LDI	R19,0
    006FF 0185      MOVW	R16,R10
    00700 940E 0A21 CALL	mod16u
    00702 E02A      LDI	R18,0xA
    00703 E030      LDI	R19,0
    00704 940E 0A23 CALL	div16u
    00706 9300 02FF STS	Seg7_Led_Buf+1,R16
(0171)  	 Seg7_Led_Buf[0]=temp%10;
    00708 E02A      LDI	R18,0xA
    00709 E030      LDI	R19,0
    0070A 0185      MOVW	R16,R10
    0070B 940E 0A21 CALL	mod16u
    0070D 9300 02FE STS	Seg7_Led_Buf,R16
(0172) 	 Seg7_Led_Update();
    0070F DE88      RCALL	_Seg7_Led_Update
(0173) 	}
    00710 C075      RJMP	0x0786
(0174)  else if(data>9)
    00711 01CE      MOVW	R24,R28
    00712 9602      ADIW	R24,2
    00713 011C      MOVW	R2,R24
    00714 EE0C      LDI	R16,0xEC
    00715 E010      LDI	R17,0
    00716 940E 0ABF CALL	elpm32
    00718 923A      ST	-Y,R3
    00719 922A      ST	-Y,R2
    0071A 940E 0CF4 CALL	fpcmp1
    0071C F5AC      BGE	0x0752
(0175)  	{
(0176) 	 temp=data*100;
    0071D EE08      LDI	R16,0xE8
    0071E E010      LDI	R17,0
    0071F 940E 0ABF CALL	elpm32
    00721 01CE      MOVW	R24,R28
    00722 9602      ADIW	R24,2
    00723 939A      ST	-Y,R25
    00724 938A      ST	-Y,R24
    00725 940E 0CDD CALL	fpmule1
    00727 940E 0BCC CALL	fpint
    00729 0158      MOVW	R10,R16
(0177) 	 point_pos=2;
    0072A E082      LDI	R24,2
    0072B 9380 02CA STS	point_pos,R24
(0178) 	 Seg7_Led_Buf[3]=temp/1000;
    0072D EE28      LDI	R18,0xE8
    0072E E033      LDI	R19,3
    0072F 940E 0A23 CALL	div16u
    00731 9300 0301 STS	Seg7_Led_Buf+3,R16
(0179)  	 Seg7_Led_Buf[2]=(temp%1000)/100;
    00733 EE28      LDI	R18,0xE8
    00734 E033      LDI	R19,3
    00735 0185      MOVW	R16,R10
    00736 940E 0A21 CALL	mod16u
    00738 E624      LDI	R18,0x64
    00739 E030      LDI	R19,0
    0073A 940E 0A23 CALL	div16u
    0073C 9300 0300 STS	Seg7_Led_Buf+2,R16
(0180)  	 Seg7_Led_Buf[1]=(temp%100)/10;
    0073E E624      LDI	R18,0x64
    0073F E030      LDI	R19,0
    00740 0185      MOVW	R16,R10
    00741 940E 0A21 CALL	mod16u
    00743 E02A      LDI	R18,0xA
    00744 E030      LDI	R19,0
    00745 940E 0A23 CALL	div16u
    00747 9300 02FF STS	Seg7_Led_Buf+1,R16
(0181)  	 Seg7_Led_Buf[0]=temp%10;
    00749 E02A      LDI	R18,0xA
    0074A E030      LDI	R19,0
    0074B 0185      MOVW	R16,R10
    0074C 940E 0A21 CALL	mod16u
    0074E 9300 02FE STS	Seg7_Led_Buf,R16
(0182) 	 Seg7_Led_Update();
    00750 DE47      RCALL	_Seg7_Led_Update
(0183) 	}
    00751 C034      RJMP	0x0786
(0184)  else
(0185)  	{
(0186) 	 temp=data*1000;
    00752 EE04      LDI	R16,0xE4
    00753 E010      LDI	R17,0
    00754 940E 0ABF CALL	elpm32
    00756 01CE      MOVW	R24,R28
    00757 9602      ADIW	R24,2
    00758 939A      ST	-Y,R25
    00759 938A      ST	-Y,R24
    0075A 940E 0CDD CALL	fpmule1
    0075C 940E 0BCC CALL	fpint
    0075E 0158      MOVW	R10,R16
(0187) 	 point_pos=3;
    0075F E083      LDI	R24,3
    00760 9380 02CA STS	point_pos,R24
(0188) 	 Seg7_Led_Buf[3]=temp/1000;
    00762 EE28      LDI	R18,0xE8
    00763 E033      LDI	R19,3
    00764 940E 0A23 CALL	div16u
    00766 9300 0301 STS	Seg7_Led_Buf+3,R16
(0189)  	 Seg7_Led_Buf[2]=(temp%1000)/100;
    00768 EE28      LDI	R18,0xE8
    00769 E033      LDI	R19,3
    0076A 0185      MOVW	R16,R10
    0076B 940E 0A21 CALL	mod16u
    0076D E624      LDI	R18,0x64
    0076E E030      LDI	R19,0
    0076F 940E 0A23 CALL	div16u
    00771 9300 0300 STS	Seg7_Led_Buf+2,R16
(0190)  	 Seg7_Led_Buf[1]=(temp%100)/10;
    00773 E624      LDI	R18,0x64
    00774 E030      LDI	R19,0
    00775 0185      MOVW	R16,R10
    00776 940E 0A21 CALL	mod16u
    00778 E02A      LDI	R18,0xA
    00779 E030      LDI	R19,0
    0077A 940E 0A23 CALL	div16u
    0077C 9300 02FF STS	Seg7_Led_Buf+1,R16
(0191)  	 Seg7_Led_Buf[0]=temp%10;
    0077E E02A      LDI	R18,0xA
    0077F E030      LDI	R19,0
    00780 0185      MOVW	R16,R10
    00781 940E 0A21 CALL	mod16u
    00783 9300 02FE STS	Seg7_Led_Buf,R16
(0192) 	 Seg7_Led_Update();
    00785 DE12      RCALL	_Seg7_Led_Update
(0193) 	}
(0194)  point=0;
    00786 2422      CLR	R2
    00787 9220 02C9 STS	point,R2
    00789 90B9      LD	R11,Y+
    0078A 90A9      LD	R10,Y+
    0078B 9624      ADIW	R28,4
    0078C 9508      RET
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\key.c
(0001) /************************************************
(0002) 文件：key.c
(0003) 用途：
(0004) 注意：内部8M晶振
(0005) 创建：2008.4.1
(0006) 修改：2008.4.1
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) /*************************************************************************
(0011) ** 函数名称:键盘初始化
(0012) ** 功能描述:
(0013) ** 输　入:
(0014) ** 输出	 :
(0015) ** 全局变量:
(0016) ** 调用模块:
(0017) ** 说明：
(0018) ** 注意：
(0019) **************************************************************************/
(0020) void Key_init(void)
(0021) {
(0022)  KEY_DDR &=~ (1<<S1)|(1<<S2)|(1<<S3)|(1<<S4);
_Key_init:
    0078D 988C      CBI	0x11,4
(0023)  KEY_PORT |= (1<<S1)|(1<<S2)|(1<<S3)|(1<<S4);
    0078E B382      IN	R24,0x12
    0078F 6F80      ORI	R24,0xF0
    00790 BB82      OUT	0x12,R24
    00791 9508      RET
_get_key:
  tmp                  --> Y,+1
  Key_Value            --> R20
    00792 934A      ST	-Y,R20
(0024) }
(0025) /*************************************************************************
(0026) ** 函数名称:键盘扫描
(0027) ** 功能描述:
(0028) ** 输　入:
(0029) ** 输出	 :
(0030) ** 全局变量:
(0031) ** 调用模块:
(0032) ** 说明：
(0033) ** 注意：
(0034) **************************************************************************/
(0035) unsigned char get_key(void)
(0036) {
(0037)  unsigned char Key_Value=0xFF,tmp;
    00793 EF4F      LDI	R20,0xFF
(0038) 
(0039)  Key_Value=KEY_PIN & ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4));
    00794 B340      IN	R20,0x10
    00795 7F40      ANDI	R20,0xF0
(0040)  if( Key_Value != ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4)) )
    00796 3F40      CPI	R20,0xF0
    00797 F0B1      BEQ	0x07AE
(0041)  	 {
(0042) 	  delay_nms(2);
    00798 E002      LDI	R16,2
    00799 E010      LDI	R17,0
    0079A 940E 056F CALL	_delay_nms
(0043) 	  if( (KEY_PIN & ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4))) == Key_Value )
    0079C B380      IN	R24,0x10
    0079D 7F80      ANDI	R24,0xF0
    0079E 1784      CP	R24,R20
    0079F F471      BNE	0x07AE
(0044) 		 {
(0045) 		  Key_Value=KEY_PIN & ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4));
    007A0 B340      IN	R20,0x10
    007A1 7F40      ANDI	R20,0xF0
(0046) 		  //NOP();
(0047) 	  	  while(( KEY_PIN & ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4)) )!= ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4)));
    007A2 B380      IN	R24,0x10
    007A3 7F80      ANDI	R24,0xF0
    007A4 3F80      CPI	R24,0xF0
    007A5 F7E1      BNE	0x07A2
(0048) 		  delay_nms(1);
    007A6 E001      LDI	R16,1
    007A7 E010      LDI	R17,0
    007A8 940E 056F CALL	_delay_nms
(0049) 		  while(( KEY_PIN & ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4)) )!= ((1<<S1)|(1<<S2)|(1<<S3)|(1<<S4)));
    007AA B380      IN	R24,0x10
    007AB 7F80      ANDI	R24,0xF0
    007AC 3F80      CPI	R24,0xF0
    007AD F7E1      BNE	0x07AA
(0050) 		 }
(0051) 	 }
(0052) 	 
(0053)  return Key_Value;
    007AE 2F04      MOV	R16,R20
    007AF 9149      LD	R20,Y+
    007B0 9508      RET
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\sio.c
(0001) /************************************************
(0002) 文件：sio.c
(0003) 用途：结构化串口通信程序
(0004) 注意：
(0005) 创建：2008.1.26
(0006) 修改：2008.1.26
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) 
(0011) #if USEUART0
(0012) siocirqueue RTbuf_UART0;
(0013) #endif
(0014) #if USEUART1
(0015) siocirqueue RTbuf_UART1;
(0016) #endif
(0017) 
(0018) #if (CPU_TYPE == M32)||(CPU_TYPE == M16)||(CPU_TYPE == M8)
(0019) #define USEUART0  TRUE
(0020) #define USEUART1  FALSE
(0021) #define iv_USART0_RXC   iv_USART_RXC
(0022) #define iv_USART0_TXC   iv_USART_TXC
(0023) #define UDR0  	  UDR
(0024) #define UCSR0A    UCSRA
(0025) #define UCSR0B    UCSRB
(0026) #define UCSR0C	  UCSRC
(0027) #define UBRR0H	  UBRRH
(0028) #define UBRR0L	  UBRRL
(0029) #define RXCIE0	  RXCIE
(0030) #define TXCIE0	  TXCIE
(0031) #endif
(0032) 
(0033) 
(0034) /*********************************************************************************************************
(0035) ** 函数名称: Com_init
(0036) ** 功能描述: 初始化串行口
(0037) ** 输　入:
(0038) ** 全局变量: 无
(0039) ** 调用模块: Com_baudrate
(0040) ** 说明：
(0041) ** 注意：
(0042) ********************************************************************************************************/
(0043) void Com_init (void) {
(0044) //WDR(); //喂狗
(0045) //CLI();                     // 关中断
(0046) #if USEUART0
(0047)     Tbuf_init(&RTbuf_UART0);              //初始化接收缓冲
_Com_init:
    007B1 E002      LDI	R16,2
    007B2 E013      LDI	R17,3
    007B3 D0E2      RCALL	_Tbuf_init
(0048)     Rbuf_init(&RTbuf_UART0);
    007B4 E002      LDI	R16,2
    007B5 E013      LDI	R17,3
    007B6 D0D8      RCALL	_Rbuf_init
(0049)     UCSR0B = 0x00; //disable while setting baud rate
    007B7 2422      CLR	R2
    007B8 B82A      OUT	0x0A,R2
(0050)     UCSR0A=0x00;
    007B9 B82B      OUT	0x0B,R2
(0051) 
(0052) #if CPU_TYPE <= M32
(0053)     UCSRC = (1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0);
(0054)     UCSR0B = (1<<RXCIE)|(1<<TXCIE)|(1<<RXEN)|(1<<TXEN);  // RXCIE=1;TXCIE=1;UDREIE=0;RXEN=1;TXEN=1
(0055) #else
(0056)     UCSR0C=0x06;  //8 DATA ,1 STOP, NO PARITY
    007BA E086      LDI	R24,6
    007BB 9380 0095 STS	0x95,R24
(0057) //    UCSR0B = (1<<RXCIE0)|(1<<TXCIE0)|(1<<RXEN0)|(1<<TXEN0);  // RXCIE=1;TXCIE=1;UDREIE=0;RXEN=1;TXEN=1
(0058) 	
(0059)     UCSR0B |= (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0);  //允许发送和接收,接收中断使能
    007BD B18A      IN	R24,0x0A
    007BE 6988      ORI	R24,0x98
    007BF B98A      OUT	0x0A,R24
(0060) 	
(0061) #endif
(0062) 
(0063) #endif
(0064) 
(0065) 
(0066) #if USEUART1
(0067)     Tbuf_init(&RTbuf_B);              //初始化接收缓冲
(0068)     Rbuf_init(&RTbuf_B);
(0069)     UCSR1B = 0x00; //disable while setting baud rate
(0070)     UCSR1A = 0x00;
(0071)     UCSR1C = 0x06;
(0072)     UCSR1B = 0xD8;
(0073) #endif
(0074)     Com_baudrate (9600);		 //
    007C0 E800      LDI	R16,0x80
    007C1 E215      LDI	R17,0x25
    007C2 C000      RJMP	_Com_baudrate
_Com_baudrate:
  tmp                  --> R10
  baudrate             --> R10
    007C3 940E 0B22 CALL	push_xgsetF00C
    007C5 0158      MOVW	R10,R16
(0075) 
(0076) //SEI();                     // 开中断
(0077) }
(0078) /*********************************************************************************************************
(0079) ** 函数名称: Com_baudrate
(0080) ** 功能描述: 利用定时器T1产生由参数baudrate指定的波特率
(0081) ** 输　入: baudrate指定的波特率
(0082) ** 全局变量: 无
(0083) ** 调用模块: 无
(0084) ** 说明：
(0085) ** 注意：
(0086) ********************************************************************************************************/
(0087) void Com_baudrate (unsigned int baudrate) {
(0088)     unsigned int tmp;
(0089)     tmp= F_CPU/baudrate/16-1;
    007C6 0115      MOVW	R2,R10
    007C7 2444      CLR	R4
    007C8 2455      CLR	R5
    007C9 E040      LDI	R20,0
    007CA E152      LDI	R21,0x12
    007CB E76A      LDI	R22,0x7A
    007CC E070      LDI	R23,0
    007CD 925A      ST	-Y,R5
    007CE 924A      ST	-Y,R4
    007CF 923A      ST	-Y,R3
    007D0 922A      ST	-Y,R2
    007D1 018A      MOVW	R16,R20
    007D2 019B      MOVW	R18,R22
    007D3 940E 0A43 CALL	div32s
    007D5 E140      LDI	R20,0x10
    007D6 E050      LDI	R21,0
    007D7 E060      LDI	R22,0
    007D8 E070      LDI	R23,0
    007D9 937A      ST	-Y,R23
    007DA 936A      ST	-Y,R22
    007DB 935A      ST	-Y,R21
    007DC 934A      ST	-Y,R20
    007DD 940E 0A43 CALL	div32s
    007DF 0118      MOVW	R2,R16
    007E0 0129      MOVW	R4,R18
    007E1 E041      LDI	R20,1
    007E2 E050      LDI	R21,0
    007E3 E060      LDI	R22,0
    007E4 E070      LDI	R23,0
    007E5 1A24      SUB	R2,R20
    007E6 0A35      SBC	R3,R21
    007E7 0A46      SBC	R4,R22
    007E8 0A57      SBC	R5,R23
    007E9 0151      MOVW	R10,R2
(0090) #if USEUART0
(0091)     UBRR0H=(unsigned char)(tmp>>8);
    007EA 2C23      MOV	R2,R3
    007EB 2433      CLR	R3
    007EC 9220 0090 STS	0x90,R2
(0092)     UBRR0L=(unsigned char)tmp;
    007EE B8A9      OUT	0x09,R10
    007EF 940C 0B29 JMP	pop_xgsetF00C
_Com_putchar:
  RTbuf                --> R12
  c                    --> R10
    007F1 940E 0B09 CALL	push_xgset003C
    007F3 0169      MOVW	R12,R18
    007F4 2EA0      MOV	R10,R16
(0093) #endif
(0094) #if USEUART1
(0095)     UBRR1H=(unsigned char)(tmp>>8);
(0096)     UBRR1L=(unsigned char)tmp;
(0097) #endif
(0098) }
(0099) /*********************************************************************************************************
(0100) ** 函数名称: Com_putchar
(0101) ** 功能描述: 从串行口输出一个字符c
(0102) ** 输　入: c:输出字符
(0103) ** 输出	 : 0:失败 1:成功
(0104) ** 全局变量: 无
(0105) ** 调用模块:
(0106) ** 说明：
(0107) ** 注意：
(0108) ********************************************************************************************************/
(0109) unsigned char Com_putchar (unsigned char c,siocirqueue *RTbuf) {
(0110) //WDR(); //喂狗
(0111)     if (Tbuf_full(RTbuf))
    007F5 0186      MOVW	R16,R12
    007F6 D0C4      RCALL	_Tbuf_full
    007F7 2300      TST	R16
    007F8 F011      BEQ	0x07FB
(0112)         return(0);
    007F9 2700      CLR	R16
    007FA C004      RJMP	0x07FF
(0113)     else {
(0114)         Tbuf_putchar(c,RTbuf);				// 将数据加入到发送缓冲区并开中断
    007FB 0196      MOVW	R18,R12
    007FC 2D0A      MOV	R16,R10
    007FD D0CE      RCALL	_Tbuf_putchar
(0115)         return(1);
    007FE E001      LDI	R16,1
    007FF 940C 0AE3 JMP	pop_xgset003C
_Com_putstring:
  i                    --> R14
  RTbuf                --> R12
  len                  --> R20
  p                    --> R10
    00801 940E 0B05 CALL	push_xgset30FC
    00803 2F42      MOV	R20,R18
    00804 0158      MOVW	R10,R16
    00805 84C8      LDD	R12,Y+8
    00806 84D9      LDD	R13,Y+9
(0116)     }
(0117) }
(0118) /*********************************************************************************************************
(0119) ** 函数名称: Com_putstring
(0120) ** 功能描述: 从串行口输出一个字符串
(0121) ** 输　入: p:指向输出字符串 len:输出长度
(0122) ** 输出	 :
(0123) ** 全局变量: 无
(0124) ** 调用模块:
(0125) ** 说明：
(0126) ** 注意：
(0127) ********************************************************************************************************/
(0128) void Com_putstring (unsigned char *p,unsigned char len,siocirqueue *RTbuf) {
(0129)     unsigned char i;
(0130) //WDR(); //喂狗
(0131)     if (len!=0 ) {
    00807 2344      TST	R20
    00808 F079      BEQ	0x0818
(0132)         for(i=0; i<len; i++)
    00809 24EE      CLR	R14
    0080A C00A      RJMP	0x0815
(0133)             while(Com_putchar(p[i],RTbuf)==0);//WDR(); //喂狗;
    0080B 0196      MOVW	R18,R12
    0080C 2DEE      MOV	R30,R14
    0080D 27FF      CLR	R31
    0080E 0DEA      ADD	R30,R10
    0080F 1DFB      ADC	R31,R11
    00810 8100      LD	R16,Z
    00811 DFDF      RCALL	_Com_putchar
    00812 2300      TST	R16
    00813 F3B9      BEQ	0x080B
    00814 94E3      INC	R14
    00815 16E4      CP	R14,R20
    00816 F3A0      BCS	0x080B
(0134)     } else {
    00817 C00B      RJMP	0x0823
(0135)         do {
(0136)             while(Com_putchar(*p,RTbuf)==0);//WDR(); //喂狗;
    00818 0196      MOVW	R18,R12
    00819 01F5      MOVW	R30,R10
    0081A 8100      LD	R16,Z
    0081B DFD5      RCALL	_Com_putchar
    0081C 2300      TST	R16
    0081D F3D1      BEQ	0x0818
(0137)         } while(*p++!='\n');
    0081E 01F5      MOVW	R30,R10
    0081F 9181      LD	R24,Z+
    00820 015F      MOVW	R10,R30
    00821 308A      CPI	R24,0xA
    00822 F7A9      BNE	0x0818
(0138)     }
    00823 940C 0AEF JMP	pop_xgset30FC
_Com_getchar:
  ts                   --> R20
  RTbuf                --> R10
  mode                 --> Y,+6
    00825 940E 0A1C CALL	push_arg4
    00827 940E 0B0E CALL	push_xgset300C
    00829 0159      MOVW	R10,R18
    0082A 9722      SBIW	R28,2
(0139) 
(0140) }
(0141) /*********************************************************************************************************
(0142) ** 函数名称: Com_getchar
(0143) ** 功能描述: 从串行口输入一个字符
(0144) ** 输　入: mode：0不需等待，在调用函数前检测Com_R_count的值
(0145) **              1 等待数据到来
(0146) ** 输出	 : 读入的字符
(0147) ** 全局变量: 无
(0148) ** 调用模块:
(0149) ** 说明：
(0150) ** 注意：
(0151) ********************************************************************************************************/
(0152) 
(0153) unsigned char Com_getchar (unsigned char mode,siocirqueue *RTbuf) {
(0154) //WDR(); //喂狗
(0155) //    Delay(Delay_Comget,MaxLimit_Comget_Delay);
(0156) //	if (mode>0) while(Com_R_count(RTbuf)==0 && !DelayOvf(Delay_Comget))//WDR(); //喂狗;
(0157) //	if (DelayOvf(Delay_Comget))
(0158) //	    return 0;    //时间超时
(0159) //	else
(0160) 	unsigned char *ts="??!\n";
    0082B ED40      LDI	R20,0xD0
    0082C E052      LDI	R21,2
(0161) 	Com_putstring (ts,4,&RTbuf_UART0);
    0082D E082      LDI	R24,2
    0082E E093      LDI	R25,3
    0082F 8399      STD	Y+1,R25
    00830 8388      ST	Y,R24
    00831 E024      LDI	R18,4
    00832 018A      MOVW	R16,R20
    00833 DFCD      RCALL	_Com_putstring
(0162)     while(!Com_R_count(RTbuf));
    00834 0185      MOVW	R16,R10
    00835 D056      RCALL	_Com_R_count
    00836 2300      TST	R16
    00837 F3E1      BEQ	0x0834
(0163) 	Com_putstring (ts,4,&RTbuf_UART0);
    00838 E082      LDI	R24,2
    00839 E093      LDI	R25,3
    0083A 8399      STD	Y+1,R25
    0083B 8388      ST	Y,R24
    0083C E024      LDI	R18,4
    0083D 018A      MOVW	R16,R20
    0083E DFC2      RCALL	_Com_putstring
(0164) 	
(0165)     return (Rbuf_getchar(RTbuf));// 串行口输入正确，返回输入的字符
    0083F 0185      MOVW	R16,R10
    00840 D0C2      RCALL	_Rbuf_getchar
    00841 9622      ADIW	R28,2
    00842 940E 0B13 CALL	pop_xgset300C
    00844 9624      ADIW	R28,4
    00845 9508      RET
_Com_Rbuf_Clear:
  RTbuf                --> R10
    00846 92AA      ST	-Y,R10
    00847 92BA      ST	-Y,R11
    00848 0158      MOVW	R10,R16
(0166) }
(0167) 
(0168) 
(0169) 
(0170) void Com_Rbuf_Clear(siocirqueue *RTbuf) {
(0171)     Rbuf_init(RTbuf);
    00849 0185      MOVW	R16,R10
    0084A D044      RCALL	_Rbuf_init
    0084B 90B9      LD	R11,Y+
    0084C 90A9      LD	R10,Y+
    0084D 9508      RET
_Com_getstring:
  ts                   --> R22
  i                    --> R10
  RTbuf                --> R12
  len                  --> R14
  p                    --> R20
    0084E 940E 0B03 CALL	push_xgsetF0FC
    00850 2EE2      MOV	R14,R18
    00851 01A8      MOVW	R20,R16
    00852 9722      SBIW	R28,2
    00853 84CC      LDD	R12,Y+12
    00854 84DD      LDD	R13,Y+13
(0172) }
(0173) 
(0174) 
(0175) 
(0176) unsigned char Com_getstring (unsigned char *p,unsigned char len,siocirqueue *RTbuf) {
(0177) 
(0178)     unsigned char i=0;
    00855 24AA      CLR	R10
(0179) 	unsigned char *ts="???\n";
    00856 EC6B      LDI	R22,0xCB
    00857 E072      LDI	R23,2
(0180)     //WDR(); //喂狗
(0181)     if (len>0 ) {
    00858 E080      LDI	R24,0
    00859 158E      CP	R24,R14
    0085A F508      BCC	0x087C
(0182)         for(i=0; i<len; i++) {
    0085B C01C      RJMP	0x0878
(0183)             //WDR(); //喂狗
(0184) 			
(0185) 			//debug_start
(0186) 			Com_putstring (ts,4,&RTbuf_UART0);
    0085C E082      LDI	R24,2
    0085D E093      LDI	R25,3
    0085E 8399      STD	Y+1,R25
    0085F 8388      ST	Y,R24
    00860 E024      LDI	R18,4
    00861 018B      MOVW	R16,R22
    00862 DF9E      RCALL	_Com_putstring
(0187) 			Com_putstring (ts,4,&RTbuf_UART0);
    00863 E082      LDI	R24,2
    00864 E093      LDI	R25,3
    00865 8399      STD	Y+1,R25
    00866 8388      ST	Y,R24
    00867 E024      LDI	R18,4
    00868 018B      MOVW	R16,R22
    00869 DF97      RCALL	_Com_putstring
(0188)             *p++=Com_getchar(1,RTbuf);
    0086A 0196      MOVW	R18,R12
    0086B E001      LDI	R16,1
    0086C DFB8      RCALL	_Com_getchar
    0086D 01FA      MOVW	R30,R20
    0086E 9301      ST	Z+,R16
    0086F 01AF      MOVW	R20,R30
(0189) 			Com_putstring (ts,4,&RTbuf_UART0);
    00870 E082      LDI	R24,2
    00871 E093      LDI	R25,3
    00872 8399      STD	Y+1,R25
    00873 8388      ST	Y,R24
    00874 E024      LDI	R18,4
    00875 018B      MOVW	R16,R22
    00876 DF8A      RCALL	_Com_putstring
    00877 94A3      INC	R10
    00878 14AE      CP	R10,R14
    00879 F310      BCS	0x085C
(0190) 			
(0191) 			
(0192) 			//debug_start
(0193)         }
(0194)         return(len);
    0087A 2D0E      MOV	R16,R14
    0087B C00D      RJMP	0x0889
(0195)     } else {
(0196) 
(0197)         do {
(0198)             *p++=Com_getchar(1,RTbuf);
    0087C 0196      MOVW	R18,R12
    0087D E001      LDI	R16,1
    0087E DFA6      RCALL	_Com_getchar
    0087F 01FA      MOVW	R30,R20
    00880 9301      ST	Z+,R16
    00881 01AF      MOVW	R20,R30
(0199)             i++;
    00882 94A3      INC	R10
(0200)             //WDR(); //喂狗
(0201)         } while(*(p-1)!='\n');
    00883 01FA      MOVW	R30,R20
    00884 9731      SBIW	R30,1
    00885 8180      LD	R24,Z
    00886 308A      CPI	R24,0xA
    00887 F7A1      BNE	0x087C
(0202) //			*p++=Com_getchar(1,RTbuf);
(0203) //			*(p)=0;
(0204)         return(i);
    00888 2D0A      MOV	R16,R10
    00889 9622      ADIW	R28,2
    0088A 940C 0AF8 JMP	pop_xgsetF0FC
(0205)     }
(0206) 
(0207) }
(0208) 
(0209) 
(0210) /*********************************************************************************************************
(0211) ** 函数名称: Com_R_count
(0212) ** 功能描述: 返回接收缓冲区字符个数函数
(0213) ** 输　入:
(0214) ** 输出	 : 字符个数
(0215) ** 全局变量: 无
(0216) ** 调用模块:
(0217) ** 说明：
(0218) ** 注意：
(0219) ********************************************************************************************************/
(0220) unsigned char Com_R_count(siocirqueue *RTbuf) {
(0221)     return RTbuf->R_count;
_Com_R_count:
  RTbuf                --> R16
    0088C 01F8      MOVW	R30,R16
    0088D 8102      LDD	R16,Z+2
    0088E 9508      RET
(0222) }
(0223) /*********************************************************************************************************
(0224) ** 函数名称: Rbuf_init
(0225) ** 功能描述: 接收缓冲区初始化
(0226) ** 输　入:
(0227) ** 输出	 :
(0228) ** 全局变量: 无
(0229) ** 调用模块:
(0230) ** 说明：
(0231) ** 注意：
(0232) ********************************************************************************************************/
(0233) void Rbuf_init(siocirqueue *RTbuf) {
(0234)     RTbuf->R_front=0;
_Rbuf_init:
  RTbuf                --> R16
    0088F 2422      CLR	R2
    00890 01F8      MOVW	R30,R16
    00891 8220      ST	Z,R2
(0235)     RTbuf->R_rear=0;
    00892 8221      STD	Z+1,R2
(0236)     RTbuf->R_count=0;
    00893 8222      STD	Z+2,R2
(0237)     RTbuf->R_overflow=0;
    00894 8223      STD	Z+3,R2
    00895 9508      RET
(0238) }
(0239) /*********************************************************************************************************
(0240) ** 函数名称: Tbuf_init
(0241) ** 功能描述: 发送缓冲区初始化
(0242) ** 输　入:
(0243) ** 输出	 :
(0244) ** 全局变量: 无
(0245) ** 调用模块:
(0246) ** 说明：
(0247) ** 注意：
(0248) ********************************************************************************************************/
(0249) void Tbuf_init(siocirqueue *RTbuf) {
(0250)     RTbuf->T_front=0;
_Tbuf_init:
  RTbuf                --> R16
    00896 2422      CLR	R2
    00897 01F8      MOVW	R30,R16
    00898 59E8      SUBI	R30,0x98
    00899 4FFF      SBCI	R31,0xFF
    0089A 8220      ST	Z,R2
    0089B 56E8      SUBI	R30,0x68
    0089C 40F0      SBCI	R31,0
(0251)     RTbuf->T_rear=0;
    0089D 59E7      SUBI	R30,0x97
    0089E 4FFF      SBCI	R31,0xFF
    0089F 8220      ST	Z,R2
    008A0 56E9      SUBI	R30,0x69
    008A1 40F0      SBCI	R31,0
(0252)     RTbuf->T_count=0;
    008A2 59E6      SUBI	R30,0x96
    008A3 4FFF      SBCI	R31,0xFF
    008A4 8220      ST	Z,R2
    008A5 56EA      SUBI	R30,0x6A
    008A6 40F0      SBCI	R31,0
(0253)     RTbuf->T_disabled=1;
    008A7 E081      LDI	R24,1
    008A8 53E1      SUBI	R30,0x31
    008A9 4FFF      SBCI	R31,0xFF
    008AA 8380      ST	Z,R24
    008AB 9508      RET
_Rbuf_empty:
  RTbuf                --> R16
    008AC 934A      ST	-Y,R20
    008AD 935A      ST	-Y,R21
(0254) }
(0255) /*********************************************************************************************************
(0256) ** 函数名称: Rbuf_empty
(0257) ** 功能描述: 接收缓冲区判空
(0258) ** 输　入:
(0259) ** 输出	 :  TRUE 空 FALSE 非空
(0260) ** 全局变量: 无
(0261) ** 调用模块:
(0262) ** 说明：
(0263) ** 注意：
(0264) ********************************************************************************************************/
(0265) unsigned char Rbuf_empty(siocirqueue *RTbuf) {
(0266)     return RTbuf->R_count==0;
    008AE 01F8      MOVW	R30,R16
    008AF 8022      LDD	R2,Z+2
    008B0 2022      TST	R2
    008B1 F419      BNE	0x08B5
    008B2 E041      LDI	R20,1
    008B3 E050      LDI	R21,0
    008B4 C002      RJMP	0x08B7
    008B5 2744      CLR	R20
    008B6 2755      CLR	R21
    008B7 2F04      MOV	R16,R20
    008B8 9159      LD	R21,Y+
    008B9 9149      LD	R20,Y+
    008BA 9508      RET
_Tbuf_full:
  RTbuf                --> R16
    008BB 934A      ST	-Y,R20
    008BC 935A      ST	-Y,R21
(0267) }
(0268) /*********************************************************************************************************
(0269) ** 函数名称: Tbuf_empty
(0270) ** 功能描述: 发送缓冲区判空
(0271) ** 输　入:
(0272) ** 输出	 :  TRUE 空 FALSE 非空
(0273) ** 全局变量: 无
(0274) ** 调用模块:
(0275) ** 说明：
(0276) ** 注意：
(0277) ********************************************************************************************************
(0278) unsigned char Tbuf_empty(void){
(0279) 	return RTbuf->T_count==0;
(0280) 	}
(0281) /*********************************************************************************************************
(0282) ** 函数名称: Rbuf_full
(0283) ** 功能描述: 接收缓冲区判满
(0284) ** 输　入:
(0285) ** 输出	 :  TRUE 满 FALSE 非满
(0286) ** 全局变量: 无
(0287) ** 调用模块:
(0288) ** 说明：
(0289) ** 注意：
(0290) ********************************************************************************************************
(0291) unsigned char Rbuf_full (void){
(0292) 	return RTbuf->R_count==RBUF_SIZE;
(0293) 	}
(0294) /*********************************************************************************************************
(0295) ** 函数名称: Tbuf_full
(0296) ** 功能描述: 发送缓冲区判满
(0297) ** 输　入:
(0298) ** 输出	 :  TRUE 满 FALSE 非满
(0299) ** 全局变量: 无
(0300) ** 调用模块:
(0301) ** 说明：
(0302) ** 注意：
(0303) ********************************************************************************************************/
(0304) unsigned char Tbuf_full(siocirqueue *RTbuf) {
(0305)     return RTbuf->T_count==TBUF_SIZE;
    008BD 01F8      MOVW	R30,R16
    008BE 59E6      SUBI	R30,0x96
    008BF 4FFF      SBCI	R31,0xFF
    008C0 8180      LD	R24,Z
    008C1 3684      CPI	R24,0x64
    008C2 F419      BNE	0x08C6
    008C3 E041      LDI	R20,1
    008C4 E050      LDI	R21,0
    008C5 C002      RJMP	0x08C8
    008C6 2744      CLR	R20
    008C7 2755      CLR	R21
    008C8 2F04      MOV	R16,R20
    008C9 9159      LD	R21,Y+
    008CA 9149      LD	R20,Y+
    008CB 9508      RET
_Tbuf_putchar:
  RTbuf                --> R20
  x                    --> R10
    008CC 940E 0B0E CALL	push_xgset300C
    008CE 01A9      MOVW	R20,R18
    008CF 2EA0      MOV	R10,R16
(0306) }
(0307) /*********************************************************************************************************
(0308) ** 函数名称: Rbuf_putchar
(0309) ** 功能描述: 把一个字符放入接收缓冲区
(0310) ** 输　入:
(0311) ** 输出	 :
(0312) ** 全局变量: 无
(0313) ** 调用模块:
(0314) ** 说明：
(0315) ** 注意：
(0316) ********************************************************************************************************
(0317) void  Rbuf_putchar (unsigned char x){
(0318) 	if(!Rbuf_full()){
(0319) 		REV_DIS();
(0320) 		RTbuf->R_count++;
(0321) 		RTbuf->R_buf[RTbuf->R_rear]=x;
(0322) 		RTbuf->R_rear=(RTbuf->R_rear+1) % RBUF_SIZE;
(0323) 		REV_EN();
(0324) 	}
(0325) }
(0326) /*********************************************************************************************************
(0327) ** 函数名称: Tbuf_putchar
(0328) ** 功能描述: 把一个字符放入发送缓冲区
(0329) ** 输　入:
(0330) ** 输出	 :
(0331) ** 全局变量: 无
(0332) ** 调用模块:
(0333) ** 说明：
(0334) ** 注意：
(0335) ********************************************************************************************************/
(0336) void Tbuf_putchar(unsigned char x,siocirqueue *RTbuf) {
(0337)     if(!Tbuf_full(RTbuf)) {
    008D0 018A      MOVW	R16,R20
    008D1 DFE9      RCALL	_Tbuf_full
    008D2 2300      TST	R16
    008D3 F009      BEQ	0x08D5
    008D4 C02C      RJMP	0x0901
(0338)         TXC_DIS();
    008D5 9856      CBI	0x0A,6
(0339)         if (RTbuf->T_disabled) {
    008D6 01FA      MOVW	R30,R20
    008D7 53E1      SUBI	R30,0x31
    008D8 4FFF      SBCI	R31,0xFF
    008D9 8020      LD	R2,Z
    008DA 5CEF      SUBI	R30,0xCF
    008DB 40F0      SBCI	R31,0
    008DC 2022      TST	R2
    008DD F031      BEQ	0x08E4
(0340)             UDR0=x;
    008DE B8AC      OUT	0x0C,R10
(0341)             RTbuf->T_disabled=0;
    008DF 2422      CLR	R2
    008E0 53E1      SUBI	R30,0x31
    008E1 4FFF      SBCI	R31,0xFF
    008E2 8220      ST	Z,R2
(0342)         } else {
    008E3 C01C      RJMP	0x0900
(0343)             RTbuf->T_count++;
    008E4 01CA      MOVW	R24,R20
    008E5 5986      SUBI	R24,0x96
    008E6 4F9F      SBCI	R25,0xFF
    008E7 01FC      MOVW	R30,R24
    008E8 8180      LD	R24,Z
    008E9 5F8F      SUBI	R24,0xFF
    008EA 8380      ST	Z,R24
(0344)             RTbuf->T_buf[RTbuf->T_rear]=x;
    008EB 01CA      MOVW	R24,R20
    008EC 5985      SUBI	R24,0x95
    008ED 4F9F      SBCI	R25,0xFF
    008EE 01FA      MOVW	R30,R20
    008EF 59E7      SUBI	R30,0x97
    008F0 4FFF      SBCI	R31,0xFF
    008F1 81E0      LD	R30,Z
    008F2 27FF      CLR	R31
    008F3 0FE8      ADD	R30,R24
    008F4 1FF9      ADC	R31,R25
    008F5 82A0      ST	Z,R10
(0345)             RTbuf->T_rear=(RTbuf->T_rear+1) % TBUF_SIZE;
    008F6 5947      SUBI	R20,0x97
    008F7 4F5F      SBCI	R21,0xFF
    008F8 E614      LDI	R17,0x64
    008F9 01FA      MOVW	R30,R20
    008FA 8100      LD	R16,Z
    008FB 5F0F      SUBI	R16,0xFF
    008FC 940E 0AA7 CALL	mod8u
    008FE 01FA      MOVW	R30,R20
    008FF 8300      ST	Z,R16
(0346)         }
(0347)         TXC_EN();
    00900 9A56      SBI	0x0A,6
(0348)     }
    00901 940C 0B13 JMP	pop_xgset300C
_Rbuf_getchar:
  Btemp                --> R10
  RTbuf                --> R20
    00903 940E 0B0E CALL	push_xgset300C
    00905 01A8      MOVW	R20,R16
(0349) }
(0350) /*********************************************************************************************************
(0351) ** 函数名称: Rbuf_getstring
(0352) ** 功能描述: 从接收缓冲区返回当前子串指针
(0353) ** 输　入:
(0354) ** 输出	 :  当前子串指针
(0355) ** 全局变量: 无
(0356) ** 调用模块:
(0357) ** 说明：
(0358) ** 注意：
(0359) ********************************************************************************************************
(0360) unsigned char * Rbuf_getstring(void){
(0361) 	return (RTbuf->R_buf[RTbuf->R_front]);
(0362) }
(0363) /*********************************************************************************************************
(0364) ** 函数名称: Tbuf_getstring
(0365) ** 功能描述: 从发送缓冲区返回当前子串指针
(0366) ** 输　入:
(0367) ** 输出	 :  当前子串指针
(0368) ** 全局变量: 无
(0369) ** 调用模块:
(0370) ** 说明：
(0371) ** 注意：
(0372) ********************************************************************************************************
(0373) unsigned char * Tbuf_getstring(void){
(0374) 	return (RTbuf->T_buf[RTbuf->T_front]);
(0375) }
(0376) /*********************************************************************************************************
(0377) ** 函数名称: Rbuf_putchar
(0378) ** 功能描述: 从接收缓冲区读一个字符
(0379) ** 输　入:
(0380) ** 输出	 :  读字符
(0381) ** 全局变量: 无
(0382) ** 调用模块:
(0383) ** 说明：
(0384) ** 注意：
(0385) ********************************************************************************************************/
(0386) unsigned char Rbuf_getchar(siocirqueue *RTbuf) {
(0387)     unsigned char Btemp=0;
    00906 24AA      CLR	R10
(0388)     if (!Rbuf_empty(RTbuf)) {
    00907 018A      MOVW	R16,R20
    00908 DFA3      RCALL	_Rbuf_empty
    00909 2300      TST	R16
    0090A F4C1      BNE	0x0923
(0389)         Btemp=RTbuf->R_buf[RTbuf->R_front];
    0090B 01CA      MOVW	R24,R20
    0090C 9604      ADIW	R24,4
    0090D 01FA      MOVW	R30,R20
    0090E 81E0      LD	R30,Z
    0090F 27FF      CLR	R31
    00910 0FE8      ADD	R30,R24
    00911 1FF9      ADC	R31,R25
    00912 80A0      LD	R10,Z
(0390)         REV_DIS();
    00913 9857      CBI	0x0A,7
(0391)         RTbuf->R_count--;
    00914 01CA      MOVW	R24,R20
    00915 9602      ADIW	R24,2
    00916 01FC      MOVW	R30,R24
    00917 8180      LD	R24,Z
    00918 5081      SUBI	R24,1
    00919 8380      ST	Z,R24
(0392)         RTbuf->R_front=(RTbuf->R_front+1) % RBUF_SIZE;
    0091A E614      LDI	R17,0x64
    0091B 01FA      MOVW	R30,R20
    0091C 8100      LD	R16,Z
    0091D 5F0F      SUBI	R16,0xFF
    0091E 940E 0AA7 CALL	mod8u
    00920 01FA      MOVW	R30,R20
    00921 8300      ST	Z,R16
(0393)         REV_EN();
    00922 9A57      SBI	0x0A,7
(0394)     }
(0395)     return (Btemp);
    00923 2D0A      MOV	R16,R10
    00924 940C 0B13 JMP	pop_xgset300C
_uart0_rx_isr:
  data                 --> R10
  status               --> R22
  RTbuf                --> R20
    00926 922A      ST	-Y,R2
    00927 923A      ST	-Y,R3
    00928 930A      ST	-Y,R16
    00929 931A      ST	-Y,R17
    0092A 938A      ST	-Y,R24
    0092B 939A      ST	-Y,R25
    0092C 93EA      ST	-Y,R30
    0092D 93FA      ST	-Y,R31
    0092E B62F      IN	R2,0x3F
    0092F 922A      ST	-Y,R2
    00930 940E 0B22 CALL	push_xgsetF00C
(0396) 
(0397) }
(0398) /*********************************************************************************************************
(0399) ** 函数名称: Tbuf_getchar
(0400) ** 功能描述: 从发送缓冲区读一个字符
(0401) ** 输　入:
(0402) ** 输出	 :  读字符
(0403) ** 全局变量: 无
(0404) ** 调用模块:
(0405) ** 说明：
(0406) ** 注意：
(0407) ********************************************************************************************************
(0408) unsigned char Tbuf_getchar(void){
(0409) 	unsigned char Btemp;
(0410) 	if (!Tbuf_empty()){
(0411) 		Btemp=RTbuf->T_buf[RTbuf->T_front];
(0412) 		TXC_DIS();
(0413) 		RTbuf->T_count--;
(0414) 		RTbuf->T_front=(RTbuf->T_front+1) % TBUF_SIZE;
(0415) 		TXC_EN();
(0416) 		return (Btemp);
(0417) 	}
(0418) }
(0419) */
(0420) 
(0421) /******************************* 中断处理函数 ***************************
(0422) * 功能：完成数据得的接收和发送
(0423) ***********************************************************************/
(0424) #if USEUART0
(0425) #pragma interrupt_handler uart0_rx_isr:iv_USART0_RXC
(0426) void uart0_rx_isr(void) {
(0427)     unsigned char status,data;
(0428)     siocirqueue *RTbuf;
(0429)     RTbuf=&RTbuf_UART0;
    00932 E042      LDI	R20,2
    00933 E053      LDI	R21,3
(0430) // CLI();
(0431)     status=UCSR0A;
    00934 B16B      IN	R22,0x0B
(0432)     data=UDR0;
    00935 B0AC      IN	R10,0x0C
(0433) //WDR(); //喂狗
(0434)     if((status & (FRAMING_ERROR | DATA_OVERRUN))==0) {
    00936 2F86      MOV	R24,R22
    00937 7188      ANDI	R24,0x18
    00938 F009      BEQ	0x093A
    00939 C022      RJMP	0x095C
(0435)         if(RTbuf->R_count<RBUF_SIZE) {
    0093A 01FA      MOVW	R30,R20
    0093B 8182      LDD	R24,Z+2
    0093C 3684      CPI	R24,0x64
    0093D F008      BCS	0x093F
    0093E C01A      RJMP	0x0959
(0436)             RTbuf->R_count++;
    0093F 01CF      MOVW	R24,R30
    00940 9602      ADIW	R24,2
    00941 01FC      MOVW	R30,R24
    00942 8180      LD	R24,Z
    00943 5F8F      SUBI	R24,0xFF
    00944 8380      ST	Z,R24
(0437)             RTbuf->R_buf[RTbuf->R_rear]=data;
    00945 01CA      MOVW	R24,R20
    00946 9604      ADIW	R24,4
    00947 01FA      MOVW	R30,R20
    00948 81E1      LDD	R30,Z+1
    00949 27FF      CLR	R31
    0094A 0FE8      ADD	R30,R24
    0094B 1FF9      ADC	R31,R25
    0094C 82A0      ST	Z,R10
(0438)             RTbuf->R_rear=(RTbuf->R_rear+1) % RBUF_SIZE;
    0094D 01CA      MOVW	R24,R20
    0094E 9601      ADIW	R24,1
    0094F 011C      MOVW	R2,R24
    00950 E614      LDI	R17,0x64
    00951 01FC      MOVW	R30,R24
    00952 8100      LD	R16,Z
    00953 5F0F      SUBI	R16,0xFF
    00954 940E 0AA7 CALL	mod8u
    00956 01F1      MOVW	R30,R2
    00957 8300      ST	Z,R16
(0439)         } else {
    00958 C003      RJMP	0x095C
(0440)             RTbuf->R_overflow=1;
    00959 E081      LDI	R24,1
    0095A 01FA      MOVW	R30,R20
    0095B 8383      STD	Z+3,R24
(0441)         }
(0442)     }
    0095C 940E 0B29 CALL	pop_xgsetF00C
    0095E 9029      LD	R2,Y+
    0095F BE2F      OUT	0x3F,R2
    00960 91F9      LD	R31,Y+
    00961 91E9      LD	R30,Y+
    00962 9199      LD	R25,Y+
    00963 9189      LD	R24,Y+
    00964 9119      LD	R17,Y+
    00965 9109      LD	R16,Y+
    00966 9039      LD	R3,Y+
    00967 9029      LD	R2,Y+
    00968 9518      RETI
_getstr:
  data                 --> R10
  status               --> R22
  RTbuf                --> R20
    00969 940E 0B22 CALL	push_xgsetF00C
(0443) //SEI();
(0444) }
(0445) 
(0446) 
(0447) 
(0448) 
(0449) 
(0450) void getstr(void) {
(0451)     unsigned char status,data;
(0452)     siocirqueue *RTbuf;
(0453)     RTbuf=&RTbuf_UART0;
    0096B E042      LDI	R20,2
    0096C E053      LDI	R21,3
(0454) // CLI();
(0455)     status=UCSR0A;
    0096D B16B      IN	R22,0x0B
(0456)     data=UDR0;
    0096E B0AC      IN	R10,0x0C
(0457) //WDR(); //喂狗
(0458)     if((status & (FRAMING_ERROR | DATA_OVERRUN))==0) {
    0096F 2F86      MOV	R24,R22
    00970 7188      ANDI	R24,0x18
    00971 F009      BEQ	0x0973
    00972 C022      RJMP	0x0995
(0459)         if(RTbuf->R_count<RBUF_SIZE) {
    00973 01FA      MOVW	R30,R20
    00974 8182      LDD	R24,Z+2
    00975 3684      CPI	R24,0x64
    00976 F008      BCS	0x0978
    00977 C01A      RJMP	0x0992
(0460)             RTbuf->R_count++;
    00978 01CF      MOVW	R24,R30
    00979 9602      ADIW	R24,2
    0097A 01FC      MOVW	R30,R24
    0097B 8180      LD	R24,Z
    0097C 5F8F      SUBI	R24,0xFF
    0097D 8380      ST	Z,R24
(0461)             RTbuf->R_buf[RTbuf->R_rear]=data;
    0097E 01CA      MOVW	R24,R20
    0097F 9604      ADIW	R24,4
    00980 01FA      MOVW	R30,R20
    00981 81E1      LDD	R30,Z+1
    00982 27FF      CLR	R31
    00983 0FE8      ADD	R30,R24
    00984 1FF9      ADC	R31,R25
    00985 82A0      ST	Z,R10
(0462)             RTbuf->R_rear=(RTbuf->R_rear+1) % RBUF_SIZE;
    00986 01CA      MOVW	R24,R20
    00987 9601      ADIW	R24,1
    00988 011C      MOVW	R2,R24
    00989 E614      LDI	R17,0x64
    0098A 01FC      MOVW	R30,R24
    0098B 8100      LD	R16,Z
    0098C 5F0F      SUBI	R16,0xFF
    0098D 940E 0AA7 CALL	mod8u
    0098F 01F1      MOVW	R30,R2
    00990 8300      ST	Z,R16
(0463)         } else {
    00991 C003      RJMP	0x0995
(0464)             RTbuf->R_overflow=1;
    00992 E081      LDI	R24,1
    00993 01FA      MOVW	R30,R20
    00994 8383      STD	Z+3,R24
(0465)         }
(0466)     }
    00995 940C 0B29 JMP	pop_xgsetF00C
_uart0_tx_isr:
  RTbuf                --> R20
    00997 922A      ST	-Y,R2
    00998 923A      ST	-Y,R3
    00999 930A      ST	-Y,R16
    0099A 931A      ST	-Y,R17
    0099B 938A      ST	-Y,R24
    0099C 939A      ST	-Y,R25
    0099D 93EA      ST	-Y,R30
    0099E 93FA      ST	-Y,R31
    0099F B62F      IN	R2,0x3F
    009A0 922A      ST	-Y,R2
    009A1 934A      ST	-Y,R20
    009A2 935A      ST	-Y,R21
(0467) //SEI();
(0468) }
(0469) 
(0470) 
(0471) 
(0472) 
(0473) 
(0474) 
(0475) #pragma interrupt_handler uart0_tx_isr: iv_USART0_TXC
(0476) void uart0_tx_isr(void) {
(0477) //CLI();
(0478)     siocirqueue *RTbuf;
(0479) //WDR(); //喂狗
(0480)     RTbuf=&RTbuf_UART0;
    009A3 E042      LDI	R20,2
    009A4 E053      LDI	R21,3
(0481)     if (RTbuf->T_count>0) {
    009A5 E080      LDI	R24,0
    009A6 01FA      MOVW	R30,R20
    009A7 59E6      SUBI	R30,0x96
    009A8 4FFF      SBCI	R31,0xFF
    009A9 8020      LD	R2,Z
    009AA 56EA      SUBI	R30,0x6A
    009AB 40F0      SBCI	R31,0
    009AC 1582      CP	R24,R2
    009AD F008      BCS	0x09AF
    009AE C01F      RJMP	0x09CE
(0482)         UDR0=RTbuf->T_buf[RTbuf->T_front];
    009AF 01CF      MOVW	R24,R30
    009B0 5985      SUBI	R24,0x95
    009B1 4F9F      SBCI	R25,0xFF
    009B2 59E8      SUBI	R30,0x98
    009B3 4FFF      SBCI	R31,0xFF
    009B4 81E0      LD	R30,Z
    009B5 27FF      CLR	R31
    009B6 0FE8      ADD	R30,R24
    009B7 1FF9      ADC	R31,R25
    009B8 8020      LD	R2,Z
    009B9 B82C      OUT	0x0C,R2
(0483)         RTbuf->T_count--;
    009BA 01CA      MOVW	R24,R20
    009BB 5986      SUBI	R24,0x96
    009BC 4F9F      SBCI	R25,0xFF
    009BD 01FC      MOVW	R30,R24
    009BE 8180      LD	R24,Z
    009BF 5081      SUBI	R24,1
    009C0 8380      ST	Z,R24
(0484)         RTbuf->T_front=(RTbuf->T_front+1) % TBUF_SIZE;
    009C1 01CA      MOVW	R24,R20
    009C2 5988      SUBI	R24,0x98
    009C3 4F9F      SBCI	R25,0xFF
    009C4 011C      MOVW	R2,R24
    009C5 E614      LDI	R17,0x64
    009C6 01FC      MOVW	R30,R24
    009C7 8100      LD	R16,Z
    009C8 5F0F      SUBI	R16,0xFF
    009C9 940E 0AA7 CALL	mod8u
    009CB 01F1      MOVW	R30,R2
    009CC 8300      ST	Z,R16
(0485)     } else
    009CD C005      RJMP	0x09D3
(0486)         RTbuf->T_disabled=1;
    009CE E081      LDI	R24,1
    009CF 01FA      MOVW	R30,R20
    009D0 53E1      SUBI	R30,0x31
    009D1 4FFF      SBCI	R31,0xFF
    009D2 8380      ST	Z,R24
    009D3 9159      LD	R21,Y+
    009D4 9149      LD	R20,Y+
    009D5 9029      LD	R2,Y+
    009D6 BE2F      OUT	0x3F,R2
    009D7 91F9      LD	R31,Y+
    009D8 91E9      LD	R30,Y+
    009D9 9199      LD	R25,Y+
    009DA 9189      LD	R24,Y+
    009DB 9119      LD	R17,Y+
    009DC 9109      LD	R16,Y+
    009DD 9039      LD	R3,Y+
    009DE 9029      LD	R2,Y+
    009DF 9518      RETI
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\TWI.c
(0001) /************************************************
(0002) 文件：TWI.c
(0003) 用途：TWI操作函数
(0004) 注意：
(0005) 创建：2008.1.26
(0006) 修改：2008.1.26
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) /*************************************************************************
(0011) ** 函数名称: twi_init(void)
(0012) ** 功能描述: i2c通信初始化
(0013) ** 输　入: 
(0014) ** 输出	 : 
(0015) ** 全局变量: 无
(0016) ** 调用模块: 
(0017) ** 说明：
(0018) ** 注意：
(0019) **************************************************************************/
(0020) void twi_init(void)
(0021) {
(0022)  TWCR= 0x00; //disable twi
_twi_init:
    009E0 2422      CLR	R2
    009E1 9220 0074 STS	0x74,R2
(0023)  TWBR= (1<<6) | (1<<5) | (1<<2); //set bit rate
    009E3 E684      LDI	R24,0x64
    009E4 9380 0070 STS	0x70,R24
(0024)  TWSR= 0x00; //set prescale
    009E6 9220 0071 STS	0x71,R2
(0025)  TWAR= 0x00; //set slave address
    009E8 9220 0072 STS	0x72,R2
(0026)  TWCR= (1<<TWEN); //enable twi
    009EA E084      LDI	R24,4
    009EB 9380 0074 STS	0x74,R24
    009ED 9508      RET
(0027) }
(0028) /*************************************************************************
(0029) ** 函数名称: i2cstart(void)
(0030) ** 功能描述: i2c通信开始
(0031) ** 输　入: 
(0032) ** 输出	 : 
(0033) ** 全局变量: 无
(0034) ** 调用模块: 
(0035) ** 说明：
(0036) ** 注意：
(0037) **************************************************************************/
(0038) void i2cstart(void)
(0039) { 
(0040) 	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN); 
_i2cstart:
    009EE EA84      LDI	R24,0xA4
    009EF 9380 0074 STS	0x74,R24
(0041)    	while (!(TWCR & (1<<TWINT)));
    009F1 9020 0074 LDS	R2,0x74
    009F3 FE27      SBRS	R2,7
    009F4 CFFC      RJMP	0x09F1
    009F5 9508      RET
(0042) }
(0043) /*************************************************************************
(0044) ** 函数名称: unsigned char i2cwt(unsigned char data)
(0045) ** 功能描述: i2c写数据,返回TWI状态
(0046) ** 输　入: 
(0047) ** 输  出: TWI状态
(0048) ** 全局变量: 无
(0049) ** 调用模块: 
(0050) ** 说明：
(0051) ** 注意：
(0052) **************************************************************************/
(0053) unsigned char i2cwt(unsigned char data)
(0054) { 
(0055) 	TWDR = data;
_i2cwt:
  data                 --> R16
    009F6 9300 0073 STS	0x73,R16
(0056)    	TWCR = (1<<TWINT) | (1<<TWEN);
    009F8 E884      LDI	R24,0x84
    009F9 9380 0074 STS	0x74,R24
(0057)    	while (!(TWCR & (1<<TWINT)));
    009FB 9020 0074 LDS	R2,0x74
    009FD FE27      SBRS	R2,7
    009FE CFFC      RJMP	0x09FB
(0058)    	_NOP();
    009FF 0000      NOP
(0059)    	return(TWSR&0b11111000);
    00A00 9100 0071 LDS	R16,0x71
    00A02 7F08      ANDI	R16,0xF8
    00A03 9508      RET
(0060) }
(0061) /*************************************************************************
(0062) ** 函数名称: unsigned char i2crd(void)
(0063) ** 功能描述: i2c读数据
(0064) ** 输　入: 
(0065) ** 输出	 : 读取的数据
(0066) ** 全局变量: 无
(0067) ** 调用模块: 
(0068) ** 说明：
(0069) ** 注意：
(0070) **************************************************************************/
(0071) unsigned char i2crd(void)
(0072) {
(0073)    	TWCR= (1<<TWINT) | (1<<TWEA) | (1<<TWEN);
_i2crd:
    00A04 EC84      LDI	R24,0xC4
    00A05 9380 0074 STS	0x74,R24
(0074)    	while (!(TWCR & (1<<TWINT)));
    00A07 9020 0074 LDS	R2,0x74
    00A09 FE27      SBRS	R2,7
    00A0A CFFC      RJMP	0x0A07
(0075)    	return(TWDR);
    00A0B 9100 0073 LDS	R16,0x73
    00A0D 9508      RET
(0076) }
(0077) /*************************************************************************
(0078) ** 函数名称: i2cstop(void)
(0079) ** 功能描述: i2c停止
(0080) ** 输　入: 
(0081) ** 输出	 : 
(0082) ** 全局变量: 无
(0083) ** 调用模块: 
(0084) ** 说明：
(0085) ** 注意：
(0086) **************************************************************************/
(0087) void i2cstop(void)
(0088) { 
(0089)    TWCR = (1<<TWINT) | (1<<TWSTO) | (1<<TWEN);
_i2cstop:
    00A0E E984      LDI	R24,0x94
    00A0F 9380 0074 STS	0x74,R24
    00A11 9508      RET
FILE: D:\desk_station\LM041L\AVR_licheng\USART_24C01_ok\source\lib\spi.c
(0001) /************************************************
(0002) 文件：spi.c
(0003) 用途：SPI驱动
(0004) 注意：
(0005) 创建：2008.1.25
(0006) 修改：2008.1.25
(0007) Copy Right  (c)  www.avrvi.com  AVR与虚拟仪器
(0008) ************************************************/
(0009) #include "..\config.h"
(0010) /*************************************************************************
(0011) ** 函数名称: spi_init(void)
(0012) ** 功能描述: SPI初始化
(0013) ** 输　入: 
(0014) ** 输出	 : 
(0015) ** 全局变量: 无
(0016) ** 调用模块: 
(0017) ** 说明：
(0018) ** 注意：
(0019) **************************************************************************/
(0020) void spi_init(void)
(0021) {
(0022)  	 DDRB |= (1<<MOSI)|(1<<SCK)|(1<<SS);//设置MOSI，SCK输出
_spi_init:
    00A12 B387      IN	R24,0x17
    00A13 6087      ORI	R24,7
    00A14 BB87      OUT	0x17,R24
(0023)  	 SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<SPR1);//使能SPI，主机模式
    00A15 E583      LDI	R24,0x53
    00A16 B98D      OUT	0x0D,R24
    00A17 9508      RET
(0024) }
(0025) /*************************************************************************
(0026) ** 函数名称: SPI_MasterTransmit(char Data)
(0027) ** 功能描述: SPI主机发送数据
(0028) ** 输　入: Data 需要通过SPI传输的数据
(0029) ** 输出	 : 
(0030) ** 全局变量: 无
(0031) ** 调用模块: 
(0032) ** 说明：
(0033) ** 注意：
(0034) **************************************************************************/
(0035) void SPI_MasterTransmit(char Data)
(0036) {
(0037)  	 /* 启动数据传输 */
(0038)  	 SPDR = Data;
_SPI_MasterTransmit:
  Data                 --> R16
    00A18 B90F      OUT	0x0F,R16
(0039)  	 /* 等待传输结束 */
(0040)  	 while(!(SPSR & (1<<SPIF)))
FILE: <library>
    00A19 9B77      SBIS	0x0E,7
    00A1A CFFE      RJMP	0x0A19
    00A1B 9508      RET
push_arg4:
    00A1C 933A      ST	-Y,R19
    00A1D 932A      ST	-Y,R18
push_arg2:
    00A1E 931A      ST	-Y,R17
    00A1F 930A      ST	-Y,R16
    00A20 9508      RET
mod16u:
    00A21 9468      BSET	6
    00A22 C001      RJMP	xdiv16u
div16u:
    00A23 94E8      BCLR	6
xdiv16u:
    00A24 92EA      ST	-Y,R14
    00A25 92FA      ST	-Y,R15
    00A26 938A      ST	-Y,R24
    00A27 24EE      CLR	R14
    00A28 24FF      CLR	R15
    00A29 E180      LDI	R24,0x10
    00A2A 0F00      LSL	R16
    00A2B 1F11      ROL	R17
    00A2C 1CEE      ROL	R14
    00A2D 1CFF      ROL	R15
    00A2E 16E2      CP	R14,R18
    00A2F 06F3      CPC	R15,R19
    00A30 F018      BCS	0x0A34
    00A31 1AE2      SUB	R14,R18
    00A32 0AF3      SBC	R15,R19
    00A33 9503      INC	R16
    00A34 958A      DEC	R24
    00A35 F7A1      BNE	0x0A2A
    00A36 F416      BRTC	0x0A39
    00A37 2D0E      MOV	R16,R14
    00A38 2D1F      MOV	R17,R15
    00A39 9189      LD	R24,Y+
    00A3A 90F9      LD	R15,Y+
    00A3B 90E9      LD	R14,Y+
    00A3C 9508      RET
div32u:
    00A3D 94E8      BCLR	6
    00A3E C001      RJMP	0x0A40
mod32u:
    00A3F 9468      BSET	6
    00A40 D030      RCALL	long_div_prolog
    00A41 24CC      CLR	R12
    00A42 C009      RJMP	0x0A4C
div32s:
    00A43 94E8      BCLR	6
    00A44 C001      RJMP	0x0A46
mod32s:
    00A45 9468      BSET	6
    00A46 D02A      RCALL	long_div_prolog
    00A47 FD37      SBRC	R19,7
    00A48 940E 0B42 CALL	neg32
    00A4A FDB7      SBRC	R27,7
    00A4B D052      RCALL	neg_R24_R27
    00A4C 2477      CLR	R7
    00A4D 2488      CLR	R8
    00A4E 2499      CLR	R9
    00A4F 24AA      CLR	R10
    00A50 24BB      CLR	R11
    00A51 D042      RCALL	tst_R16_R19
    00A52 F0C1      BEQ	0x0A6B
    00A53 D045      RCALL	tst_R24_R27
    00A54 F0B1      BEQ	0x0A6B
    00A55 E2E8      LDI	R30,0x28
    00A56 0F00      LSL	R16
    00A57 1F11      ROL	R17
    00A58 1F22      ROL	R18
    00A59 1F33      ROL	R19
    00A5A 1C77      ROL	R7
    00A5B 1C88      ROL	R8
    00A5C 1C99      ROL	R9
    00A5D 1CAA      ROL	R10
    00A5E 1CBB      ROL	R11
    00A5F 1688      CP	R8,R24
    00A60 0699      CPC	R9,R25
    00A61 06AA      CPC	R10,R26
    00A62 06BB      CPC	R11,R27
    00A63 F028      BCS	0x0A69
    00A64 1A88      SUB	R8,R24
    00A65 0A99      SBC	R9,R25
    00A66 0AAA      SBC	R10,R26
    00A67 0ABB      SBC	R11,R27
    00A68 9503      INC	R16
    00A69 95EA      DEC	R30
    00A6A F759      BNE	0x0A56
    00A6B F426      BRTC	0x0A70
    00A6C 2D08      MOV	R16,R8
    00A6D 2D19      MOV	R17,R9
    00A6E 2D2A      MOV	R18,R10
    00A6F 2D3B      MOV	R19,R11
    00A70 C013      RJMP	long_div_epilog
long_div_prolog:
    00A71 927A      ST	-Y,R7
    00A72 928A      ST	-Y,R8
    00A73 929A      ST	-Y,R9
    00A74 92AA      ST	-Y,R10
    00A75 92BA      ST	-Y,R11
    00A76 92CA      ST	-Y,R12
    00A77 93EA      ST	-Y,R30
    00A78 938A      ST	-Y,R24
    00A79 939A      ST	-Y,R25
    00A7A 93AA      ST	-Y,R26
    00A7B 93BA      ST	-Y,R27
    00A7C 858B      LDD	R24,Y+11
    00A7D 859C      LDD	R25,Y+12
    00A7E 85AD      LDD	R26,Y+13
    00A7F 85BE      LDD	R27,Y+14
    00A80 2EC3      MOV	R12,R19
    00A81 F00E      BRTS	0x0A83
    00A82 26CB      EOR	R12,R27
    00A83 9508      RET
long_div_epilog:
    00A84 FCC7      SBRC	R12,7
    00A85 940E 0B42 CALL	neg32
    00A87 91B9      LD	R27,Y+
    00A88 91A9      LD	R26,Y+
    00A89 9199      LD	R25,Y+
    00A8A 9189      LD	R24,Y+
    00A8B 91E9      LD	R30,Y+
    00A8C 90C9      LD	R12,Y+
    00A8D 90B9      LD	R11,Y+
    00A8E 90A9      LD	R10,Y+
    00A8F 9099      LD	R9,Y+
    00A90 9089      LD	R8,Y+
    00A91 9079      LD	R7,Y+
    00A92 9624      ADIW	R28,4
    00A93 9508      RET
tst_R16_R19:
    00A94 2FE0      MOV	R30,R16
    00A95 2BE1      OR	R30,R17
    00A96 2BE2      OR	R30,R18
    00A97 2BE3      OR	R30,R19
    00A98 9508      RET
tst_R24_R27:
    00A99 2FE8      MOV	R30,R24
    00A9A 2BE9      OR	R30,R25
    00A9B 2BEA      OR	R30,R26
    00A9C 2BEB      OR	R30,R27
    00A9D 9508      RET
neg_R24_R27:
    00A9E 9580      COM	R24
    00A9F 9590      COM	R25
    00AA0 95A0      COM	R26
    00AA1 95B0      COM	R27
    00AA2 5F8F      SUBI	R24,0xFF
    00AA3 4F9F      SBCI	R25,0xFF
    00AA4 4FAF      SBCI	R26,0xFF
    00AA5 4FBF      SBCI	R27,0xFF
    00AA6 9508      RET
mod8u:
    00AA7 9468      BSET	6
    00AA8 C001      RJMP	xdiv8u
div8u:
    00AA9 94E8      BCLR	6
xdiv8u:
    00AAA 932A      ST	-Y,R18
    00AAB 92FA      ST	-Y,R15
    00AAC 92EA      ST	-Y,R14
    00AAD 24FF      CLR	R15
    00AAE 24EE      CLR	R14
    00AAF E120      LDI	R18,0x10
    00AB0 0F00      LSL	R16
    00AB1 1CFF      ROL	R15
    00AB2 1CEE      ROL	R14
    00AB3 16E1      CP	R14,R17
    00AB4 F010      BCS	0x0AB7
    00AB5 1AE1      SUB	R14,R17
    00AB6 9503      INC	R16
    00AB7 952A      DEC	R18
    00AB8 F7B9      BNE	0x0AB0
    00AB9 F40E      BRTC	0x0ABB
    00ABA 2D0E      MOV	R16,R14
    00ABB 90E9      LD	R14,Y+
    00ABC 90F9      LD	R15,Y+
    00ABD 9129      LD	R18,Y+
    00ABE 9508      RET
elpm32:
    00ABF 93EA      ST	-Y,R30
    00AC0 93FA      ST	-Y,R31
    00AC1 920A      ST	-Y,R0
    00AC2 2FE0      MOV	R30,R16
    00AC3 2FF1      MOV	R31,R17
    00AC4 95D8      ELPM
    00AC5 2D00      MOV	R16,R0
    00AC6 9631      ADIW	R30,1
    00AC7 95D8      ELPM
    00AC8 2D10      MOV	R17,R0
    00AC9 9631      ADIW	R30,1
    00ACA 95D8      ELPM
    00ACB 2D20      MOV	R18,R0
    00ACC 9631      ADIW	R30,1
    00ACD 95D8      ELPM
    00ACE 2D30      MOV	R19,R0
    00ACF 9009      LD	R0,Y+
    00AD0 91F9      LD	R31,Y+
    00AD1 91E9      LD	R30,Y+
    00AD2 9508      RET
empy16s:
    00AD3 920A      ST	-Y,R0
    00AD4 921A      ST	-Y,R1
    00AD5 938A      ST	-Y,R24
    00AD6 939A      ST	-Y,R25
    00AD7 9F02      MUL	R16,R18
    00AD8 01C0      MOVW	R24,R0
    00AD9 9F12      MUL	R17,R18
    00ADA 0D90      ADD	R25,R0
    00ADB 9F03      MUL	R16,R19
    00ADC 0D90      ADD	R25,R0
    00ADD 018C      MOVW	R16,R24
    00ADE 9199      LD	R25,Y+
    00ADF 9189      LD	R24,Y+
    00AE0 9019      LD	R1,Y+
    00AE1 9009      LD	R0,Y+
    00AE2 9508      RET
pop_xgset003C:
    00AE3 90A9      LD	R10,Y+
    00AE4 90B9      LD	R11,Y+
    00AE5 90C9      LD	R12,Y+
    00AE6 90D9      LD	R13,Y+
    00AE7 9508      RET
pop_xgset00FC:
    00AE8 90A9      LD	R10,Y+
    00AE9 90B9      LD	R11,Y+
    00AEA 90C9      LD	R12,Y+
    00AEB 90D9      LD	R13,Y+
    00AEC 90E9      LD	R14,Y+
    00AED 90F9      LD	R15,Y+
    00AEE 9508      RET
pop_xgset30FC:
    00AEF 90A9      LD	R10,Y+
    00AF0 90B9      LD	R11,Y+
    00AF1 90C9      LD	R12,Y+
    00AF2 90D9      LD	R13,Y+
    00AF3 90E9      LD	R14,Y+
    00AF4 90F9      LD	R15,Y+
    00AF5 9149      LD	R20,Y+
    00AF6 9159      LD	R21,Y+
    00AF7 9508      RET
pop_xgsetF0FC:
    00AF8 90A9      LD	R10,Y+
    00AF9 90B9      LD	R11,Y+
    00AFA 90C9      LD	R12,Y+
    00AFB 90D9      LD	R13,Y+
    00AFC 90E9      LD	R14,Y+
    00AFD 90F9      LD	R15,Y+
    00AFE 9149      LD	R20,Y+
    00AFF 9159      LD	R21,Y+
    00B00 9169      LD	R22,Y+
    00B01 9179      LD	R23,Y+
    00B02 9508      RET
push_xgsetF0FC:
    00B03 937A      ST	-Y,R23
    00B04 936A      ST	-Y,R22
push_xgset30FC:
    00B05 935A      ST	-Y,R21
    00B06 934A      ST	-Y,R20
push_xgset00FC:
    00B07 92FA      ST	-Y,R15
    00B08 92EA      ST	-Y,R14
push_xgset003C:
    00B09 92DA      ST	-Y,R13
    00B0A 92CA      ST	-Y,R12
    00B0B 92BA      ST	-Y,R11
    00B0C 92AA      ST	-Y,R10
    00B0D 9508      RET
push_xgset300C:
    00B0E 935A      ST	-Y,R21
    00B0F 934A      ST	-Y,R20
    00B10 92BA      ST	-Y,R11
    00B11 92AA      ST	-Y,R10
    00B12 9508      RET
pop_xgset300C:
    00B13 90A9      LD	R10,Y+
    00B14 90B9      LD	R11,Y+
    00B15 9149      LD	R20,Y+
    00B16 9159      LD	R21,Y+
    00B17 9508      RET
push_xgsetF000:
    00B18 937A      ST	-Y,R23
    00B19 936A      ST	-Y,R22
    00B1A 935A      ST	-Y,R21
    00B1B 934A      ST	-Y,R20
    00B1C 9508      RET
pop_xgsetF000:
    00B1D 9149      LD	R20,Y+
    00B1E 9159      LD	R21,Y+
    00B1F 9169      LD	R22,Y+
    00B20 9179      LD	R23,Y+
    00B21 9508      RET
push_xgsetF00C:
    00B22 937A      ST	-Y,R23
    00B23 936A      ST	-Y,R22
    00B24 935A      ST	-Y,R21
    00B25 934A      ST	-Y,R20
    00B26 92BA      ST	-Y,R11
    00B27 92AA      ST	-Y,R10
    00B28 9508      RET
pop_xgsetF00C:
    00B29 90A9      LD	R10,Y+
    00B2A 90B9      LD	R11,Y+
    00B2B 9149      LD	R20,Y+
    00B2C 9159      LD	R21,Y+
    00B2D 9169      LD	R22,Y+
    00B2E 9179      LD	R23,Y+
    00B2F 9508      RET
push_xgsetF03C:
    00B30 937A      ST	-Y,R23
    00B31 936A      ST	-Y,R22
    00B32 935A      ST	-Y,R21
    00B33 934A      ST	-Y,R20
    00B34 92DA      ST	-Y,R13
    00B35 92CA      ST	-Y,R12
    00B36 92BA      ST	-Y,R11
    00B37 92AA      ST	-Y,R10
    00B38 9508      RET
pop_xgsetF03C:
    00B39 90A9      LD	R10,Y+
    00B3A 90B9      LD	R11,Y+
    00B3B 90C9      LD	R12,Y+
    00B3C 90D9      LD	R13,Y+
    00B3D 9149      LD	R20,Y+
    00B3E 9159      LD	R21,Y+
    00B3F 9169      LD	R22,Y+
    00B40 9179      LD	R23,Y+
    00B41 9508      RET
neg32:
    00B42 9500      COM	R16
    00B43 9510      COM	R17
    00B44 9520      COM	R18
    00B45 9530      COM	R19
    00B46 5F0F      SUBI	R16,0xFF
    00B47 4F1F      SBCI	R17,0xFF
    00B48 4F2F      SBCI	R18,0xFF
    00B49 4F3F      SBCI	R19,0xFF
    00B4A 9508      RET
lsl32:
    00B4B 920F      PUSH	R0
    00B4C 9009      LD	R0,Y+
    00B4D 2000      TST	R0
    00B4E F031      BEQ	0x0B55
    00B4F 0F00      LSL	R16
    00B50 1F11      ROL	R17
    00B51 1F22      ROL	R18
    00B52 1F33      ROL	R19
    00B53 940A      DEC	R0
    00B54 CFF8      RJMP	0x0B4D
    00B55 900F      POP	R0
    00B56 9508      RET
fpsub:
    00B57 9468      BSET	6
    00B58 C001      RJMP	fpadd_alt
fpadd:
    00B59 94E8      BCLR	6
fpadd_alt:
    00B5A 940E 0C6C CALL	saveFPRegs
    00B5C 940E 0BFE CALL	unpacks
    00B5E F409      BNE	0x0B60
    00B5F C048      RJMP	0x0BA8
    00B60 2CE6      MOV	R14,R6
    00B61 2CD5      MOV	R13,R5
    00B62 2CC4      MOV	R12,R4
    00B63 2EB3      MOV	R11,R19
    00B64 2EA2      MOV	R10,R18
    00B65 2E91      MOV	R9,R17
    00B66 2E80      MOV	R8,R16
    00B67 8100      LD	R16,Z
    00B68 8111      LDD	R17,Z+1
    00B69 8122      LDD	R18,Z+2
    00B6A 8133      LDD	R19,Z+3
    00B6B 940E 0BFE CALL	unpacks
    00B6D F409      BNE	0x0B6F
    00B6E C044      RJMP	0x0BB3
    00B6F 2D84      MOV	R24,R4
    00B70 2D95      MOV	R25,R5
    00B71 198C      SUB	R24,R12
    00B72 099D      SBC	R25,R13
    00B73 F0B9      BEQ	0x0B8B
    00B74 F472      BPL	0x0B83
    00B75 9590      COM	R25
    00B76 9580      COM	R24
    00B77 9601      ADIW	R24,1
    00B78 2C4C      MOV	R4,R12
    00B79 2C5D      MOV	R5,R13
    00B7A 3188      CPI	R24,0x18
    00B7B F5B8      BCC	0x0BB3
    00B7C 9535      ASR	R19
    00B7D 9527      ROR	R18
    00B7E 9517      ROR	R17
    00B7F 9507      ROR	R16
    00B80 9701      SBIW	R24,1
    00B81 F7D1      BNE	0x0B7C
    00B82 C008      RJMP	0x0B8B
    00B83 3188      CPI	R24,0x18
    00B84 F518      BCC	0x0BA8
    00B85 94B5      ASR	R11
    00B86 94A7      ROR	R10
    00B87 9497      ROR	R9
    00B88 9487      ROR	R8
    00B89 9701      SBIW	R24,1
    00B8A F7D1      BNE	0x0B85
    00B8B 2466      CLR	R6
    00B8C F02E      BRTS	0x0B92
    00B8D 0D08      ADD	R16,R8
    00B8E 1D19      ADC	R17,R9
    00B8F 1D2A      ADC	R18,R10
    00B90 1D3B      ADC	R19,R11
    00B91 C009      RJMP	0x0B9B
    00B92 1A80      SUB	R8,R16
    00B93 0A91      SBC	R9,R17
    00B94 0AA2      SBC	R10,R18
    00B95 0AB3      SBC	R11,R19
    00B96 2D08      MOV	R16,R8
    00B97 2D19      MOV	R17,R9
    00B98 2D2A      MOV	R18,R10
    00B99 2D3B      MOV	R19,R11
    00B9A 2333      TST	R19
    00B9B F422      BPL	0x0BA0
    00B9C 940E 0B42 CALL	neg32
    00B9E E880      LDI	R24,0x80
    00B9F 2E68      MOV	R6,R24
    00BA0 940E 0C27 CALL	normalize_and_pack
    00BA2 C002      RJMP	0x0BA5
    00BA3 940E 0C5C CALL	pack
    00BA5 940E 0C7B CALL	restoreFPRegs
    00BA7 9508      RET
    00BA8 8100      LD	R16,Z
    00BA9 8111      LDD	R17,Z+1
    00BAA 8122      LDD	R18,Z+2
    00BAB 8133      LDD	R19,Z+3
    00BAC F7C6      BRTC	0x0BA5
    00BAD 940E 0C06 CALL	tstR16_R19
    00BAF F3A9      BEQ	0x0BA5
    00BB0 E880      LDI	R24,0x80
    00BB1 2738      EOR	R19,R24
    00BB2 CFF2      RJMP	0x0BA5
    00BB3 2D08      MOV	R16,R8
    00BB4 2D19      MOV	R17,R9
    00BB5 2D2A      MOV	R18,R10
    00BB6 2D3B      MOV	R19,R11
    00BB7 2C4C      MOV	R4,R12
    00BB8 2C5D      MOV	R5,R13
    00BB9 2C6E      MOV	R6,R14
    00BBA 2333      TST	R19
    00BBB F73A      BPL	0x0BA3
    00BBC 940E 0B42 CALL	neg32
    00BBE E880      LDI	R24,0x80
    00BBF 2E68      MOV	R6,R24
    00BC0 CFE2      RJMP	0x0BA3
fpadd2:
    00BC1 93FA      ST	-Y,R31
    00BC2 93EA      ST	-Y,R30
    00BC3 2FEC      MOV	R30,R28
    00BC4 2FFD      MOV	R31,R29
    00BC5 9632      ADIW	R30,2
    00BC6 940E 0B59 CALL	fpadd
    00BC8 91E9      LD	R30,Y+
    00BC9 91F9      LD	R31,Y+
    00BCA 9624      ADIW	R28,4
    00BCB 9508      RET
fpint:
    00BCC 924A      ST	-Y,R4
    00BCD 925A      ST	-Y,R5
    00BCE 926A      ST	-Y,R6
    00BCF 938A      ST	-Y,R24
    00BD0 940E 0C0E CALL	unpacku
    00BD2 F111      BEQ	0x0BF5
    00BD3 2055      TST	R5
    00BD4 F0E2      BMI	0x0BF1
    00BD5 E18F      LDI	R24,0x1F
    00BD6 1648      CP	R4,R24
    00BD7 F4C0      BCC	0x0BF0
    00BD8 E187      LDI	R24,0x17
    00BD9 1648      CP	R4,R24
    00BDA F0D1      BEQ	0x0BF5
    00BDB F458      BCC	0x0BE7
    00BDC 9441      NEG	R4
    00BDD EE89      LDI	R24,0xE9
    00BDE 1A48      SUB	R4,R24
    00BDF C005      RJMP	0x0BE5
    00BE0 9535      ASR	R19
    00BE1 9527      ROR	R18
    00BE2 9517      ROR	R17
    00BE3 9507      ROR	R16
    00BE4 944A      DEC	R4
    00BE5 F7D1      BNE	0x0BE0
    00BE6 C00E      RJMP	0x0BF5
    00BE7 E187      LDI	R24,0x17
    00BE8 1A48      SUB	R4,R24
    00BE9 0F00      LSL	R16
    00BEA 1F11      ROL	R17
    00BEB 1F22      ROL	R18
    00BEC 1F33      ROL	R19
    00BED 944A      DEC	R4
    00BEE F7D1      BNE	0x0BE9
    00BEF C005      RJMP	0x0BF5
    00BF0 E73F      LDI	R19,0x7F
    00BF1 2F23      MOV	R18,R19
    00BF2 2F13      MOV	R17,R19
    00BF3 2F03      MOV	R16,R19
    00BF4 C004      RJMP	0x0BF9
    00BF5 2066      TST	R6
    00BF6 F011      BEQ	0x0BF9
    00BF7 940E 0B42 CALL	neg32
    00BF9 9189      LD	R24,Y+
    00BFA 9069      LD	R6,Y+
    00BFB 9059      LD	R5,Y+
    00BFC 9049      LD	R4,Y+
    00BFD 9508      RET
unpacks:
    00BFE D00F      RCALL	unpacku
    00BFF F029      BEQ	0x0C05
    00C00 2066      TST	R6
    00C01 F011      BEQ	0x0C04
    00C02 940E 0B42 CALL	neg32
    00C04 9498      BCLR	1
    00C05 9508      RET
tstR16_R19:
    00C06 2300      TST	R16
    00C07 F429      BNE	0x0C0D
    00C08 2311      TST	R17
    00C09 F419      BNE	0x0C0D
    00C0A 2322      TST	R18
    00C0B F409      BNE	0x0C0D
    00C0C 2333      TST	R19
    00C0D 9508      RET
unpacku:
    00C0E DFF7      RCALL	tstR16_R19
    00C0F F099      BEQ	0x0C23
    00C10 938A      ST	-Y,R24
    00C11 2E63      MOV	R6,R19
    00C12 E880      LDI	R24,0x80
    00C13 2268      AND	R6,R24
    00C14 0F22      LSL	R18
    00C15 1F33      ROL	R19
    00C16 2E43      MOV	R4,R19
    00C17 E78F      LDI	R24,0x7F
    00C18 1A48      SUB	R4,R24
    00C19 2455      CLR	R5
    00C1A 2788      CLR	R24
    00C1B 0A58      SBC	R5,R24
    00C1C 9526      LSR	R18
    00C1D E830      LDI	R19,0x80
    00C1E 2B23      OR	R18,R19
    00C1F 2733      CLR	R19
    00C20 9189      LD	R24,Y+
    00C21 9498      BCLR	1
    00C22 9508      RET
    00C23 2444      CLR	R4
    00C24 2455      CLR	R5
    00C25 2466      CLR	R6
    00C26 9508      RET
normalize_and_pack:
    00C27 DFDE      RCALL	tstR16_R19
    00C28 F409      BNE	0x0C2A
    00C29 9508      RET
    00C2A 93AA      ST	-Y,R26
    00C2B 93BA      ST	-Y,R27
    00C2C 01D2      MOVW	R26,R4
    00C2D 939A      ST	-Y,R25
    00C2E 938A      ST	-Y,R24
    00C2F E78E      LDI	R24,0x7E
    00C30 E090      LDI	R25,0
    00C31 2333      TST	R19
    00C32 F049      BEQ	0x0C3C
    00C33 9536      LSR	R19
    00C34 9527      ROR	R18
    00C35 9517      ROR	R17
    00C36 9507      ROR	R16
    00C37 17A8      CP	R26,R24
    00C38 07B9      CPC	R27,R25
    00C39 F4CC      BGE	0x0C53
    00C3A 9611      ADIW	R26,1
    00C3B CFF5      RJMP	0x0C31
    00C3C 9580      COM	R24
    00C3D 9590      COM	R25
    00C3E 9601      ADIW	R24,1
    00C3F 2322      TST	R18
    00C40 F0BA      BMI	0x0C58
    00C41 0F00      LSL	R16
    00C42 1F11      ROL	R17
    00C43 1F22      ROL	R18
    00C44 17A8      CP	R26,R24
    00C45 07B9      CPC	R27,R25
    00C46 F014      BLT	0x0C49
    00C47 9711      SBIW	R26,1
    00C48 CFF6      RJMP	0x0C3F
    00C49 2700      CLR	R16
    00C4A 2711      CLR	R17
    00C4B 2722      CLR	R18
    00C4C 2733      CLR	R19
    00C4D 9189      LD	R24,Y+
    00C4E 9199      LD	R25,Y+
    00C4F 012D      MOVW	R4,R26
    00C50 91B9      LD	R27,Y+
    00C51 91A9      LD	R26,Y+
    00C52 9508      RET
    00C53 2733      CLR	R19
    00C54 EF0F      LDI	R16,0xFF
    00C55 2F10      MOV	R17,R16
    00C56 E72F      LDI	R18,0x7F
    00C57 2F32      MOV	R19,R18
    00C58 9189      LD	R24,Y+
    00C59 9199      LD	R25,Y+
    00C5A 012D      MOVW	R4,R26
    00C5B C002      RJMP	0x0C5E
pack:
    00C5C 93AA      ST	-Y,R26
    00C5D 93BA      ST	-Y,R27
    00C5E DFA7      RCALL	tstR16_R19
    00C5F F049      BEQ	0x0C69
    00C60 01D2      MOVW	R26,R4
    00C61 58A1      SUBI	R26,0x81
    00C62 4FBF      SBCI	R27,0xFF
    00C63 012D      MOVW	R4,R26
    00C64 2D34      MOV	R19,R4
    00C65 0F22      LSL	R18
    00C66 9536      LSR	R19
    00C67 9527      ROR	R18
    00C68 2936      OR	R19,R6
    00C69 91B9      LD	R27,Y+
    00C6A 91A9      LD	R26,Y+
    00C6B 9508      RET
saveFPRegs:
    00C6C 924A      ST	-Y,R4
    00C6D 925A      ST	-Y,R5
    00C6E 926A      ST	-Y,R6
    00C6F 927A      ST	-Y,R7
    00C70 928A      ST	-Y,R8
    00C71 929A      ST	-Y,R9
    00C72 92AA      ST	-Y,R10
    00C73 92BA      ST	-Y,R11
    00C74 92CA      ST	-Y,R12
    00C75 92DA      ST	-Y,R13
    00C76 92EA      ST	-Y,R14
    00C77 92FA      ST	-Y,R15
    00C78 938A      ST	-Y,R24
    00C79 939A      ST	-Y,R25
    00C7A 9508      RET
restoreFPRegs:
    00C7B 9199      LD	R25,Y+
    00C7C 9189      LD	R24,Y+
    00C7D 90F9      LD	R15,Y+
    00C7E 90E9      LD	R14,Y+
    00C7F 90D9      LD	R13,Y+
    00C80 90C9      LD	R12,Y+
    00C81 90B9      LD	R11,Y+
    00C82 90A9      LD	R10,Y+
    00C83 9099      LD	R9,Y+
    00C84 9089      LD	R8,Y+
    00C85 9079      LD	R7,Y+
    00C86 9069      LD	R6,Y+
    00C87 9059      LD	R5,Y+
    00C88 9049      LD	R4,Y+
    00C89 9508      RET
fpmule:
    00C8A 940E 0C6C CALL	saveFPRegs
    00C8C 93AA      ST	-Y,R26
    00C8D 93BA      ST	-Y,R27
    00C8E 940E 0C0E CALL	unpacku
    00C90 F1E1      BEQ	0x0CCD
    00C91 2CE6      MOV	R14,R6
    00C92 2CD5      MOV	R13,R5
    00C93 2CC4      MOV	R12,R4
    00C94 2EB3      MOV	R11,R19
    00C95 2EA2      MOV	R10,R18
    00C96 2E91      MOV	R9,R17
    00C97 2E80      MOV	R8,R16
    00C98 8100      LD	R16,Z
    00C99 8111      LDD	R17,Z+1
    00C9A 8122      LDD	R18,Z+2
    00C9B 8133      LDD	R19,Z+3
    00C9C 940E 0C0E CALL	unpacku
    00C9E F171      BEQ	0x0CCD
    00C9F 246E      EOR	R6,R14
    00CA0 0C4C      ADD	R4,R12
    00CA1 1C5D      ADC	R5,R13
    00CA2 E880      LDI	R24,0x80
    00CA3 1648      CP	R4,R24
    00CA4 0653      CPC	R5,R19
    00CA5 F564      BGE	0x0CD2
    00CA6 E881      LDI	R24,0x81
    00CA7 1648      CP	R4,R24
    00CA8 EF8F      LDI	R24,0xFF
    00CA9 0658      CPC	R5,R24
    00CAA F16C      BLT	0x0CD8
    00CAB 9EA2      MUL	R10,R18
    00CAC 2DB1      MOV	R27,R1
    00CAD 2DA0      MOV	R26,R0
    00CAE 9E91      MUL	R9,R17
    00CAF 2D91      MOV	R25,R1
    00CB0 2D80      MOV	R24,R0
    00CB1 9EA0      MUL	R10,R16
    00CB2 0D80      ADD	R24,R0
    00CB3 1D91      ADC	R25,R1
    00CB4 1FA3      ADC	R26,R19
    00CB5 1FB3      ADC	R27,R19
    00CB6 9E82      MUL	R8,R18
    00CB7 0D80      ADD	R24,R0
    00CB8 1D91      ADC	R25,R1
    00CB9 1FA3      ADC	R26,R19
    00CBA 1FB3      ADC	R27,R19
    00CBB 9E92      MUL	R9,R18
    00CBC 0D90      ADD	R25,R0
    00CBD 1DA1      ADC	R26,R1
    00CBE 1FB3      ADC	R27,R19
    00CBF 9EA1      MUL	R10,R17
    00CC0 0D90      ADD	R25,R0
    00CC1 1DA1      ADC	R26,R1
    00CC2 1FB3      ADC	R27,R19
    00CC3 2F2B      MOV	R18,R27
    00CC4 2F1A      MOV	R17,R26
    00CC5 2F09      MOV	R16,R25
    00CC6 0F88      LSL	R24
    00CC7 1F00      ROL	R16
    00CC8 1F11      ROL	R17
    00CC9 1F22      ROL	R18
    00CCA 1F33      ROL	R19
    00CCB 940E 0C27 CALL	normalize_and_pack
    00CCD 91B9      LD	R27,Y+
    00CCE 91A9      LD	R26,Y+
    00CCF 940E 0C7B CALL	restoreFPRegs
    00CD1 9508      RET
    00CD2 EF0F      LDI	R16,0xFF
    00CD3 2F10      MOV	R17,R16
    00CD4 E72F      LDI	R18,0x7F
    00CD5 E78F      LDI	R24,0x7F
    00CD6 2E48      MOV	R4,R24
    00CD7 CFF5      RJMP	0x0CCD
    00CD8 2700      CLR	R16
    00CD9 2F10      MOV	R17,R16
    00CDA 2F20      MOV	R18,R16
    00CDB 2F30      MOV	R19,R16
    00CDC CFF0      RJMP	0x0CCD
fpmule1:
    00CDD 93FA      ST	-Y,R31
    00CDE 93EA      ST	-Y,R30
    00CDF 81EA      LDD	R30,Y+2
    00CE0 81FB      LDD	R31,Y+3
    00CE1 940E 0C8A CALL	fpmule
    00CE3 91E9      LD	R30,Y+
    00CE4 91F9      LD	R31,Y+
    00CE5 9622      ADIW	R28,2
    00CE6 9508      RET
fpcmp:
    00CE7 940E 0B57 CALL	fpsub
    00CE9 2333      TST	R19
    00CEA F03A      BMI	0x0CF2
    00CEB 940E 0C06 CALL	tstR16_R19
    00CED F011      BEQ	0x0CF0
    00CEE E001      LDI	R16,1
    00CEF 9508      RET
    00CF0 2700      CLR	R16
    00CF1 9508      RET
    00CF2 EF0F      LDI	R16,0xFF
    00CF3 9508      RET
fpcmp1:
    00CF4 93FA      ST	-Y,R31
    00CF5 93EA      ST	-Y,R30
    00CF6 81EA      LDD	R30,Y+2
    00CF7 81FB      LDD	R31,Y+3
    00CF8 940E 0CE7 CALL	fpcmp
    00CFA 91E9      LD	R30,Y+
    00CFB 91F9      LD	R31,Y+
    00CFC 9622      ADIW	R28,2
    00CFD 2300      TST	R16
    00CFE 9508      RET
